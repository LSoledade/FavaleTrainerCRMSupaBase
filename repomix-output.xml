This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.env.example
.gitignore
client/index.html
client/src/App.tsx
client/src/assets/gym-background.svg
client/src/assets/personal-training.svg
client/src/components/admin/AuditLogViewer.tsx
client/src/components/dashboard/ChartCard.tsx
client/src/components/dashboard/Dashboard.tsx
client/src/components/dashboard/GreetingWidget.tsx
client/src/components/dashboard/KpiCard.tsx
client/src/components/dashboard/RecentActivity.tsx
client/src/components/dashboard/SourcePieChart.tsx
client/src/components/dashboard/StateBarChart.tsx
client/src/components/dashboard/TimelineChart.tsx
client/src/components/dashboard/TodayAppointmentCard.tsx
client/src/components/dashboard/UserWeatherWidget.tsx
client/src/components/dashboard/WeatherWidget.tsx
client/src/components/ErrorBoundary.tsx
client/src/components/Header.tsx
client/src/components/Layout.tsx
client/src/components/leads/LeadDialog.tsx
client/src/components/leads/LeadForm.tsx
client/src/components/leads/LeadManagement.tsx
client/src/components/leads/LeadStatusChangeNotification.tsx
client/src/components/leads/LeadTable.tsx
client/src/components/leads/TagInput.tsx
client/src/components/oauth/GoogleCalendarConfig.tsx
client/src/components/professors/ProfessorDialog.tsx
client/src/components/ProtectedRoute.tsx
client/src/components/scheduling/AppointmentDetailsDialog.tsx
client/src/components/scheduling/AppointmentDialog.tsx
client/src/components/scheduling/AppointmentsManagement.tsx
client/src/components/scheduling/MultiDateAppointmentDialog.tsx
client/src/components/scheduling/NewRecurrenceForm.tsx
client/src/components/scheduling/NewSessionForm.tsx
client/src/components/scheduling/RecurringAppointmentDialog.tsx
client/src/components/scheduling/RecurringSessionCard.tsx
client/src/components/scheduling/RecurringSessionGroup.tsx
client/src/components/scheduling/SessionCalendar.tsx
client/src/components/scheduling/SessionDetails.tsx
client/src/components/scheduling/SessionForm.tsx
client/src/components/scheduling/SessionManagement.tsx
client/src/components/scheduling/SessionReport.tsx
client/src/components/scheduling/SessionTable.tsx
client/src/components/Sidebar.tsx
client/src/components/tasks/KanbanBoard.tsx
client/src/components/tasks/TaskCard.tsx
client/src/components/tasks/TaskDetailDialog.tsx
client/src/components/tasks/TaskDetailsPage.tsx
client/src/components/tasks/TaskDialog.tsx
client/src/components/tasks/TasksPage.tsx
client/src/components/tasks/TasksWidget.tsx
client/src/components/theme-provider.tsx
client/src/components/ui/accordion.tsx
client/src/components/ui/alert-dialog.tsx
client/src/components/ui/alert.tsx
client/src/components/ui/aspect-ratio.tsx
client/src/components/ui/avatar.tsx
client/src/components/ui/badge.tsx
client/src/components/ui/breadcrumb.tsx
client/src/components/ui/button.tsx
client/src/components/ui/calendar.tsx
client/src/components/ui/card.tsx
client/src/components/ui/carousel.tsx
client/src/components/ui/chart.tsx
client/src/components/ui/checkbox.tsx
client/src/components/ui/collapsible.tsx
client/src/components/ui/command.tsx
client/src/components/ui/context-menu.tsx
client/src/components/ui/dialog.tsx
client/src/components/ui/drawer.tsx
client/src/components/ui/dropdown-menu.tsx
client/src/components/ui/form.tsx
client/src/components/ui/hover-card.tsx
client/src/components/ui/input-otp.tsx
client/src/components/ui/input.tsx
client/src/components/ui/label.tsx
client/src/components/ui/MarkdownRenderer.tsx
client/src/components/ui/menubar.tsx
client/src/components/ui/navigation-menu.tsx
client/src/components/ui/pagination.tsx
client/src/components/ui/popover.tsx
client/src/components/ui/progress.tsx
client/src/components/ui/radio-group.tsx
client/src/components/ui/resizable.tsx
client/src/components/ui/scroll-area.tsx
client/src/components/ui/select.tsx
client/src/components/ui/separator.tsx
client/src/components/ui/sheet.tsx
client/src/components/ui/sidebar.tsx
client/src/components/ui/skeleton.tsx
client/src/components/ui/slider.tsx
client/src/components/ui/switch.tsx
client/src/components/ui/table.tsx
client/src/components/ui/tabs.tsx
client/src/components/ui/textarea.tsx
client/src/components/ui/toast.tsx
client/src/components/ui/toaster.tsx
client/src/components/ui/toggle-group.tsx
client/src/components/ui/toggle.tsx
client/src/components/ui/tooltip.tsx
client/src/components/ui/use-toast.ts
client/src/components/whatsapp/WhatsappButton.tsx
client/src/components/whatsapp/WhatsappChat.tsx
client/src/components/whatsapp/WhatsappConfigForm.tsx
client/src/components/whatsapp/WhatsappModal.tsx
client/src/components/whatsapp/WhatsappTemplateSelector.tsx
client/src/config/openai.example.ts
client/src/context/LeadContext.tsx
client/src/context/TaskContext.tsx
client/src/context/WhatsappContext.tsx
client/src/global.d.ts
client/src/hooks/use-auth.tsx
client/src/hooks/use-mobile.tsx
client/src/hooks/use-toast.ts
client/src/index.css
client/src/lib/queryClient.ts
client/src/lib/utils.ts
client/src/main.tsx
client/src/pages/AuthPage.tsx
client/src/pages/CalendarPage.tsx
client/src/pages/ConfigPage.tsx
client/src/pages/DashboardPage.tsx
client/src/pages/FavaleIAPage.tsx
client/src/pages/LeadsPage.tsx
client/src/pages/not-found.tsx
client/src/pages/PrivacyPolicyPage.tsx
client/src/pages/ProfessorsPage.tsx
client/src/pages/ReportPage.tsx
client/src/pages/SecurityPage.tsx
client/src/pages/SessionsPage.tsx
client/src/pages/TaskDetailsPage.tsx
client/src/pages/TasksPage.tsx
client/src/pages/WhatsappConfigPage.tsx
client/src/pages/WhatsappPage.tsx
client/src/services/openai.ts
client/src/types/index.ts
client/src/utils/formatters.ts
client/src/utils/sessionGrouping.ts
components.json
create-tables.js
drizzle.config.ts
GEMINI.MD
generate-password.js
migrate-db.js
package.json
postcss.config.js
seed-trainers.js
seed.js
server/audit-log.ts
server/auth.ts
server/controllers/auditLog.controller.ts
server/controllers/lead.controller.ts
server/controllers/newScheduling.controller.ts
server/controllers/oauth.controller.ts
server/controllers/scheduling.controller.ts
server/controllers/stats.controller.ts
server/controllers/task.controller.ts
server/controllers/user.controller.ts
server/controllers/weather.controller.ts
server/controllers/whatsapp.controller.ts
server/db.ts
server/email-service.ts
server/google-calendar.ts
server/index.ts
server/middlewares/auth.middleware.ts
server/middlewares/error.middleware.ts
server/migrations/create-google-tokens-table.js
server/production-config.ts
server/routes.ts
server/routes/auditLog.routes.ts
server/routes/lead.routes.ts
server/routes/oauth.routes.ts
server/routes/scheduling.routes.ts
server/routes/stats.routes.ts
server/routes/task.routes.ts
server/routes/user.routes.ts
server/routes/weather.routes.ts
server/routes/whatsapp.routes.ts
server/storage.ts
server/supabase-session-store.ts
server/utils/auth.utils.ts
server/utils/lead.utils.ts
server/utils/task.utils.ts
server/validation.ts
server/vite.ts
server/weather-service.ts
server/whatsapp-service.ts
shared/schema.ts
tailwind.config.ts
tsconfig.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".env.example">
# Database Configuration (Required)
DATABASE_URL=postgresql://username:password@host:port/database

# Server Configuration
NODE_ENV=production
PORT=5000
HOST=0.0.0.0

# CORS Configuration
CORS_ORIGINS=https://yourdomain.com,https://www.yourdomain.com

# Logging Configuration
LOG_LEVEL=info

# Health Check Configuration
HEALTH_CHECK_PATH=/health
SHUTDOWN_TIMEOUT=30000

# WhatsApp Integration (Optional)
EVOLUTION_API_URL=https://your-evolution-api.com
EVOLUTION_API_TOKEN=your-evolution-api-token
EVOLUTION_API_INSTANCE=default

# Email Service (Optional)
SENDGRID_API_KEY=your-sendgrid-api-key

# Google Calendar Integration (Optional)
GOOGLE_CLIENT_ID=your-google-client-id
GOOGLE_CLIENT_SECRET=your-google-client-secret

# Weather Service (Optional)
OPENWEATHER_API_KEY=your-openweather-api-key

# Session Configuration
SESSION_SECRET=your-session-secret-key
</file>

<file path="client/index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
    <!-- This is a replit script which adds a banner on the top of the page when opened in development mode outside the replit environment -->
    <script type="text/javascript" src="https://replit.com/public/js/replit-dev-banner.js"></script>
  </body>
</html>
</file>

<file path="client/src/App.tsx">
import { Switch, Route, useLocation } from "wouter";
import { Toaster } from "@/components/ui/toaster";
import { TooltipProvider } from "@/components/ui/tooltip";
import NotFound from "@/pages/not-found";
import Layout from "@/components/Layout";
import DashboardPage from "@/pages/DashboardPage";
import LeadsPage from "@/pages/LeadsPage";
import AuthPage from "@/pages/AuthPage";
import ConfigPage from "@/pages/ConfigPage";
import SessionsPage from "@/pages/SessionsPage";
import CalendarPage from "@/pages/CalendarPage";
import ProfessorsPage from "@/pages/ProfessorsPage";
import WhatsappPage from "@/pages/WhatsappPage";
import WhatsappConfigPage from "@/pages/WhatsappConfigPage";
import ReportPage from "@/pages/ReportPage";
import TasksPage from "@/pages/TasksPage";
import TaskDetailsPage from "@/pages/TaskDetailsPage";
import { FavaleIAPage } from "@/pages/FavaleIAPage";
import ProtectedRoute from "@/components/ProtectedRoute";
import { ThemeProvider } from "@/components/theme-provider";
import { LeadProvider } from "@/context/LeadContext";
import { WhatsappProvider } from "@/context/WhatsappContext";
import { TaskProvider } from "@/context/TaskContext";
import { AuthProvider } from "@/hooks/use-auth";
import PrivacyPolicyPage from "@/pages/PrivacyPolicyPage";
import ErrorBoundary from "@/components/ErrorBoundary"; // Adicionado ErrorBoundary

function Router() {
  return (
    <Switch>
      <ProtectedRoute path="/" component={DashboardPage} />
      <ProtectedRoute path="/leads" component={LeadsPage} />
      <ProtectedRoute path="/agendamentos" component={SessionsPage} />
      <ProtectedRoute path="/calendario" component={CalendarPage} />
      <ProtectedRoute path="/professores" component={ProfessorsPage} />
      <ProtectedRoute path="/whatsapp" component={WhatsappPage} />
      <ProtectedRoute path="/whatsapp/config" component={WhatsappConfigPage} />
      <ProtectedRoute path="/favale-ia" component={FavaleIAPage} />
      <ProtectedRoute path="/tarefas" component={TasksPage} />
      <ProtectedRoute path="/tarefas/:id" component={TaskDetailsPage} />
      <ProtectedRoute path="/config" component={ConfigPage} />
      <Route path="/auth" component={AuthPage} />
      <Route path="/politica-de-privacidade" component={PrivacyPolicyPage} />
      <Route component={NotFound} />
    </Switch>
  );
}

function App() {
  const [location] = useLocation();
  const isAuthPage = location === "/auth";

  return (
    <ThemeProvider>
      <TooltipProvider>
        <AuthProvider>
          <LeadProvider>
            <WhatsappProvider>
              <TaskProvider>
                {isAuthPage ? (
                  <Router />
                ) : (
                  <Layout>
                    <Router />
                  </Layout>
                )}
                <Toaster />
              </TaskProvider>
            </WhatsappProvider>
          </LeadProvider>
        </AuthProvider>
      </TooltipProvider>
    </ThemeProvider>
  );
}

export default App;
</file>

<file path="client/src/assets/gym-background.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="800" height="600" viewBox="0 0 800 600" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <linearGradient id="bg-gradient" x1="0%" y1="0%" x2="100%" y2="100%">
      <stop offset="0%" stop-color="#3b82f6" stop-opacity="0.1" />
      <stop offset="100%" stop-color="#ec4899" stop-opacity="0.2" />
    </linearGradient>
    <filter id="filter0_d" x="0" y="0" width="800" height="600" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
      <feFlood flood-opacity="0" result="BackgroundImageFix"/>
      <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"/>
      <feOffset dy="4"/>
      <feGaussianBlur stdDeviation="2"/>
      <feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.25 0"/>
      <feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow"/>
      <feBlend mode="normal" in="SourceGraphic" in2="effect1_dropShadow" result="shape"/>
    </filter>
  </defs>
  
  <!-- Background Pattern -->
  <rect width="800" height="600" fill="url(#bg-gradient)" />
  
  <!-- Dumbbell Silhouette 1 -->
  <g transform="translate(100, 150) scale(0.8)">
    <rect x="50" y="45" width="200" height="10" rx="5" fill="#333333" opacity="0.7" />
    <circle cx="40" cy="50" r="30" fill="#333333" opacity="0.7" />
    <circle cx="260" cy="50" r="30" fill="#333333" opacity="0.7" />
  </g>
  
  <!-- Dumbbell Silhouette 2 -->
  <g transform="translate(500, 370) rotate(30) scale(0.7)">
    <rect x="50" y="45" width="200" height="10" rx="5" fill="#333333" opacity="0.7" />
    <circle cx="40" cy="50" r="30" fill="#333333" opacity="0.7" />
    <circle cx="260" cy="50" r="30" fill="#333333" opacity="0.7" />
  </g>
  
  <!-- Barbell Silhouette -->
  <g transform="translate(200, 300) scale(1.2)">
    <rect x="20" y="47" width="260" height="6" rx="3" fill="#444444" opacity="0.6" />
    <rect x="30" y="30" width="10" height="40" rx="2" fill="#444444" opacity="0.6" />
    <rect x="260" y="30" width="10" height="40" rx="2" fill="#444444" opacity="0.6" />
    <circle cx="20" cy="50" r="15" fill="#444444" opacity="0.6" />
    <circle cx="280" cy="50" r="15" fill="#444444" opacity="0.6" />
  </g>
  
  <!-- Kettlebell Silhouette -->
  <g transform="translate(570, 150) scale(0.6)">
    <path d="M50,20 L70,20 C80,20 90,30 90,50 L90,80 C90,120 50,140 50,140 C50,140 10,120 10,80 L10,50 C10,30 20,20 30,20 L50,20 Z" fill="#555555" opacity="0.6" />
    <rect x="40" y="5" width="20" height="15" rx="5" fill="#555555" opacity="0.6" />
  </g>
  
  <!-- Abstract Fitness Person Silhouette -->
  <g transform="translate(350, 250) scale(0.8)">
    <circle cx="50" cy="30" r="25" fill="#666666" opacity="0.5" /> <!-- Head -->
    <rect x="40" y="55" width="20" height="60" rx="5" fill="#666666" opacity="0.5" /> <!-- Torso -->
    <rect x="20" y="60" width="15" height="50" rx="5" transform="rotate(-30 20 60)" fill="#666666" opacity="0.5" /> <!-- Left Arm -->
    <rect x="65" y="60" width="15" height="50" rx="5" transform="rotate(30 65 60)" fill="#666666" opacity="0.5" /> <!-- Right Arm -->
    <rect x="35" y="115" width="15" height="60" rx="5" transform="rotate(10 35 115)" fill="#666666" opacity="0.5" /> <!-- Left Leg -->
    <rect x="50" y="115" width="15" height="60" rx="5" transform="rotate(-10 50 115)" fill="#666666" opacity="0.5" /> <!-- Right Leg -->
  </g>
  
  <!-- Logo Text Favale & Pink -->
  <g transform="translate(400, 500)" text-anchor="middle">
    <text font-family="Arial, sans-serif" font-size="14" font-weight="bold" fill="#333333" opacity="0.5">FAVALE &amp; PINK PERSONAL TRAINING</text>
  </g>
</svg>
</file>

<file path="client/src/assets/personal-training.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="800" height="600" viewBox="0 0 800 600" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <linearGradient id="bg-gradient" x1="0%" y1="0%" x2="100%" y2="100%">
      <stop offset="0%" stop-color="#3b82f6" stop-opacity="0.15" />
      <stop offset="100%" stop-color="#ec4899" stop-opacity="0.15" />
    </linearGradient>
  </defs>
  
  <!-- Background -->
  <rect width="800" height="600" fill="url(#bg-gradient)" />
  
  <!-- Personal Trainer and Client Silhouettes -->
  <g transform="translate(200, 200)">
    <!-- Trainer Silhouette -->
    <circle cx="0" cy="-70" r="30" fill="#333" opacity="0.7" /> <!-- Head -->
    <rect x="-15" y="-40" width="30" height="80" rx="5" fill="#333" opacity="0.7" /> <!-- Torso -->
    <rect x="-50" y="-30" width="35" height="12" rx="5" fill="#333" opacity="0.7" transform="rotate(-10 -50 -30)" /> <!-- Left arm upper -->
    <rect x="-65" y="0" width="35" height="10" rx="5" fill="#333" opacity="0.7" transform="rotate(-80 -65 0)" /> <!-- Left arm lower -->
    <rect x="15" y="-30" width="35" height="12" rx="5" fill="#333" opacity="0.7" transform="rotate(30 15 -30)" /> <!-- Right arm upper -->
    <rect x="40" y="-10" width="30" height="10" rx="5" fill="#333" opacity="0.7" transform="rotate(70 40 -10)" /> <!-- Right arm lower -->
    <rect x="-20" y="40" width="15" height="60" rx="5" fill="#333" opacity="0.7" transform="rotate(10 -20 40)" /> <!-- Left leg -->
    <rect x="5" y="40" width="15" height="60" rx="5" fill="#333" opacity="0.7" transform="rotate(-10 5 40)" /> <!-- Right leg -->
    
    <!-- Client Silhouette -->
    <g transform="translate(120, 10)">
      <circle cx="0" cy="-70" r="28" fill="#444" opacity="0.6" /> <!-- Head -->
      <rect x="-15" y="-40" width="30" height="70" rx="5" fill="#444" opacity="0.6" /> <!-- Torso -->
      <rect x="-40" y="-30" width="25" height="10" rx="5" fill="#444" opacity="0.6" transform="rotate(20 -40 -30)" /> <!-- Left arm upper -->
      <rect x="-30" y="0" width="30" height="8" rx="4" fill="#444" opacity="0.6" transform="rotate(100 -30 0)" /> <!-- Left arm lower -->
      <rect x="15" y="-30" width="25" height="10" rx="5" fill="#444" opacity="0.6" transform="rotate(-20 15 -30)" /> <!-- Right arm upper -->
      <rect x="30" y="0" width="30" height="8" rx="4" fill="#444" opacity="0.6" transform="rotate(-100 30 0)" /> <!-- Right arm lower -->
      <rect x="-20" y="30" width="15" height="60" rx="5" fill="#444" opacity="0.6" transform="rotate(-15 -20 30)" /> <!-- Left leg -->
      <rect x="5" y="30" width="15" height="60" rx="5" fill="#444" opacity="0.6" transform="rotate(25 5 30)" /> <!-- Right leg -->
    </g>
  </g>
  
  <!-- Exercise Equipment -->
  <g transform="translate(500, 300)">
    <!-- Exercise Ball -->
    <circle cx="0" cy="0" r="40" fill="#555" opacity="0.5" />
    <ellipse cx="0" cy="0" rx="40" ry="10" fill="#444" opacity="0.4" />
    
    <!-- Resistance Band -->
    <path d="M-60,50 C-20,20 20,20 60,50" stroke="#666" stroke-width="4" fill="none" opacity="0.6" />
    
    <!-- Yoga Mat Rolled -->
    <g transform="translate(-80, 70)">
      <ellipse cx="0" cy="0" rx="15" ry="10" fill="#777" opacity="0.5" />
      <ellipse cx="0" cy="0" rx="15" ry="5" fill="#666" opacity="0.4" />
    </g>
  </g>
  
  <!-- Workout Notes/Plan -->
  <g transform="translate(650, 150)">
    <rect x="-30" y="-40" width="60" height="80" rx="2" fill="#eee" opacity="0.5" />
    <line x1="-20" y1="-25" x2="20" y2="-25" stroke="#777" stroke-width="1" opacity="0.6" />
    <line x1="-20" y1="-15" x2="20" y2="-15" stroke="#777" stroke-width="1" opacity="0.6" />
    <line x1="-20" y1="-5" x2="0" y2="-5" stroke="#777" stroke-width="1" opacity="0.6" />
    <line x1="-20" y1="5" x2="20" y2="5" stroke="#777" stroke-width="1" opacity="0.6" />
    <line x1="-20" y1="15" x2="10" y2="15" stroke="#777" stroke-width="1" opacity="0.6" />
  </g>
  
  <!-- Stopwatch -->
  <g transform="translate(100, 450)">
    <circle cx="0" cy="0" r="25" fill="#555" opacity="0.5" />
    <circle cx="0" cy="0" r="20" fill="#444" opacity="0.4" />
    <line x1="0" y1="0" x2="0" y2="-12" stroke="#777" stroke-width="2" opacity="0.8" />
    <line x1="0" y1="0" x2="8" y2="8" stroke="#777" stroke-width="2" opacity="0.8" />
  </g>
  
  <!-- Water Bottle -->
  <g transform="translate(150, 420)">
    <rect x="-7" y="-20" width="14" height="40" rx="7" fill="#666" opacity="0.5" />
    <rect x="-5" y="-25" width="10" height="5" rx="2" fill="#666" opacity="0.5" />
  </g>
  
  <!-- Logo Text Favale & Pink -->
  <g transform="translate(400, 520)" text-anchor="middle">
    <text font-family="Arial, sans-serif" font-size="18" font-weight="bold" fill="#333" opacity="0.8">FAVALE &amp; PINK</text>
    <text font-family="Arial, sans-serif" font-size="12" y="20" fill="#333" opacity="0.8">PERSONAL TRAINING</text>
  </g>
</svg>
</file>

<file path="client/src/components/admin/AuditLogViewer.tsx">
import React, { useState } from 'react';
import { useQuery } from '@tanstack/react-query';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Loader2, Search, RefreshCw, FileDown } from "lucide-react";
import { format } from 'date-fns';
import { pt } from 'date-fns/locale';

// Tipos para os logs de auditoria
interface AuditLog {
  timestamp: string;
  type: string;
  userId: string | number;
  username: string;
  ip: string;
  details: any;
}

export default function AuditLogViewer() {
  const [filter, setFilter] = useState<string>('');
  const [eventType, setEventType] = useState<string>('');
  const [limit, setLimit] = useState<number>(100);

  const { data: logs, isLoading, isError, refetch } = useQuery<AuditLog[]>({
    queryKey: ['/api/audit-logs', { count: limit }],
    queryFn: async () => {
      const response = await fetch(`/api/audit-logs?count=${limit}`);
      if (!response.ok) {
        throw new Error('Falha ao carregar logs de auditoria');
      }
      return await response.json();
    },
  });

  // Função para exportar logs para CSV
  const exportToCSV = () => {
    if (!logs) return;

    const headers = ['Data e Hora', 'Tipo de Evento', 'Usuário', 'ID do Usuário', 'IP', 'Detalhes'];
    
    // Converter logs para linhas CSV
    const rows = logs
      .filter(log => filterLog(log))
      .map(log => [
        format(new Date(log.timestamp), 'dd/MM/yyyy HH:mm:ss', { locale: pt }),
        log.type,
        log.username,
        log.userId,
        log.ip,
        JSON.stringify(log.details)
      ]);
    
    // Combinar cabeçalho e linhas
    const csvContent = [
      headers.join(','),
      ...rows.map(row => row.map(cell => `"${cell}"`).join(','))
    ].join('\n');
    
    // Criar blob e link para download
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.setAttribute('href', url);
    link.setAttribute('download', `logs-auditoria-${format(new Date(), 'yyyy-MM-dd')}.csv`);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  // Filtro de logs
  const filterLog = (log: AuditLog) => {
    // Filtrar por tipo de evento
    if (eventType && eventType !== 'all' && log.type !== eventType) {
      return false;
    }
    
    // Filtrar por texto de pesquisa
    if (filter) {
      const searchLower = filter.toLowerCase();
      return (
        log.username.toLowerCase().includes(searchLower) ||
        log.type.toLowerCase().includes(searchLower) ||
        log.ip.toLowerCase().includes(searchLower) ||
        JSON.stringify(log.details).toLowerCase().includes(searchLower)
      );
    }
    
    return true;
  };

  // Formatar tipo de evento para exibição
  const formatEventType = (type: string) => {
    const eventTypes: Record<string, string> = {
      LOGIN_SUCCESS: 'Login com Sucesso',
      LOGIN_FAILURE: 'Falha no Login',
      LOGOUT: 'Logout',
      USER_CREATED: 'Usuário Criado',
      USER_UPDATED: 'Usuário Atualizado',
      USER_DELETED: 'Usuário Excluído',
      LEAD_CREATED: 'Lead Criado',
      LEAD_UPDATED: 'Lead Atualizado',
      LEAD_DELETED: 'Lead Excluído',
      LEAD_BATCH_UPDATE: 'Atualização em Lote de Leads',
      LEAD_BATCH_DELETE: 'Exclusão em Lote de Leads'
    };
    
    return eventTypes[type] || type;
  };

  // Obter tipos de eventos únicos para o filtro
  const eventTypes = logs 
    ? logs.reduce<string[]>((types, log) => {
        if (!types.includes(log.type)) {
          types.push(log.type);
        }
        return types;
      }, [])
    : [];

  // Filtrar logs
  const filteredLogs = logs?.filter(filterLog) || [];

  if (isError) {
    return (
      <Card className="w-full">
        <CardHeader>
          <CardTitle>Logs de Auditoria</CardTitle>
          <CardDescription>Registro de atividades do sistema</CardDescription>
        </CardHeader>
        <CardContent>
          <div className="flex items-center justify-center p-6 text-red-500">
            Erro ao carregar os logs de auditoria. Por favor, tente novamente.
          </div>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card className="w-full">
      <CardHeader>
        <CardTitle>Logs de Auditoria</CardTitle>
        <CardDescription>Registro de atividades do sistema</CardDescription>
      </CardHeader>
      <CardContent>
        <div className="flex flex-col md:flex-row gap-4 mb-6">
          <div className="flex-1 relative">
            <Input
              placeholder="Pesquisar logs..."
              value={filter}
              onChange={(e) => setFilter(e.target.value)}
              className="pl-10"
            />
            <Search className="absolute left-3 top-2.5 h-5 w-5 text-gray-400" />
          </div>
          
          <Select value={eventType} onValueChange={setEventType}>
            <SelectTrigger className="w-full md:w-[200px]">
              <SelectValue placeholder="Tipo de Evento" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="all">Todos os Eventos</SelectItem>
              {eventTypes.map(type => (
                <SelectItem key={type} value={type}>
                  {formatEventType(type)}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
          
          <Select 
            value={limit.toString()} 
            onValueChange={(value) => setLimit(parseInt(value))}
          >
            <SelectTrigger className="w-full md:w-[150px]">
              <SelectValue placeholder="Limite" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="50">50 registros</SelectItem>
              <SelectItem value="100">100 registros</SelectItem>
              <SelectItem value="200">200 registros</SelectItem>
              <SelectItem value="500">500 registros</SelectItem>
              <SelectItem value="1000">1000 registros</SelectItem>
            </SelectContent>
          </Select>
          
          <div className="flex gap-2">
            <Button variant="outline" onClick={() => refetch()} title="Atualizar">
              <RefreshCw className="h-4 w-4 mr-2" />
              Atualizar
            </Button>
            <Button variant="outline" onClick={exportToCSV} title="Exportar CSV">
              <FileDown className="h-4 w-4 mr-2" />
              Exportar
            </Button>
          </div>
        </div>
        
        {isLoading ? (
          <div className="flex items-center justify-center p-6">
            <Loader2 className="h-8 w-8 animate-spin text-primary" />
          </div>
        ) : filteredLogs.length === 0 ? (
          <div className="flex items-center justify-center p-6 text-gray-500">
            Nenhum log encontrado com os filtros atuais.
          </div>
        ) : (
          <div className="rounded-md border overflow-hidden">
            <div className="overflow-x-auto">
              <table className="w-full text-sm">
                <thead className="bg-gray-100 dark:bg-gray-800">
                  <tr>
                    <th className="px-4 py-3 text-left">Data e Hora</th>
                    <th className="px-4 py-3 text-left">Tipo de Evento</th>
                    <th className="px-4 py-3 text-left">Usuário</th>
                    <th className="px-4 py-3 text-left">IP</th>
                    <th className="px-4 py-3 text-left">Detalhes</th>
                  </tr>
                </thead>
                <tbody className="divide-y">
                  {filteredLogs.map((log, index) => (
                    <tr key={index} className="hover:bg-gray-50 dark:hover:bg-gray-700">
                      <td className="px-4 py-3 align-top">
                        {format(new Date(log.timestamp), 'dd/MM/yyyy HH:mm:ss', { locale: pt })}
                      </td>
                      <td className="px-4 py-3 align-top">
                        <span 
                          className={`px-2 py-1 rounded-full text-xs font-medium ${
                            log.type.includes('LOGIN_FAILURE') ? 'bg-red-100 text-red-800 dark:bg-red-900/30 dark:text-red-300' :
                            log.type.includes('DELETED') ? 'bg-orange-100 text-orange-800 dark:bg-orange-900/30 dark:text-orange-300' :
                            log.type.includes('CREATED') ? 'bg-green-100 text-green-800 dark:bg-green-900/30 dark:text-green-300' :
                            log.type.includes('UPDATED') ? 'bg-blue-100 text-blue-800 dark:bg-blue-900/30 dark:text-blue-300' :
                            'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300'
                          }`}
                        >
                          {formatEventType(log.type)}
                        </span>
                      </td>
                      <td className="px-4 py-3 align-top">{log.username}</td>
                      <td className="px-4 py-3 align-top">{log.ip}</td>
                      <td className="px-4 py-3 align-top">
                        <div className="max-w-xs whitespace-normal break-words">
                          {Object.entries(log.details || {}).map(([key, value]) => (
                            <div key={key} className="mb-1">
                              <span className="font-medium">{key}:</span>{' '}
                              {typeof value === 'object' ? JSON.stringify(value) : String(value)}
                            </div>
                          ))}
                        </div>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </div>
        )}
        
        <div className="mt-4 text-sm text-gray-500">
          Mostrando {filteredLogs.length} de {logs?.length || 0} registros
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="client/src/components/dashboard/ChartCard.tsx">
import { ReactNode } from "react";
import { Card } from "@/components/ui/card";

interface ChartCardProps {
  title: string;
  children: ReactNode;
  className?: string;
}

export default function ChartCard({ title, children, className = "" }: ChartCardProps) {
  return (
    <Card variant="glowLifted" className={className}>
      <div className="flex justify-between items-center p-3 sm:p-4 border-b dark:border-slate-700 dark:border-primary/20">
        <h3 className="font-heading text-base sm:text-lg font-medium dark:text-white dark:glow-title truncate">{title}</h3>
        <button className="text-gray-400 hover:text-secondary dark:text-gray-300 dark:hover:text-pink-400 ml-2 transition-all duration-200 dark:hover:glow-text">
          <span className="material-icons text-base sm:text-lg">more_vert</span>
        </button>
      </div>
      <div className="p-2 sm:p-4 h-[250px] sm:h-[300px]">
        {children}
      </div>
    </Card>
  );
}
</file>

<file path="client/src/components/dashboard/Dashboard.tsx">
import { useQuery } from "@tanstack/react-query";
import KpiCard from "./KpiCard";
import ChartCard from "./ChartCard";
import SourcePieChart from "./SourcePieChart";
import StateBarChart from "./StateBarChart";
import TimelineChart from "./TimelineChart";
import TodayAppointmentCard from "./TodayAppointmentCard";
import GreetingWidget from "./GreetingWidget";
import UserWeatherWidget from "./UserWeatherWidget";
import { Button } from "../ui/button";
import { Filter } from "lucide-react";
import { useTheme } from "@/components/theme-provider";

interface DashboardStats {
  totalLeads: number;
  totalStudents: number;
  totalActiveSessions: number;
  totalCompletedSessions: number;
  sessionsPerStudent: string;
  conversionRate: string;
  leadsBySource: Record<string, number>;
  leadsByState: Record<string, number>;
  leadsByCampaign: Record<string, number>;
  totalLeadsByCampaign: number;
}

export default function Dashboard() {
  const { theme } = useTheme();
  const { data: stats, isLoading, error } = useQuery<DashboardStats>({
    queryKey: ["/api/stats"],
  });

  if (isLoading) {
    return (
      <div className="flex h-[calc(100vh-4rem)] items-center justify-center">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary dark:border-pink-400 dark:shadow-glow-md relative">
          <div className="absolute inset-0 rounded-full dark:shadow-glow-xs dark:opacity-50 animate-pulse"></div>
        </div>
      </div>
    );
  }

  if (error || !stats) {
    return (
      <div className="m-6 bg-red-50 dark:bg-red-900/20 p-6 rounded-lg text-red-600 dark:text-red-400 border border-red-200 dark:border-red-500/30 dark:shadow-glow-xs relative overflow-hidden">
        <div className="absolute top-0 right-0 -mt-1 -mr-1 bg-red-100 dark:bg-red-500/20 p-3 rounded-bl-lg dark:shadow-glow-xs">
          <span className="material-icons text-red-500 dark:text-red-400 dark:glow-text">error</span>
        </div>
        <h3 className="text-lg font-semibold mb-2 dark:glow-text-subtle">Erro no Dashboard</h3>
        <p>Erro ao carregar estatísticas do dashboard. Tente novamente mais tarde.</p>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Greeting & Weather Widgets */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4 md:gap-6">
        <div className="md:col-span-2">
          <GreetingWidget />
        </div>
        <div className="md:col-span-1">
          <UserWeatherWidget />
        </div>
      </div>
      
      {/* KPI Cards - Row 1 */}
      <div className="grid grid-cols-2 md:grid-cols-2 lg:grid-cols-4 gap-4 md:gap-6">
        <div className="bg-white dark:bg-gray-800 p-6 rounded-xl shadow-sm border border-gray-100 dark:border-gray-700">
          <div className="flex justify-between mb-4">
            <h3 className="text-base font-medium text-gray-500 dark:text-gray-400">Total de Leads</h3>
          </div>
          <div className="flex items-center gap-4">
            <div className="flex items-center justify-center w-10 h-10 rounded-lg bg-primary-light bg-opacity-20 dark:bg-primary/30">
              <span className="material-icons text-primary dark:text-primary-light">people</span>
            </div>
            <div>
              <div className="text-2xl font-bold text-gray-800 dark:text-white">{stats.totalLeads}</div>
              <div className="flex items-center gap-1">
                <span className="text-xs text-green-600 dark:text-green-400">+5%</span>
                <span className="text-xs text-gray-500 dark:text-gray-400">vs. último mês</span>
              </div>
            </div>
          </div>
        </div>
        
        <div className="bg-white dark:bg-gray-800 p-6 rounded-xl shadow-sm border border-gray-100 dark:border-gray-700">
          <div className="flex justify-between mb-4">
            <h3 className="text-base font-medium text-gray-500 dark:text-gray-400">Total de Alunos</h3>
          </div>
          <div className="flex items-center gap-4">
            <div className="flex items-center justify-center w-10 h-10 rounded-lg bg-green-100 dark:bg-green-900/30">
              <span className="material-icons text-green-600 dark:text-green-400">school</span>
            </div>
            <div>
              <div className="text-2xl font-bold text-gray-800 dark:text-white">{stats.totalStudents}</div>
              <div className="flex items-center gap-1">
                <span className="text-xs text-green-600 dark:text-green-400">+10%</span>
                <span className="text-xs text-gray-500 dark:text-gray-400">vs. último mês</span>
              </div>
            </div>
          </div>
        </div>
        
        <div className="bg-white dark:bg-gray-800 p-6 rounded-xl shadow-sm border border-gray-100 dark:border-gray-700">
          <div className="flex justify-between mb-4">
            <h3 className="text-base font-medium text-gray-500 dark:text-gray-400">Taxa de Conversão</h3>
          </div>
          <div className="flex items-center gap-4">
            <div className="flex items-center justify-center w-10 h-10 rounded-lg bg-amber-100 dark:bg-amber-900/30">
              <span className="material-icons text-amber-600 dark:text-amber-400">trending_up</span>
            </div>
            <div>
              <div className="text-2xl font-bold text-gray-800 dark:text-white">{stats.conversionRate}%</div>
              <div className="flex items-center gap-1">
                <span className="text-xs text-green-600 dark:text-green-400">+3%</span>
                <span className="text-xs text-gray-500 dark:text-gray-400">vs. último mês</span>
              </div>
            </div>
          </div>
        </div>
        
        <div className="bg-white dark:bg-gray-800 p-6 rounded-xl shadow-sm border border-gray-100 dark:border-gray-700">
          <div className="flex justify-between mb-4">
            <h3 className="text-base font-medium text-gray-500 dark:text-gray-400">Sessões por Aluno</h3>
          </div>
          <div className="flex items-center gap-4">
            <div className="flex items-center justify-center w-10 h-10 rounded-lg bg-secondary-light bg-opacity-20 dark:bg-secondary/30">
              <span className="material-icons text-secondary-light dark:text-secondary-light/80">fitness_center</span>
            </div>
            <div>
              <div className="text-2xl font-bold text-gray-800 dark:text-white">{stats.sessionsPerStudent}</div>
              <div className="flex items-center gap-1">
                <span className="text-xs text-green-600 dark:text-green-400">+8%</span>
                <span className="text-xs text-gray-500 dark:text-gray-400">vs. último mês</span>
              </div>
            </div>
          </div>
        </div>
      </div>
      
      {/* KPI Cards - Row 2 */}
      <div className="grid grid-cols-2 md:grid-cols-2 lg:grid-cols-4 gap-4 md:gap-6">
        <div className="bg-white dark:bg-gray-800 p-6 rounded-xl shadow-sm border border-gray-100 dark:border-gray-700">
          <div className="flex justify-between mb-4">
            <h3 className="text-base font-medium text-gray-500 dark:text-gray-400">Sessões Agendadas</h3>
          </div>
          <div className="flex items-center gap-4">
            <div className="flex items-center justify-center w-10 h-10 rounded-lg bg-blue-100 dark:bg-blue-900/30">
              <span className="material-icons text-blue-600 dark:text-blue-400">event_available</span>
            </div>
            <div>
              <div className="text-2xl font-bold text-gray-800 dark:text-white">{stats.totalActiveSessions}</div>
              <div className="flex items-center gap-1">
                <span className="text-xs text-green-600 dark:text-green-400">+12%</span>
                <span className="text-xs text-gray-500 dark:text-gray-400">vs. último mês</span>
              </div>
            </div>
          </div>
        </div>
        
        <div className="bg-white dark:bg-gray-800 p-6 rounded-xl shadow-sm border border-gray-100 dark:border-gray-700">
          <div className="flex justify-between mb-4">
            <h3 className="text-base font-medium text-gray-500 dark:text-gray-400">Sessões Realizadas</h3>
          </div>
          <div className="flex items-center gap-4">
            <div className="flex items-center justify-center w-10 h-10 rounded-lg bg-teal-100 dark:bg-teal-900/30">
              <span className="material-icons text-teal-600 dark:text-teal-400">check_circle</span>
            </div>
            <div>
              <div className="text-2xl font-bold text-gray-800 dark:text-white">{stats.totalCompletedSessions}</div>
              <div className="flex items-center gap-1">
                <span className="text-xs text-green-600 dark:text-green-400">+15%</span>
                <span className="text-xs text-gray-500 dark:text-gray-400">vs. último mês</span>
              </div>
            </div>
          </div>
        </div>
        
        <div className="bg-white dark:bg-gray-800 p-6 rounded-xl shadow-sm border border-gray-100 dark:border-gray-700">
          <div className="flex justify-between mb-4">
            <h3 className="text-base font-medium text-gray-500 dark:text-gray-400">Leads por Campanha</h3>
          </div>
          <div className="flex items-center gap-4">
            <div className="flex items-center justify-center w-10 h-10 rounded-lg bg-indigo-100 dark:bg-indigo-900/30">
              <span className="material-icons text-indigo-600 dark:text-indigo-400">campaign</span>
            </div>
            <div>
              <div className="text-2xl font-bold text-gray-800 dark:text-white">{stats.totalLeadsByCampaign}</div>
              <div className="flex items-center gap-1">
                <span className="text-xs text-green-600 dark:text-green-400">+7%</span>
                <span className="text-xs text-gray-500 dark:text-gray-400">vs. último mês</span>
              </div>
            </div>
          </div>
        </div>
        
        <div className="bg-white dark:bg-gray-800 p-6 rounded-xl shadow-sm border border-gray-100 dark:border-gray-700">
          <div className="flex justify-between mb-4">
            <h3 className="text-base font-medium text-gray-500 dark:text-gray-400">Leads Novos (30d)</h3>
          </div>
          <div className="flex items-center gap-4">
            <div className="flex items-center justify-center w-10 h-10 rounded-lg bg-pink-100 dark:bg-pink-900/30">
              <span className="material-icons text-pink-600 dark:text-pink-400">new_releases</span>
            </div>
            <div>
              <div className="text-2xl font-bold text-gray-800 dark:text-white">{Math.round(stats.totalLeads * 0.23)}</div>
              <div className="flex items-center gap-1">
                <span className="text-xs text-green-600 dark:text-green-400">+18%</span>
                <span className="text-xs text-gray-500 dark:text-gray-400">vs. último mês</span>
              </div>
            </div>
          </div>
        </div>
      </div>
      
      {/* Charts Row */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 md:gap-6">
        <div className="bg-white dark:bg-gray-800 p-6 rounded-xl shadow-sm border border-gray-100 dark:border-gray-700 md:col-span-1">
          <div className="flex justify-between items-center mb-4">
            <h3 className="text-base font-medium text-gray-800 dark:text-white">Distribuição por Origem</h3>
          </div>
          <div className="h-64">
            <SourcePieChart data={stats.leadsBySource} />
          </div>
        </div>
        
        <div className="bg-white dark:bg-gray-800 p-6 rounded-xl shadow-sm border border-gray-100 dark:border-gray-700 md:col-span-1 lg:col-span-2">
          <div className="flex justify-between items-center mb-4">
            <h3 className="text-base font-medium text-gray-800 dark:text-white">Leads por Estado</h3>
          </div>
          <div className="h-64">
            <StateBarChart data={stats.leadsByState} />
          </div>
        </div>
      </div>
      
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 md:gap-6">
        <div className="bg-white dark:bg-gray-800 p-6 rounded-xl shadow-sm border border-gray-100 dark:border-gray-700 md:col-span-2">
          <div className="flex justify-between items-center mb-4">
            <h3 className="text-base font-medium text-gray-800 dark:text-white">Leads ao Longo do Tempo</h3>
          </div>
          <div className="h-64">
            <TimelineChart />
          </div>
        </div>
        
        <div className="bg-white dark:bg-gray-800 p-6 rounded-xl shadow-sm border border-gray-100 dark:border-gray-700 md:col-span-2 lg:col-span-1">
          <TodayAppointmentCard />
        </div>
      </div>
    </div>
  );
}
</file>

<file path="client/src/components/dashboard/GreetingWidget.tsx">
import { useEffect, useState } from 'react';
import { useQuery } from '@tanstack/react-query';
import { Card, CardContent } from '@/components/ui/card';
import { Skeleton } from '@/components/ui/skeleton';
import { Sun, Moon, Sunrise, Coffee } from 'lucide-react';

export default function GreetingWidget() {
  const [greeting, setGreeting] = useState('');
  const [welcomeMessage, setWelcomeMessage] = useState('');
  const [icon, setIcon] = useState<JSX.Element>(<Coffee className="h-8 w-8 text-primary" />);
  
  // Busca os dados do usuário logado
  const { data: user, isLoading } = useQuery({
    queryKey: ['/api/user'],
  });
  
  // Define a saudação com base na hora do dia
  useEffect(() => {
    const updateGreeting = () => {
      const currentHour = new Date().getHours();
      
      if (currentHour >= 5 && currentHour < 12) {
        setGreeting('Bom dia');
        setWelcomeMessage('Comece seu dia com energia e foco!');
        setIcon(<Sunrise className="h-8 w-8 text-amber-500" />);
      } else if (currentHour >= 12 && currentHour < 18) {
        setGreeting('Boa tarde');
        setWelcomeMessage('Aproveite a produtividade da tarde!');
        setIcon(<Sun className="h-8 w-8 text-yellow-500" />);
      } else {
        setGreeting('Boa noite');
        setWelcomeMessage('Descanse bem após um dia produtivo!');
        setIcon(<Moon className="h-8 w-8 text-indigo-400" />);
      }
    };
    
    // Atualiza inicialmente
    updateGreeting();
    
    // Atualiza a cada minuto (para caso o usuário fique com a página aberta durante transições)
    const intervalId = setInterval(updateGreeting, 60000);
    
    // Limpeza ao desmontar
    return () => clearInterval(intervalId);
  }, []);
  
  if (isLoading) {
    return (
      <Card className="overflow-hidden">
        <CardContent className="p-6">
          <div className="flex flex-col space-y-4">
            <Skeleton className="h-8 w-48" />
            <Skeleton className="h-6 w-64" />
          </div>
        </CardContent>
      </Card>
    );
  }
  
  return (
    <Card className="overflow-hidden border-primary-100 bg-gradient-to-br from-white to-primary-50 dark:from-gray-800 dark:to-primary-900/10 dark:border-primary-900">
      <CardContent className="p-6">
        <div className="flex items-center gap-4">
          <div className="flex items-center justify-center h-12 w-12 rounded-full bg-primary-100 dark:bg-primary-900/30">
            {icon}
          </div>
          <div className="space-y-1">
            <h2 className="text-2xl font-semibold text-gray-800 dark:text-white">
              {greeting}, {user?.username || 'usuário'}!
            </h2>
            <p className="text-gray-600 dark:text-gray-300">
              {welcomeMessage}
            </p>
          </div>
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="client/src/components/dashboard/KpiCard.tsx">
interface KpiCardProps {
  title: string;
  value: number | string;
  icon: string;
  change: number;
  iconBgColor: string;
  iconColor: string;
}

import { Card } from "@/components/ui/card";

export default function KpiCard({ 
  title, 
  value, 
  icon, 
  change, 
  iconBgColor, 
  iconColor 
}: KpiCardProps) {
  return (
    <Card variant="glowIntenseLifted" className="p-4 sm:p-6">
      <div className="flex justify-between items-start">
        <div className="space-y-1 sm:space-y-2">
          <h3 className="text-xs sm:text-sm font-medium text-gray-500 dark:text-gray-400">{title}</h3>
          <p className="text-xl sm:text-2xl font-semibold tracking-tight dark:text-white dark:glow-value">{value}</p>

          <div className={`flex flex-wrap items-center ${change >= 0 ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'}`}>
            <span className="material-icons text-sm">
              {change >= 0 ? 'trending_up' : 'trending_down'}
            </span>
            <span className="ml-1 text-sm font-medium dark:glow-text-subtle">{Math.abs(change)}%</span>
            <span className="ml-1 text-xs text-gray-500 dark:text-gray-400 hidden xs:inline">vs último mês</span>
          </div>
        </div>

        <div className={`${iconBgColor} dark:bg-opacity-20 p-2 sm:p-3 rounded-lg dark:border dark:border-primary/30 dark:shadow-glow-xs`}>
          <span className={`material-icons text-base sm:text-lg ${iconColor} dark:glow-text-subtle`}>{icon}</span>
        </div>
      </div>
    </Card>
  );
}
</file>

<file path="client/src/components/dashboard/RecentActivity.tsx">
import { useQuery } from "@tanstack/react-query";
import { Lead } from "@shared/schema";
import { formatDistanceToNow } from "date-fns";
import { ptBR } from "date-fns/locale";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";

interface Activity {
  id: string;
  type: "new" | "converted" | "campaign" | "updated" | "deleted";
  title: string;
  description: string;
  time: string;
  icon: string;
  iconBgColor: string;
  iconColor: string;
}

interface RecentActivityProps {
  className?: string;
}

import { Card } from "@/components/ui/card";

export default function RecentActivity({ className = "" }: RecentActivityProps) {
  const { data: leads, isLoading } = useQuery<Lead[]>({
    queryKey: ["/api/leads"],
  });

  const generateActivities = (leads: Lead[]): Activity[] => {
    const sortedLeads = [...leads].sort((a, b) => {
      return new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime();
    });

    const activities: Activity[] = sortedLeads.slice(0, 5).map((lead, index) => {
      const types: ("new" | "converted" | "updated" | "deleted")[] = ["new", "converted", "updated", "deleted"];
      const type = lead.status === "Aluno" ? "converted" : types[index % types.length];

      let title = "";
      let icon = "";
      let iconBgColor = "";
      let iconColor = "";

      switch (type) {
        case "new":
          title = `${lead.name} adicionado como novo lead`;
          icon = "person_add";
          iconBgColor = "bg-primary-light bg-opacity-20 dark:bg-pink-400/20";
          iconColor = "text-primary dark:text-white";
          break;
        case "converted":
          title = `${lead.name} convertido para aluno`;
          icon = "check_circle";
          iconBgColor = "bg-green-100 dark:bg-green-600/20";
          iconColor = "text-green-600 dark:text-white";
          break;
        case "updated":
          title = `${lead.name} atualizou informações de contato`;
          icon = "update";
          iconBgColor = "bg-amber-100 dark:bg-amber-600/20";
          iconColor = "text-amber-600 dark:text-white";
          break;
        case "deleted":
          title = `Lead ${lead.name} removido`;
          icon = "delete";
          iconBgColor = "bg-red-100 dark:bg-red-600/20";
          iconColor = "text-red-600 dark:text-white";
          break;
      }

      return {
        id: `activity-${lead.id}-${type}`,
        type,
        title,
        description: "",
        time: formatDistanceToNow(new Date(lead.updatedAt), { 
          addSuffix: true, 
          locale: ptBR 
        }),
        icon,
        iconBgColor,
        iconColor
      };
    });

    activities.splice(2, 0, {
      id: "activity-campaign",
      type: "campaign",
      title: "Nova campanha Verão 2023 iniciada",
      description: "",
      time: "Há 2 horas",
      icon: "campaign",
      iconBgColor: "bg-secondary-light bg-opacity-20 dark:bg-pink-400/20",
      iconColor: "text-secondary-light dark:text-white"
    });

    return activities.slice(0, 5);
  };

  const activities = leads ? generateActivities(leads) : [];

  return (
    <Card variant="glowIntenseLifted" className={`flex flex-col h-full p-3 sm:p-5 ${className}`}>
      <div className="flex justify-between items-center mb-3 sm:mb-4 border-b dark:border-primary/20 pb-3">
        <h3 className="font-heading text-base sm:text-lg font-medium dark:text-white dark:glow-title">Atividades Recentes</h3>
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <button className="text-gray-400 hover:text-secondary transition-all duration-200 dark:text-gray-300 dark:hover:text-pink-400 hover:scale-110 dark:hover:glow-text">
                <span className="material-icons text-base sm:text-lg">more_vert</span>
              </button>
            </TooltipTrigger>
            <TooltipContent>
              <p>Mais ações</p>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
      </div>

      <div className="flex-1 overflow-y-auto scrollbar-thin scrollbar-thumb-gray-200 dark:scrollbar-thumb-slate-700 scrollbar-track-transparent">
        {isLoading ? (
          <div className="flex justify-center py-4">
            <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-primary dark:border-pink-400 dark:shadow-glow-sm"></div>
          </div>
        ) : activities.length > 0 ? (
          <div className="space-y-3 sm:space-y-4">
            {activities.map((activity) => (
              <div key={activity.id} className="flex items-start group hover:bg-gray-50 dark:hover:bg-slate-700/50 dark:hover:bg-opacity-30 p-2 rounded-lg transition-all duration-200 hover-lift-sm dark:border-l dark:border-transparent dark:hover:border-primary/30 dark:hover:shadow-glow-xs">
                <div className={`${activity.iconBgColor} rounded-full w-6 h-6 sm:w-8 sm:h-8 flex items-center justify-center mr-2 sm:mr-3 flex-shrink-0 dark:shadow-glow-xs dark:border dark:border-primary/40 transition-all duration-200 group-hover:scale-110`}>
                  <span className={`material-icons text-xs sm:text-sm ${activity.iconColor} dark:glow-text-subtle`}>{activity.icon}</span>
                </div>
                <div className="min-w-0 flex-1">
                  <TooltipProvider>
                    <Tooltip>
                      <TooltipTrigger asChild>
                        <p className="text-xs sm:text-sm dark:text-white dark:group-hover:glow-text-intense truncate cursor-help transition-all duration-300">{activity.title}</p>
                      </TooltipTrigger>
                      <TooltipContent>
                        <p>{activity.title}</p>
                      </TooltipContent>
                    </Tooltip>
                  </TooltipProvider>
                  <p className="text-[10px] sm:text-xs text-gray-500 dark:text-gray-300 mt-0.5">{activity.time}</p>
                </div>
              </div>
            ))}
          </div>
        ) : (
          <p className="text-center text-xs sm:text-sm text-gray-500 dark:text-gray-300 py-4">Nenhuma atividade recente</p>
        )}
      </div>
    </Card>
  );
}
</file>

<file path="client/src/components/dashboard/SourcePieChart.tsx">
import { PieChart, Pie, Cell, ResponsiveContainer, Legend, Tooltip } from 'recharts';

interface SourcePieChartProps {
  data: Record<string, number>;
}

export default function SourcePieChart({ data }: SourcePieChartProps) {
  // Check if running in browser environment
  const isBrowser = typeof window !== 'undefined';
  const isMobile = isBrowser ? window.innerWidth < 640 : false;
  // Format data for chart
  const chartData = Object.entries(data)
    .filter(([_, value]) => value > 0)
    .map(([key, value]) => ({
      name: key,
      value: value
    }));
  
  // Calculate percentages
  const total = chartData.reduce((acc, curr) => acc + curr.value, 0);
  const formattedData = chartData.map(item => ({
    ...item,
    percentage: total > 0 ? Math.round((item.value / total) * 100) : 0
  }));
  
  // Define colors for the sources
  const COLORS = ['#ff9810', '#ed0180', '#FF5722', '#009688', '#3F51B5', '#FFC107'];
  
  // Custom tooltip
  const CustomTooltip = ({ active, payload }: any) => {
    if (active && payload && payload.length) {
      return (
        <div className="bg-white dark:bg-slate-800 shadow-md dark:shadow-black/30 rounded p-2 text-xs sm:text-sm border border-gray-100 dark:border-gray-700">
          <p className="font-semibold text-gray-800 dark:text-gray-200">{payload[0].name}</p>
          <p className="text-gray-600 dark:text-gray-300">Leads: {payload[0].value}</p>
          <p className="text-gray-600 dark:text-gray-300">{payload[0].payload.percentage}%</p>
        </div>
      );
    }
    return null;
  };
  
  return (
    <div className="w-full h-full">
      <ResponsiveContainer width="100%" height="100%">
        <PieChart>
          <Pie
            data={formattedData}
            cx="50%"
            cy="50%"
            labelLine={false}
            outerRadius={isMobile ? 60 : 80}
            fill="#8884d8"
            dataKey="value"
            label={({ name, percentage }) => (
              isMobile ? 
              `${percentage}%` : 
              `${name} (${percentage}%)`
            )}
          >
            {formattedData.map((entry, index) => (
              <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
            ))}
          </Pie>
          <Tooltip content={<CustomTooltip />} />
          <Legend 
            layout="horizontal"
            verticalAlign="bottom"
            align="center"
            wrapperStyle={{
              fontSize: isMobile ? 10 : 12,
              paddingTop: 15
            }}
          />
        </PieChart>
      </ResponsiveContainer>
    </div>
  );
}
</file>

<file path="client/src/components/dashboard/StateBarChart.tsx">
import { BarChart, Bar, XAxis, YAxis, Tooltip, ResponsiveContainer, Cell } from 'recharts';
import { useState, useEffect } from 'react';

interface StateBarChartProps {
  data: Record<string, number>;
}

export default function StateBarChart({ data }: StateBarChartProps) {
  const [darkMode, setDarkMode] = useState(false);

  // Detectar tema escuro
  useEffect(() => {
    const isDarkMode = document.documentElement.classList.contains('dark');
    setDarkMode(isDarkMode);

    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.attributeName === 'class') {
          const isDark = document.documentElement.classList.contains('dark');
          setDarkMode(isDark);
        }
      });
    });

    observer.observe(document.documentElement, { attributes: true });
    return () => observer.disconnect();
  }, []);

  // Format data for chart
  const chartData = Object.entries(data || {})
    .filter(([_, count]) => count > 0)
    .map(([state, count]) => ({ state, count }))
    .sort((a, b) => b.count - a.count)
    .slice(0, 7); // Take top 7 states
  
  // Cores para barras no tema claro e escuro
  const barColors = darkMode ? 
    ['#E91E63', '#D81B60', '#C2185B', '#AD1457', '#880E4F', '#6A0E4F', '#5D0E4F'] : 
    ['#E91E63', '#EC407A', '#F06292', '#F48FB1', '#F8BBD0', '#FCE4EC', '#FFEBEE'];
  
  // Custom tooltip
  const CustomTooltip = ({ active, payload, label }: any) => {
    if (active && payload && payload.length) {
      return (
        <div className="bg-white dark:bg-slate-800 shadow-md dark:shadow-primary/20 rounded p-2 text-xs sm:text-sm border border-gray-100 dark:border-gray-700">
          <p className="font-semibold text-gray-800 dark:text-gray-200">{label}</p>
          <p className="text-gray-600 dark:text-gray-300">Leads: {payload[0].value}</p>
        </div>
      );
    }
    return null;
  };
  
  // Se não houver dados, mostre uma mensagem
  if (chartData.length === 0) {
    return (
      <div className="w-full h-full flex items-center justify-center text-gray-500 dark:text-gray-400 text-sm">
        Não há dados de estados para mostrar
      </div>
    );
  }
  
  return (
    <div className="w-full overflow-auto pb-2 h-full">
      <div className="min-w-[320px] xs:min-w-[400px] sm:min-w-full h-full">
        <ResponsiveContainer width="100%" height="100%">
          <BarChart
            data={chartData}
            margin={{ top: 5, right: 20, left: 10, bottom: 5 }}
          >
            <XAxis 
              dataKey="state" 
              tick={{ fontSize: 12 }} 
              tickLine={false}
              axisLine={{ stroke: darkMode ? '#374151' : '#e5e7eb' }}
              stroke={darkMode ? '#6B7280' : '#9CA3AF'}
            />
            <YAxis 
              tickFormatter={(value) => value.toString()} 
              tick={{ fontSize: 12 }} 
              tickLine={false}
              axisLine={{ stroke: darkMode ? '#374151' : '#e5e7eb' }}
              stroke={darkMode ? '#6B7280' : '#9CA3AF'}
            />
            <Tooltip content={<CustomTooltip />} />
            <Bar 
              dataKey="count" 
              barSize={20} 
              radius={[4, 4, 0, 0]}
              className="dark:drop-shadow-glow"
            >
              {chartData.map((entry, index) => (
                <Cell 
                  key={`cell-${index}`} 
                  fill={barColors[index % barColors.length]} 
                  className={darkMode ? 'drop-shadow-glow' : ''}
                />
              ))}
            </Bar>
          </BarChart>
        </ResponsiveContainer>
      </div>
    </div>
  );
}
</file>

<file path="client/src/components/dashboard/TimelineChart.tsx">
import { useState, useEffect } from 'react';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts';
import { useQuery } from "@tanstack/react-query";

interface LeadTimeData {
  name: string;
  novosLeads: number;
  convertidos: number;
  sessoes: number;
}

export default function TimelineChart() {
  const [timeRange, setTimeRange] = useState('7d');
  const [darkMode, setDarkMode] = useState(false);
  const [chartData, setChartData] = useState<LeadTimeData[]>([]);
  
  // Dados de leads
  const { data: leads } = useQuery<any[]>({
    queryKey: ["/api/leads"],
    enabled: true,
  });
  
  // Dados de sessões
  const { data: sessions } = useQuery<any[]>({
    queryKey: ["/api/sessions"],
    enabled: true,
  });

  // Detectar tema escuro
  useEffect(() => {
    const isDarkMode = document.documentElement.classList.contains('dark');
    setDarkMode(isDarkMode);

    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.attributeName === 'class') {
          const isDark = document.documentElement.classList.contains('dark');
          setDarkMode(isDark);
        }
      });
    });

    observer.observe(document.documentElement, { attributes: true });
    return () => observer.disconnect();
  }, []);
  
  // Calcular dados para o gráfico com base nos dados reais
  useEffect(() => {
    if (!leads || !sessions) return;
    
    // Preparar datas para o período selecionado
    const today = new Date();
    const dates: Date[] = [];
    let days = 7;
    
    if (timeRange === '30d') {
      days = 30;
    } else if (timeRange === 'year') {
      days = 365;
    }
    
    // Gerar array de datas para o período
    for (let i = days - 1; i >= 0; i--) {
      const date = new Date(today);
      date.setDate(today.getDate() - i);
      dates.push(date);
    }
    
    // Formatar os dados de acordo com o período escolhido
    const generatedData: LeadTimeData[] = [];
    
    if (timeRange === 'year') {
      // Dados mensais para o ano
      const months = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
      const monthData: Record<string, LeadTimeData> = {};
      
      months.forEach(month => {
        monthData[month] = { name: month, novosLeads: 0, convertidos: 0, sessoes: 0 };
      });
      
      // Contar leads por mês
      leads.forEach(lead => {
        const date = new Date(lead.entryDate);
        if (date.getFullYear() === today.getFullYear()) {
          const month = months[date.getMonth()];
          monthData[month].novosLeads++;
          
          if (lead.status === 'Aluno') {
            monthData[month].convertidos++;
          }
        }
      });
      
      // Contar sessões por mês
      sessions.forEach(session => {
        const date = new Date(session.startTime);
        if (date.getFullYear() === today.getFullYear()) {
          const month = months[date.getMonth()];
          monthData[month].sessoes++;
        }
      });
      
      // Converter para array
      months.forEach(month => {
        generatedData.push(monthData[month]);
      });
    } else {
      // Dados diários para 7d ou 30d
      const dateFormat = new Intl.DateTimeFormat('pt-BR', { weekday: 'short' });
      const dailyData: Record<string, LeadTimeData> = {};
      
      dates.forEach(date => {
        const dayName = dateFormat.format(date).slice(0, 3);
        const dateKey = date.toISOString().split('T')[0]; // YYYY-MM-DD
        
        dailyData[dateKey] = { 
          name: dayName, 
          novosLeads: 0, 
          convertidos: 0,
          sessoes: 0 
        };
      });
      
      // Contar leads por dia
      leads.forEach(lead => {
        const leadDate = new Date(lead.entryDate);
        const dateKey = leadDate.toISOString().split('T')[0];
        
        if (dailyData[dateKey]) {
          dailyData[dateKey].novosLeads++;
          
          if (lead.status === 'Aluno') {
            dailyData[dateKey].convertidos++;
          }
        }
      });
      
      // Contar sessões por dia
      sessions.forEach(session => {
        const sessionDate = new Date(session.startTime);
        const dateKey = sessionDate.toISOString().split('T')[0];
        
        if (dailyData[dateKey]) {
          dailyData[dateKey].sessoes++;
        }
      });
      
      // Converter para array mantendo a ordem das datas
      dates.forEach(date => {
        const dateKey = date.toISOString().split('T')[0];
        if (dailyData[dateKey]) {
          generatedData.push(dailyData[dateKey]);
        }
      });
    }
    
    setChartData(generatedData);
  }, [leads, sessions, timeRange]);
  
  // Custom tooltip para melhor apresentação
  const CustomTooltip = ({ active, payload, label }: any) => {
    if (active && payload && payload.length) {
      return (
        <div className="bg-white dark:bg-slate-800 shadow-md dark:shadow-glow-xs rounded p-2 text-xs sm:text-sm border border-gray-100 dark:border-primary/30">
          <p className="font-semibold text-gray-800 dark:text-gray-200 dark:glow-text-subtle mb-1">{label}</p>
          {payload.map((entry: any, index: number) => (
            <p key={index} style={{ color: entry.color }} className="text-gray-600 dark:text-gray-300 flex items-center gap-1">
              <span className="inline-block w-2 h-2 rounded-full" style={{ backgroundColor: entry.color }}></span>
              <span className="font-medium">{entry.name}:</span> 
              <span className="dark:glow-text-subtle">{entry.value}</span>
            </p>
          ))}
        </div>
      );
    }
    return null;
  };
  
  // Se estiver carregando ou não houver dados
  if (!chartData || chartData.length === 0) {
    return (
      <div className="w-full h-full flex flex-col">
        <div className="flex justify-end mb-2 sm:mb-4">
          <div className="relative group">
            <select 
              className="text-xs sm:text-sm border rounded px-2 py-1 text-gray-700 dark:bg-slate-800 dark:border-primary/30 dark:text-gray-300 focus:outline-none dark:focus:ring-1 dark:focus:ring-primary/50 dark:focus:shadow-glow-xs transition-all duration-200 dark:hover:border-primary/50 pr-6 appearance-none opacity-70 cursor-pointer"
              value={timeRange}
              onChange={(e) => setTimeRange(e.target.value)}
              disabled
            >
              <option value="7d">Últimos 7 dias</option>
              <option value="30d">Últimos 30 dias</option>
              <option value="year">Este ano</option>
            </select>
            <div className="absolute right-2 top-1/2 -translate-y-1/2 pointer-events-none text-gray-500 dark:text-gray-400 transition-colors duration-200">
              <span className="material-icons text-sm">expand_more</span>
            </div>
          </div>
        </div>
        
        <div className="flex-1 flex items-center justify-center">
          <div className="flex flex-col items-center space-y-3">
            <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-primary dark:border-pink-400 dark:shadow-glow-sm"></div>
            <div className="text-gray-500 dark:text-gray-400 text-sm dark:glow-text-subtle">
              Carregando dados...
            </div>
          </div>
        </div>
      </div>
    );
  }
  
  return (
    <div className="w-full h-full flex flex-col">
      <div className="flex justify-end mb-2 sm:mb-4">
        <div className="relative group">
          <select 
            className="text-xs sm:text-sm border rounded px-2 py-1 text-gray-700 dark:bg-slate-800 dark:border-primary/30 dark:text-gray-300 focus:outline-none dark:focus:ring-1 dark:focus:ring-primary/50 dark:focus:shadow-glow-xs transition-all duration-200 dark:hover:border-primary/50 pr-6 appearance-none cursor-pointer"
            value={timeRange}
            onChange={(e) => setTimeRange(e.target.value)}
          >
            <option value="7d">Últimos 7 dias</option>
            <option value="30d">Últimos 30 dias</option>
            <option value="year">Este ano</option>
          </select>
          <div className="absolute right-2 top-1/2 -translate-y-1/2 pointer-events-none text-gray-500 dark:text-gray-400 dark:group-hover:text-primary/80 transition-colors duration-200">
            <span className="material-icons text-sm">expand_more</span>
          </div>
        </div>
      </div>
      
      <div className="w-full overflow-auto pb-2 flex-1">
        <div className="min-w-[320px] xs:min-w-[400px] sm:min-w-full h-full">
          <ResponsiveContainer width="100%" height="100%">
            <LineChart
              data={chartData}
              margin={{ top: 5, right: 20, left: 10, bottom: 5 }}
            >
              <CartesianGrid 
                strokeDasharray="3 3" 
                vertical={false} 
                stroke={darkMode ? '#374151' : '#e5e7eb'}
              />
              <XAxis 
                dataKey="name" 
                tick={{ fontSize: 12 }}
                tickLine={false}
                axisLine={{ stroke: darkMode ? '#374151' : '#e5e7eb' }} 
                stroke={darkMode ? '#6B7280' : '#9CA3AF'}
              />
              <YAxis 
                tick={{ fontSize: 12 }} 
                tickLine={false}
                axisLine={{ stroke: darkMode ? '#374151' : '#e5e7eb' }}
                stroke={darkMode ? '#6B7280' : '#9CA3AF'}
              />
              <Tooltip content={<CustomTooltip />} />
              <Legend 
                wrapperStyle={{ fontSize: 12, paddingTop: 10 }}
                iconType="circle"
              />
              <Line 
                type="monotone" 
                dataKey="novosLeads" 
                name="Novos Leads" 
                stroke="#E91E63" 
                strokeWidth={2} 
                dot={false}
                activeDot={{ r: 6, className: darkMode ? 'drop-shadow-glow' : '' }}
                className={darkMode ? 'drop-shadow-glow' : ''}
              />
              <Line 
                type="monotone" 
                dataKey="convertidos" 
                name="Convertidos" 
                stroke="#311B92" 
                strokeWidth={2} 
                dot={false}
                activeDot={{ r: 6, className: darkMode ? 'drop-shadow-glow-secondary' : '' }}
                className={darkMode ? 'drop-shadow-glow-secondary' : ''}
              />
              <Line 
                type="monotone" 
                dataKey="sessoes" 
                name="Sessões" 
                stroke="#009688" 
                strokeWidth={2} 
                dot={false}
                activeDot={{ r: 6 }}
              />
            </LineChart>
          </ResponsiveContainer>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="client/src/components/dashboard/TodayAppointmentCard.tsx">
import { useQuery } from "@tanstack/react-query";
import { format, isToday } from "date-fns";
import { ptBR } from "date-fns/locale";
import { CalendarClock, MapPin, User, Clock } from "lucide-react";
import { Link } from "wouter";
import { Card } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Skeleton } from "@/components/ui/skeleton";
import { TooltipProvider, Tooltip, TooltipTrigger, TooltipContent } from "@/components/ui/tooltip";

type SessionStatus = 'scheduled' | 'completed' | 'cancelled' | 'no-show';

interface Session {
  id: number;
  startTime: string;
  endTime: string;
  leadId: number;
  trainerId: number;
  location: string;
  status: SessionStatus;
  source: 'Favale' | 'Pink' | 'FavalePink';
  notes?: string;
  value?: number;
  service?: string;
}

interface TodayAppointmentCardProps {
  className?: string;
}

export default function TodayAppointmentCard({ className = "" }: TodayAppointmentCardProps) {
  // Fetch sessions from API
  const { data: sessions = [], isLoading, error } = useQuery({
    queryKey: ['/api/sessions'],
    queryFn: () => fetch('/api/sessions').then(res => res.json())
  });

  // Fetch leads for student names
  const { data: leads = [] } = useQuery({
    queryKey: ['/api/leads'],
    queryFn: () => fetch('/api/leads').then(res => res.json())
  });

  // Fetch trainers for trainer names
  const { data: trainers = [] } = useQuery({
    queryKey: ['/api/trainers'],
    queryFn: () => fetch('/api/trainers').then(res => res.json())
  });

  // Helper functions to get names from IDs
  const getStudentName = (leadId: number) => {
    const lead = leads.find((l: any) => l.id === leadId);
    return lead?.name || 'Estudante';
  };

  const getTrainerName = (trainerId: number) => {
    const trainer = trainers.find((t: any) => t.id === trainerId);
    return trainer?.name || 'Professor';
  };

  // Filter sessions for today only and sort by time
  const todaySessions = sessions
    .filter((session: any) => isToday(new Date(session.startTime)))
    .sort((a: any, b: any) => new Date(a.startTime).getTime() - new Date(b.startTime).getTime());

  const getStatusBadge = (status: string) => {
    const statusLower = status.toLowerCase();
    switch (statusLower) {
      case "agendado":
      case "scheduled":
        return <Badge variant="outline" className="bg-blue-50 text-blue-600 border-blue-200">Agendado</Badge>;
      case "concluído":
      case "completed":
        return <Badge variant="outline" className="bg-green-50 text-green-600 border-green-200">Concluído</Badge>;
      case "cancelado":
      case "cancelled":
        return <Badge variant="outline" className="bg-red-50 text-red-600 border-red-200">Cancelado</Badge>;
      case "remarcado":
      case "rescheduled":
        return <Badge variant="outline" className="bg-purple-50 text-purple-600 border-purple-200">Remarcado</Badge>;
      case "não compareceu":
      case "no-show":
        return <Badge variant="outline" className="bg-amber-50 text-amber-600 border-amber-200">Não Compareceu</Badge>;
      default:
        return <Badge variant="outline">{status}</Badge>;
    }
  };

  return (
    <Card variant="glowIntenseLifted" className={`flex flex-col h-full p-3 sm:p-5 ${className}`}>
      <div className="flex justify-between items-center mb-3 sm:mb-4 border-b dark:border-primary/20 pb-3">
        <div className="flex items-center gap-2">
          <CalendarClock className="h-5 w-5 text-[#ff9810]" />
          <h3 className="font-heading text-base sm:text-lg font-medium dark:text-white dark:glow-title">Agendamentos de Hoje</h3>
        </div>
        <Link href="/calendario">
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button variant="ghost" size="icon" className="h-8 w-8 text-gray-400 hover:text-secondary transition-all duration-200 dark:text-gray-300 dark:hover:text-pink-400 hover:scale-110 dark:hover:glow-text">
                  <span className="material-icons text-base sm:text-lg">calendar_month</span>
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Ver calendário completo</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        </Link>
      </div>

      <div className="flex-1 overflow-y-auto scrollbar-thin scrollbar-thumb-gray-200 dark:scrollbar-thumb-slate-700 scrollbar-track-transparent">
        {isLoading ? (
          <div className="space-y-3">
            <Skeleton className="h-20 w-full" />
            <Skeleton className="h-20 w-full" />
            <Skeleton className="h-20 w-full" />
          </div>
        ) : todaySessions.length === 0 ? (
          <div className="flex flex-col items-center justify-center h-32 text-center text-gray-500 dark:text-gray-400">
            <CalendarClock className="h-8 w-8 mb-2 opacity-50" />
            <p className="text-sm">Nenhum agendamento para hoje</p>
            <Link href="/agendamentos">
              <Button variant="outline" size="sm" className="mt-2 text-xs">
                Agendar Sessão
              </Button>
            </Link>
          </div>
        ) : (
          <div className="space-y-3">
            {todaySessions.map((session: Session) => (
              <div key={session.id} className={`p-3 rounded-lg border transition-colors hover:bg-gray-50 dark:hover:bg-gray-800/50 ${session.source === 'Favale' ? 'border-l-4 border-l-blue-500' : 'border-l-4 border-l-pink-500'}`}>
                <div className="flex items-start justify-between mb-2">
                  <div className="flex items-center gap-2">
                    <Clock className="h-4 w-4 text-gray-400" />
                    <span className="text-sm font-medium text-gray-900 dark:text-white">
                      {format(new Date(session.startTime), 'HH:mm')} - {format(new Date(session.endTime), 'HH:mm')}
                    </span>
                  </div>
                  {getStatusBadge(session.status)}
                </div>
                
                <div className="flex items-center gap-2 mb-1">
                  <User className="h-3.5 w-3.5 text-gray-400" />
                  <span className="text-sm text-gray-700 dark:text-gray-300">
                    {getStudentName(session.leadId)} com {getTrainerName(session.trainerId)}
                  </span>
                </div>
                
                <div className="flex items-center gap-2">
                  <MapPin className="h-3.5 w-3.5 text-gray-400" />
                  <span className="text-xs text-gray-500 dark:text-gray-400">
                    {session.location}
                  </span>
                  <Badge variant="outline" className={`ml-auto text-xs ${session.source === 'Favale' ? 'bg-blue-50 text-blue-600 border-blue-200' : 'bg-pink-50 text-pink-600 border-pink-200'}`}>
                    {session.source}
                  </Badge>
                </div>
                
                {session.notes && (
                  <div className="mt-2 text-xs text-gray-500 dark:text-gray-400 italic">
                    {session.notes}
                  </div>
                )}
              </div>
            ))}
          </div>
        )}
      </div>
    </Card>
  );
}
</file>

<file path="client/src/components/dashboard/UserWeatherWidget.tsx">
import { useState, useEffect } from 'react';
import { useQuery } from '@tanstack/react-query';
import { Skeleton } from '@/components/ui/skeleton';
import { Card, CardContent } from '@/components/ui/card';
import { Sun, Cloud, CloudRain, CloudSnow, CloudLightning, Wind, CloudFog, AlertTriangle } from 'lucide-react';
import { useToast } from '@/hooks/use-toast';

const capitalCities: Record<string, string> = {
  'AC': 'Rio Branco',
  'AL': 'Maceió',
  'AP': 'Macapá',
  'AM': 'Manaus',
  'BA': 'Salvador',
  'CE': 'Fortaleza',
  'DF': 'Brasília',
  'ES': 'Vitória',
  'GO': 'Goiânia',
  'MA': 'São Luís',
  'MT': 'Cuiabá',
  'MS': 'Campo Grande',
  'MG': 'Belo Horizonte',
  'PA': 'Belém',
  'PB': 'João Pessoa',
  'PR': 'Curitiba',
  'PE': 'Recife',
  'PI': 'Teresina',
  'RJ': 'Rio de Janeiro',
  'RN': 'Natal',
  'RS': 'Porto Alegre',
  'RO': 'Porto Velho',
  'RR': 'Boa Vista',
  'SC': 'Florianópolis',
  'SP': 'São Paulo',
  'SE': 'Aracaju',
  'TO': 'Palmas'
};

// Lista de estados que ocorrem com mais frequência para usar como fallback
const popularStates = ['SP', 'RJ', 'MG', 'BA', 'RS'];

// Mapeamento de nomes de cidades em inglês para português
const cityNameMapping: Record<string, string> = {
  "San Paulo": "São Paulo",
  "Rio De Janeiro": "Rio de Janeiro",
  "Belo Horizonte": "Belo Horizonte",
  "Brazilia": "Brasília",
  "Recife": "Recife",
  "Salvador": "Salvador",
  "Porto Allegre": "Porto Alegre",
  "Fortaleza": "Fortaleza",
  "Curitiba": "Curitiba"
};

// Converte nomes de cidades para português quando disponível
const getCityName = (apiCityName: string): string => {
  return cityNameMapping[apiCityName] || apiCityName;
};

export default function UserWeatherWidget() {
  const [userCity, setUserCity] = useState('São Paulo');
  
  // Interface para o tipo de estatísticas
  interface DashboardStats {
    totalLeads: number;
    totalStudents: number;
    totalActiveSessions: number;
    totalCompletedSessions: number;
    sessionsPerStudent: string;
    conversionRate: string;
    leadsBySource: Record<string, number>;
    leadsByState: Record<string, number>;
    leadsByCampaign: Record<string, number>;
    totalLeadsByCampaign: number;
  }
  
  // Busca as estatísticas para obter a distribuição de leads por estado
  const { data: stats, isLoading: statsLoading } = useQuery<DashboardStats>({
    queryKey: ["/api/stats"],
  });
  
  // Define a cidade baseada no estado com mais leads
  useEffect(() => {
    if (!stats || !stats.leadsByState) return;
    
    try {
      // Encontra o estado com mais leads
      let maxLeads = 0;
      let dominantState = 'SP'; // Default para São Paulo se não houver dados
      
      for (const [state, count] of Object.entries(stats.leadsByState)) {
        if (count > maxLeads) {
          maxLeads = count as number;
          dominantState = state;
        }
      }
      
      // Se o estado não estiver na lista, usa São Paulo como fallback
      if (!dominantState || !capitalCities[dominantState]) {
        dominantState = 'SP';
      }
      
      // Define a cidade baseada na capital do estado dominante
      setUserCity(capitalCities[dominantState]);
    } catch (error) {
      console.error('Erro ao determinar a cidade do usuário:', error);
      // Usa São Paulo como fallback em caso de erro
      setUserCity('São Paulo');
    }
  }, [stats]);

  if (statsLoading) {
    return (
      <Card className="overflow-hidden">
        <CardContent className="p-4">
          <div className="flex flex-col space-y-2">
            <Skeleton className="h-6 w-24" />
            <div className="flex items-center space-x-2">
              <Skeleton className="h-10 w-10 rounded-full" />
              <Skeleton className="h-8 w-16" />
            </div>
            <Skeleton className="h-4 w-32" />
          </div>
        </CardContent>
      </Card>
    );
  }

  // Interface para os dados da API do clima
  interface WeatherData {
    location: {
      name: string;
      region: string;
      country: string;
      localtime: string;
    };
    current: {
      temp_c: number;
      condition: {
        text: string;
        icon: string;
        code: number;
      };
      wind_kph: number;
      wind_dir: string;
      humidity: number;
      feelslike_c: number;
      uv: number;
    };
    error?: {
      code: number;
      message: string;
    };
  }
  
  // Busca dados do clima da API
  const { data: weather, isLoading: weatherLoading, error: weatherError } = useQuery<WeatherData>({
    queryKey: [`/api/weather/${encodeURIComponent(userCity)}`],
    retry: 1,
    refetchOnWindowFocus: false,
    staleTime: 1000 * 60 * 30, // 30 minutos
    enabled: !!userCity, // Só busca se tiver uma cidade definida
  });


  
  // Determina o ícone apropriado com base no código de condição e se é dia ou noite
  const getWeatherIcon = (code: number) => {
    // Verificar se é dia ou noite na resposta da API
    const isDay = weather?.current?.is_day === 1;
    
    // Códigos baseados na documentação da Weather API
    if (code === 1000) {
      // Céu limpo - Sol ou Lua dependendo se é dia ou noite
      return isDay ? 
        <Sun className="h-8 w-8 text-yellow-500" /> : 
        <span className="material-icons text-indigo-300 text-3xl">nightlight</span>;
    }
    
    if ([1003, 1006, 1009].includes(code)) {
      // Nublado
      return isDay ? 
        <Cloud className="h-8 w-8 text-gray-400" /> : 
        <span className="material-icons text-gray-400 text-3xl">nights_stay</span>;
    }
    
    if ([1063, 1180, 1183, 1186, 1189, 1192, 1195, 1240, 1243, 1246].includes(code)) 
      return <CloudRain className="h-8 w-8 text-blue-400" />; // Chuva
      
    if ([1066, 1114, 1117, 1210, 1213, 1216, 1219, 1222, 1225, 1255, 1258].includes(code)) 
      return <CloudSnow className="h-8 w-8 text-blue-200" />; // Neve
      
    if ([1087, 1273, 1276, 1279, 1282].includes(code)) 
      return <CloudLightning className="h-8 w-8 text-yellow-400" />; // Tempestade
      
    if ([1030, 1135, 1147].includes(code)) 
      return <CloudFog className="h-8 w-8 text-gray-300" />; // Neblina
      
    if ([1069, 1072, 1150, 1153, 1168, 1171, 1198, 1201, 1204, 1207, 1249, 1252, 1261, 1264].includes(code)) 
      return <CloudRain className="h-8 w-8 text-gray-400" />; // Garoa
      
    return <Wind className="h-8 w-8 text-blue-300" />; // Padrão
  };

  // Se estiver carregando os dados do clima, mostra um componente de carregamento
  if (weatherLoading) {
    return (
      <Card className="overflow-hidden">
        <CardContent className="p-4">
          <div className="flex flex-col space-y-2">
            <Skeleton className="h-6 w-24" />
            <div className="flex items-center space-x-2">
              <Skeleton className="h-10 w-10 rounded-full" />
              <Skeleton className="h-8 w-16" />
            </div>
            <Skeleton className="h-4 w-32" />
          </div>
        </CardContent>
      </Card>
    );
  }

  // Se houve um erro ou não há dados do clima
  if (weatherError || !weather || weather.error) {
    return (
      <Card className="overflow-hidden border-yellow-200 bg-yellow-50 dark:border-yellow-700 dark:bg-yellow-900/20">
        <CardContent className="p-4">
          <div className="flex items-center space-x-3">
            <AlertTriangle className="h-8 w-8 text-yellow-500" />
            <div>
              <p className="text-sm text-yellow-600 dark:text-yellow-400">
                Não foi possível obter dados do clima
              </p>
            </div>
          </div>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card className="overflow-hidden border-blue-100 dark:border-blue-900">
      <CardContent className="p-4">
        <div className="flex flex-col">
          <h3 className="text-sm font-medium text-blue-800 dark:text-blue-300">
            Clima em {getCityName(weather.location.name)}
          </h3>
          
          <div className="mt-2 mb-2 flex items-center space-x-3">
            <div>
              {getWeatherIcon(weather.current.condition.code)}
            </div>
            <div className="flex flex-col">
              <span className="text-2xl font-bold text-gray-800 dark:text-white">
                {Math.round(weather.current.temp_c)}°C
              </span>
              <span className="text-xs text-gray-500 dark:text-gray-400">
                Sensação {Math.round(weather.current.feelslike_c)}°C
              </span>
            </div>
          </div>
          
          <p className="text-sm text-gray-600 dark:text-gray-300">
            {weather.current.condition.text}
          </p>
          
          <div className="mt-2 grid grid-cols-2 gap-2 text-xs text-gray-500 dark:text-gray-400">
            <div>
              Umidade: {weather.current.humidity}%
            </div>
            <div>
              Vento: {Math.round(weather.current.wind_kph)} km/h
            </div>
          </div>
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="client/src/components/dashboard/WeatherWidget.tsx">
import { useState, useEffect } from 'react';
import { useQuery } from '@tanstack/react-query';
import { Sun, Cloud, CloudRain, CloudSnow, CloudLightning, Wind, CloudFog, AlertTriangle } from 'lucide-react';
import { Card, CardContent } from '@/components/ui/card';
import { Skeleton } from '@/components/ui/skeleton';
import { useToast } from '@/hooks/use-toast';

interface WeatherData {
  location: {
    name: string;
    region: string;
    country: string;
    localtime: string;
  };
  current: {
    temp_c: number;
    condition: {
      text: string;
      icon: string;
      code: number;
    };
    wind_kph: number;
    wind_dir: string;
    humidity: number;
    feelslike_c: number;
    uv: number;
  };
  error?: {
    code: number;
    message: string;
  };
}

export default function WeatherWidget({ city = "São Paulo" }: { city?: string }) {
  const { toast } = useToast();
  const [localCity, setLocalCity] = useState(city);
  
  // Busca dados do clima da API
  const { data: weather, isLoading, error } = useQuery<WeatherData>({
    queryKey: [`/api/weather/${encodeURIComponent(localCity)}`],
    retry: 1,
    refetchOnWindowFocus: false,
    staleTime: 1000 * 60 * 30, // 30 minutos
  });

  // Determina o ícone apropriado com base no código de condição
  const getWeatherIcon = (code: number) => {
    // Códigos baseados na documentação da Weather API
    if (code === 1000) return <Sun className="h-8 w-8 text-yellow-500" />; // Ensolarado
    if ([1003, 1006, 1009].includes(code)) return <Cloud className="h-8 w-8 text-gray-400" />; // Nublado
    if ([1063, 1180, 1183, 1186, 1189, 1192, 1195, 1240, 1243, 1246].includes(code)) 
      return <CloudRain className="h-8 w-8 text-blue-400" />; // Chuva
    if ([1066, 1114, 1117, 1210, 1213, 1216, 1219, 1222, 1225, 1255, 1258].includes(code)) 
      return <CloudSnow className="h-8 w-8 text-blue-200" />; // Neve
    if ([1087, 1273, 1276, 1279, 1282].includes(code)) 
      return <CloudLightning className="h-8 w-8 text-yellow-400" />; // Tempestade
    if ([1030, 1135, 1147].includes(code)) 
      return <CloudFog className="h-8 w-8 text-gray-300" />; // Neblina
    if ([1069, 1072, 1150, 1153, 1168, 1171, 1198, 1201, 1204, 1207, 1249, 1252, 1261, 1264].includes(code)) 
      return <CloudRain className="h-8 w-8 text-gray-400" />; // Garoa
      
    return <Wind className="h-8 w-8 text-blue-300" />; // Padrão
  };

  // Se estiver carregando, mostra um componente de carregamento
  if (isLoading) {
    return (
      <Card className="overflow-hidden">
        <CardContent className="p-4">
          <div className="flex flex-col space-y-2">
            <Skeleton className="h-6 w-24" />
            <div className="flex items-center space-x-2">
              <Skeleton className="h-10 w-10 rounded-full" />
              <Skeleton className="h-8 w-16" />
            </div>
            <Skeleton className="h-4 w-32" />
          </div>
        </CardContent>
      </Card>
    );
  }

  // Se houve um erro ou não há dados do clima
  if (error || !weather || weather.error) {
    return (
      <Card className="overflow-hidden border-yellow-200 bg-yellow-50 dark:border-yellow-700 dark:bg-yellow-900/20">
        <CardContent className="p-4">
          <div className="flex items-center space-x-3">
            <AlertTriangle className="h-8 w-8 text-yellow-500" />
            <div>
              <p className="text-sm text-yellow-600 dark:text-yellow-400">
                Não foi possível obter dados do clima
              </p>
            </div>
          </div>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card className="overflow-hidden border-blue-100 dark:border-blue-900">
      <CardContent className="p-4">
        <div className="flex flex-col">
          <h3 className="text-sm font-medium text-blue-800 dark:text-blue-300">
            Clima em {weather.location.name}
          </h3>
          
          <div className="mt-2 mb-2 flex items-center space-x-3">
            <div>
              {getWeatherIcon(weather.current.condition.code)}
            </div>
            <div className="flex flex-col">
              <span className="text-2xl font-bold text-gray-800 dark:text-white">
                {Math.round(weather.current.temp_c)}°C
              </span>
              <span className="text-xs text-gray-500 dark:text-gray-400">
                Sensação {Math.round(weather.current.feelslike_c)}°C
              </span>
            </div>
          </div>
          
          <p className="text-sm text-gray-600 dark:text-gray-300">
            {weather.current.condition.text}
          </p>
          
          <div className="mt-2 grid grid-cols-2 gap-2 text-xs text-gray-500 dark:text-gray-400">
            <div>
              Umidade: {weather.current.humidity}%
            </div>
            <div>
              Vento: {Math.round(weather.current.wind_kph)} km/h
            </div>
          </div>
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="client/src/components/ErrorBoundary.tsx">
import React from 'react';

interface ErrorBoundaryState {
  hasError: boolean;
  error?: Error;
}

interface ErrorBoundaryProps {
  children: React.ReactNode;
  fallback?: React.ComponentType<{ error?: Error; resetError: () => void }>;
}

class ErrorBoundary extends React.Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('ErrorBoundary caught an error:', error, errorInfo);
  }

  resetError = () => {
    this.setState({ hasError: false, error: undefined });
  };

  render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        const FallbackComponent = this.props.fallback;
        return <FallbackComponent error={this.state.error} resetError={this.resetError} />;
      }

      return (
        <div className="min-h-screen flex items-center justify-center bg-gray-50 dark:bg-gray-900">
          <div className="max-w-md w-full bg-white dark:bg-gray-800 shadow-lg rounded-lg p-6">
            <div className="flex items-center justify-center w-12 h-12 mx-auto bg-red-100 dark:bg-red-900 rounded-full mb-4">
              <svg className="w-6 h-6 text-red-600 dark:text-red-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z" />
              </svg>
            </div>
            <h1 className="text-center text-xl font-semibold text-gray-900 dark:text-white mb-2">
              Oops! Algo deu errado
            </h1>
            <p className="text-center text-gray-600 dark:text-gray-400 mb-6">
              Ocorreu um erro inesperado. Tente recarregar a página ou entre em contato com o suporte.
            </p>
            <div className="flex gap-3">
              <button
                onClick={this.resetError}
                className="flex-1 bg-primary text-white py-2 px-4 rounded-md hover:bg-primary/90 transition-colors"
              >
                Tentar novamente
              </button>
              <button
                onClick={() => window.location.reload()}
                className="flex-1 bg-gray-600 text-white py-2 px-4 rounded-md hover:bg-gray-700 transition-colors"
              >
                Recarregar página
              </button>
            </div>
            {this.state.error && (
              <details className="mt-4 text-sm">
                <summary className="cursor-pointer text-gray-500 dark:text-gray-400">
                  Detalhes técnicos
                </summary>
                <pre className="mt-2 p-2 bg-gray-100 dark:bg-gray-700 rounded text-xs overflow-auto">
                  {this.state.error.message}
                </pre>
              </details>
            )}
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}

export default ErrorBoundary;
</file>

<file path="client/src/components/Header.tsx">
import { useLocation, Link } from "wouter";
import { useTheme } from "@/components/theme-provider";
import { useAuth } from "@/hooks/use-auth";
import { Button } from "@/components/ui/button";
import { Avatar, AvatarFallback } from "@/components/ui/avatar";
import { LogOut, User, Sun, Moon } from "lucide-react";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";

interface HeaderProps {
  setSidebarOpen: (open: boolean) => void;
}

export default function Header({ setSidebarOpen }: HeaderProps) {
  const [location] = useLocation();
  const { theme, setTheme } = useTheme();
  const { user, logoutMutation } = useAuth();
  
  const toggleTheme = () => {
    setTheme(theme === "light" ? "dark" : "light");
  };
  
  const getThemeIcon = () => {
    return theme === "light" ? <Moon className="h-4 w-4" /> : <Sun className="h-4 w-4" />;
  };
  
  const getThemeTitle = () => {
    return theme === "light" ? "Mudar para tema escuro" : "Mudar para tema claro";
  };
  
  const getPageTitle = () => {
    switch (location) {
      case "/":
        return "Dashboard";
      case "/leads":
        return "Leads";
      case "/agendamentos":
        return "Agendamentos";
      case "/calendario":
        return "Calendário";
      case "/tarefas":
        return "Tarefas";
      case "/whatsapp":
        return "WhatsApp";
      case "/whatsapp/config":
        return "Configurações do WhatsApp";
      case "/favale-ia":
        return "FavaleIA";
      case "/config":
        return "Configurações";
      case "/auth":
        return "Autenticação";
      case "/politica-de-privacidade":
        return "Política de Privacidade";
      default:
        // Para rotas dinâmicas como /tarefas/:id
        if (location.startsWith("/tarefas/")) {
          return "Detalhes da Tarefa";
        }
        return "FavaleTrainer";
    }
  };
  
  return (
    <header className="h-16 flex items-center justify-between z-10 mb-2">
      <div className="flex items-center">
        <button 
          className="lg:hidden mr-2 p-1.5 rounded-md hover:bg-gray-100 dark:hover:bg-gray-800"
          onClick={() => setSidebarOpen(true)}
        >
          <span className="material-icons text-gray-600 dark:text-gray-300">menu</span>
        </button>
        <h1 className="text-xl font-semibold text-gray-800 dark:text-white">
          {getPageTitle()}
        </h1>
      </div>
      
      <div className="flex items-center space-x-2">
        <Button 
          variant="outline" 
          size="sm"
          onClick={toggleTheme}
          className="font-normal text-gray-600 dark:text-gray-300 border-gray-200 dark:border-gray-700 flex items-center gap-1 h-9"
          title={getThemeTitle()}
        >
          {getThemeIcon()}
        </Button>
        
        <DropdownMenu>
          <DropdownMenuTrigger asChild>
            <div className="flex items-center cursor-pointer ml-2">
              <Avatar className="h-9 w-9 border-2 border-white dark:border-gray-800 ring-2 ring-gray-200 dark:ring-gray-700">
                <AvatarFallback className="text-sm font-medium text-white bg-gray-700">
                  {user?.username.substring(0, 2).toUpperCase() || "LW"}
                </AvatarFallback>
              </Avatar>
              <div className="ml-2 hidden sm:block">
                <div className="text-sm font-medium text-gray-800 dark:text-white">{user?.username || "Leslie Watson"}</div>
                <div className="text-xs text-gray-500 dark:text-gray-400">Admin</div>
              </div>
            </div>
          </DropdownMenuTrigger>
          <DropdownMenuContent align="end" className="w-56">
            <DropdownMenuLabel>Minha Conta</DropdownMenuLabel>
            <DropdownMenuSeparator />
            <Link href="/config">
              <DropdownMenuItem>
                <User className="mr-2 h-4 w-4" />
                <span>Perfil e Configurações</span>
              </DropdownMenuItem>
            </Link>
            <DropdownMenuSeparator />
            <DropdownMenuItem onClick={() => logoutMutation.mutate()}>
              <LogOut className="mr-2 h-4 w-4" />
              <span>Sair</span>
            </DropdownMenuItem>
          </DropdownMenuContent>
        </DropdownMenu>
      </div>
    </header>
  );
}
</file>

<file path="client/src/components/Layout.tsx">
import { ReactNode, useState, useEffect } from "react";
import Sidebar from "./Sidebar";
import Header from "./Header";
import { useWhatsappContext } from "@/context/WhatsappContext";
import WhatsappModal from "./whatsapp/WhatsappModal";
import { useTheme } from "@/components/theme-provider";

interface LayoutProps {
  children: ReactNode;
}

export default function Layout({ children }: LayoutProps) {
  const [sidebarOpen, setSidebarOpen] = useState(false);
  const [isMobile, setIsMobile] = useState(false);
  const [sidebarExpanded, setSidebarExpanded] = useState(true);
  const { isWhatsappOpen, selectedLeadForWhatsapp, closeWhatsappChat } = useWhatsappContext();
  const { theme } = useTheme();
  
  useEffect(() => {
    // Verificar se é mobile ao inicializar
    const checkMobile = () => {
      setIsMobile(window.innerWidth < 1024);
    };
    
    checkMobile();
    window.addEventListener('resize', checkMobile);
    
    return () => {
      window.removeEventListener('resize', checkMobile);
    };
  }, []);
  
  return (
    <div className="flex h-screen w-full bg-gray-50 dark:bg-gray-900 transition-colors duration-200">
      {/* Sidebar */}
      <Sidebar open={sidebarOpen} setOpen={setSidebarOpen} expanded={sidebarExpanded} />
      {/* Botão de expandir/recolher fixo */}
      {!isMobile && (
        <button 
          onClick={() => setSidebarExpanded(!sidebarExpanded)}
          className="fixed left-3 bottom-24 z-[9999] p-1 rounded-full hover:bg-secondary-light dark:hover:bg-gray-700 transition-all duration-300 dark:bg-gray-800 border-2 border-gray-400 dark:border-gray-600 w-10 h-10 flex items-center justify-center hover:scale-110 shadow-lg bg-[#111827]"
          title="Alternar menu"
        >
          <span className="material-icons text-white text-base font-bold">
            {sidebarExpanded ? "chevron_left" : "menu"}
          </span>
        </button>
      )}
      {/* Main Content */}
      <main className="flex-1 flex flex-col p-4">
        <Header setSidebarOpen={setSidebarOpen} />
        <div className="flex-1 p-4 bg-white dark:bg-gray-800 rounded-xl shadow-sm border border-gray-100 dark:border-gray-700 overflow-y-auto">
          {children}
        </div>
      </main>
      {/* WhatsApp Modal */}
      <WhatsappModal 
        isOpen={isWhatsappOpen} 
        onClose={closeWhatsappChat} 
        lead={selectedLeadForWhatsapp} 
      />
    </div>
  );
}
</file>

<file path="client/src/components/leads/LeadDialog.tsx">
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { useLeadContext } from "@/context/LeadContext";
import LeadForm from "./LeadForm";
import { InsertLead } from "@shared/schema";

export default function LeadDialog() {
  const { 
    isDialogOpen, 
    setIsDialogOpen, 
    selectedLead, 
    createLead, 
    updateLead 
  } = useLeadContext();

  const handleSubmit = async (data: InsertLead) => {
    if (selectedLead) {
      await updateLead(selectedLead.id, data);
    } else {
      await createLead(data);
    }
  };

  const handleClose = () => {
    setIsDialogOpen(false);
  };

  return (
    <Dialog open={isDialogOpen} onOpenChange={setIsDialogOpen}>
      <DialogContent className="sm:max-w-[650px] max-h-[90vh] overflow-y-auto bg-white dark:bg-gray-800 dark:text-gray-100 dark:border-gray-700 dark:shadow-gray-900/20 dark:shadow-glow-md">
        <DialogHeader>
          <DialogTitle>
            {selectedLead ? "Editar Lead" : "Adicionar Novo Lead"}
          </DialogTitle>
        </DialogHeader>
        <LeadForm 
          lead={selectedLead} 
          onSubmit={handleSubmit}
          onCancel={handleClose}
        />
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="client/src/components/leads/LeadForm.tsx">
import { useState, useEffect, useRef } from "react";
import { zodResolver } from "@hookform/resolvers/zod";
import { useForm, useWatch } from "react-hook-form";
import { Lead, InsertLead, leadValidationSchema } from "@shared/schema";
import TagInput from "./TagInput";
import LeadStatusChangeNotification from "./LeadStatusChangeNotification";

interface LeadFormProps {
  lead?: Lead | null;
  onSubmit: (data: InsertLead) => void;
  onCancel: () => void;
}

export default function LeadForm({ lead, onSubmit, onCancel }: LeadFormProps) {
  const [tags, setTags] = useState<string[]>(lead?.tags || []);
  const [showStatusNotification, setShowStatusNotification] = useState(false);
  const originalStatus = useRef(lead?.status || "Lead");
  const formattedData = useRef<InsertLead | null>(null);
  
  // Função para lidar com o resultado da notificação
  const handleNotificationResult = (sendNotification: boolean, message?: string) => {
    setShowStatusNotification(false);
    if (formattedData.current) {
      onSubmit(formattedData.current);
      formattedData.current = null;
    }
  };
  
  const { 
    register, 
    handleSubmit, 
    formState: { errors, isSubmitting },
    setValue, 
    reset,
    control
  } = useForm<InsertLead>({
    resolver: zodResolver(leadValidationSchema),
    defaultValues: lead || {
      entryDate: new Date(),
      name: "",
      email: "",
      phone: "",
      state: "",
      campaign: "",
      tags: [],
      source: "",
      status: "Lead",
      notes: ""
    }
  });
  
  useEffect(() => {
    if (lead) {
      // Para edição, formatar a data no formato YYYY-MM-DD para o campo date
      const entryDate = lead.entryDate instanceof Date
        ? lead.entryDate
        : new Date(lead.entryDate);
        
      const formattedDate = entryDate.toISOString().split('T')[0];
      
      reset({
        ...lead,
        entryDate: formattedDate // Apenas para exibição no input type="date"
      } as any);
      setTags(lead.tags || []);
    } else {
      // Para novo lead, usar a data atual formatada
      const today = new Date().toISOString().split('T')[0];
      setValue('entryDate', today);
    }
  }, [lead, reset, setValue]);
  
  // Watch for status field changes
  const watchStatus = useWatch({
    control,
    name: "status",
    defaultValue: lead?.status || "Lead"
  });
  
  const onSubmitHandler = handleSubmit(data => {
    try {
      // Format the entry date
      let entryDate = new Date();
      
      if (data.entryDate) {
        if (data.entryDate instanceof Date) {
          entryDate = data.entryDate;
        } else if (typeof data.entryDate === 'string') {
          // Handle different date formats (dd/mm/yyyy, mm/dd/yyyy, yyyy-mm-dd)
          const dateParts = data.entryDate.split(/[\/\-]/);
          
          // Try to determine the format and create a valid Date
          if (dateParts.length === 3) {
            // If it's in yyyy-mm-dd format (from input type="date")
            if (dateParts[0].length === 4) {
              entryDate = new Date(data.entryDate);
            } 
            // If it's in dd/mm/yyyy format (common in Brazil)
            else if (dateParts[0].length === 2 && dateParts[1].length === 2) {
              entryDate = new Date(`${dateParts[2]}-${dateParts[1]}-${dateParts[0]}`);
            } else {
              // Fallback to standard parsing
              entryDate = new Date(data.entryDate);
            }
          } else {
            // Fallback to standard parsing
            entryDate = new Date(data.entryDate);
          }
        }
      }
      
      // Validate that we got a valid date
      if (isNaN(entryDate.getTime())) {
        throw new Error('Data de entrada inválida');
      }
      
      const formData: InsertLead = {
        ...data,
        entryDate,
        tags
      };
      
      console.log('Submitting form data:', formData);
      // Enviar a data no formato ISO para evitar problemas com fusos horários
      const normalizedFormData = {
        ...formData,
        entryDate: formData.entryDate.toISOString(),
      };
      console.log('Normalized form data for submission:', normalizedFormData);
      
      // Check if status is changing from Lead to Aluno
      if (
        originalStatus.current === "Lead" && 
        data.status === "Aluno" &&
        lead?.id // Only existing leads with ID
      ) {
        // Store the formatted data and show notification dialog
        formattedData.current = normalizedFormData;
        setShowStatusNotification(true);
      } else {
        // Submit directly if no status change or not a lead->aluno transition
        onSubmit(normalizedFormData);
      }
    } catch (error) {
      console.error('Error formatting lead data:', error);
    }
  });
  
  // Handle tags updates
  const handleTagsChange = (newTags: string[]) => {
    setTags(newTags);
  };
  
  return (
    <form onSubmit={onSubmitHandler} className="space-y-4 p-2">
      <div className="mb-4">
        <h2 className="text-xl font-semibold mb-2">
          {lead ? `Editar Lead: ${lead.name}` : 'Novo Lead'}
        </h2>
      </div>
      
      {/* Nome */}
      <div className="mb-4">
        <label className="block text-sm font-medium mb-1">Nome*</label>
        <input
          type="text"
          {...register("name")}
          className="w-full px-3 py-2 border rounded-md"
          placeholder="Nome completo"
        />
        {errors.name && (
          <p className="mt-1 text-xs text-red-600">{errors.name.message}</p>
        )}
      </div>
      
      {/* Email */}
      <div className="mb-4">
        <label className="block text-sm font-medium mb-1">Email</label>
        <input
          type="email"
          {...register("email")}
          className="w-full px-3 py-2 border rounded-md"
          placeholder="email@exemplo.com"
        />
        {errors.email && (
          <p className="mt-1 text-xs text-red-600">{errors.email.message}</p>
        )}
      </div>
      
      {/* Telefone */}
      <div className="mb-4">
        <label className="block text-sm font-medium mb-1">Telefone*</label>
        <input
          type="text"
          {...register("phone")}
          className="w-full px-3 py-2 border rounded-md"
          placeholder="(xx) xxxxx-xxxx"
        />
        {errors.phone && (
          <p className="mt-1 text-xs text-red-600">{errors.phone.message}</p>
        )}
      </div>
      
      {/* Estado */}
      <div className="mb-4">
        <label className="block text-sm font-medium mb-1">Estado</label>
        <input
          type="text"
          {...register("state")}
          className="w-full px-3 py-2 border rounded-md"
          placeholder="SP, RJ, MG, etc."
        />
        {errors.state && (
          <p className="mt-1 text-xs text-red-600">{errors.state.message}</p>
        )}
      </div>
      
      {/* Origem */}
      <div className="mb-4">
        <label className="block text-sm font-medium mb-1">Origem</label>
        <select
          {...register("source")}
          className="w-full px-3 py-2 border rounded-md"
        >
          <option value="">Selecione a origem</option>
          <option value="Instagram">Instagram</option>
          <option value="Facebook">Facebook</option>
          <option value="Google">Google</option>
          <option value="Indicação">Indicação</option>
          <option value="WhatsApp">WhatsApp</option>
          <option value="Outro">Outro</option>
        </select>
        {errors.source && (
          <p className="mt-1 text-xs text-red-600">{errors.source.message}</p>
        )}
      </div>
      
      {/* Campanha */}
      <div className="mb-4">
        <label className="block text-sm font-medium mb-1">Campanha</label>
        <input
          type="text"
          {...register("campaign")}
          className="w-full px-3 py-2 border rounded-md"
          placeholder="Nome da campanha"
        />
        {errors.campaign && (
          <p className="mt-1 text-xs text-red-600">{errors.campaign.message}</p>
        )}
      </div>
      
      {/* Data de entrada */}
      <div className="mb-4">
        <label className="block text-sm font-medium mb-1">Data de entrada</label>
        <input
          type="date"
          {...register("entryDate")}
          className="w-full px-3 py-2 border rounded-md"
        />
        {errors.entryDate && (
          <p className="mt-1 text-xs text-red-600">{errors.entryDate.message}</p>
        )}
      </div>
      
      {/* Tags */}
      <div className="mb-4">
        <label className="block text-sm font-medium mb-1">Tags</label>
        <TagInput tags={tags} onChange={handleTagsChange} />
      </div>
      
      {/* Status */}
      <div className="mb-4">
        <label className="block text-sm font-medium mb-1">Status</label>
        <div className="flex gap-4">
          <label className="inline-flex items-center">
            <input 
              type="radio" 
              value="Lead" 
              className="text-primary"
              {...register("status")}
            />
            <span className="ml-2 text-sm text-gray-700 dark:text-gray-200">Lead</span>
          </label>
          <label className="inline-flex items-center">
            <input 
              type="radio" 
              value="Aluno" 
              className="text-primary"
              {...register("status")}
            />
            <span className="ml-2 text-sm text-gray-700 dark:text-gray-200">Aluno</span>
          </label>
        </div>
        {errors.status && (
          <p className="mt-1 text-xs text-red-600">{errors.status.message}</p>
        )}
      </div>
      
      {/* Observações */}
      <div className="mb-4">
        <label className="block text-sm font-medium mb-1">Observações</label>
        <textarea
          {...register("notes")}
          className="w-full px-3 py-2 border rounded-md"
          rows={4}
          placeholder="Observações adicionais sobre o lead"
        ></textarea>
        {errors.notes && (
          <p className="mt-1 text-xs text-red-600">{errors.notes.message}</p>
        )}
      </div>
      
      {/* Buttons */}
      <div className="flex justify-end gap-2">
        <button
          type="button"
          onClick={onCancel}
          className="px-4 py-2 border rounded-md text-sm font-medium"
        >
          Cancelar
        </button>
        <button
          type="submit"
          disabled={isSubmitting}
          className="px-4 py-2 bg-primary text-white rounded-md text-sm font-medium"
        >
          {isSubmitting ? (
            <>
              <span className="animate-spin inline-block mr-2">&#8987;</span>
              Salvando...
            </>
          ) : (
            <>Salvar</>
          )}
        </button>
      </div>
      
      {lead && showStatusNotification && (
        <LeadStatusChangeNotification
          lead={lead}
          isOpen={showStatusNotification}
          onClose={() => setShowStatusNotification(false)}
          onSubmitChange={handleNotificationResult}
        />
      )}
    </form>
  );
}
</file>

<file path="client/src/components/leads/LeadManagement.tsx">
import { useState, useRef, ChangeEvent, useEffect } from "react";
import { useQuery, useQueryClient } from "@tanstack/react-query";
import { Lead, InsertLead } from "@shared/schema";
import { useLeadContext } from "@/context/LeadContext";
import { useToast } from "@/hooks/use-toast";
import { Progress } from "@/components/ui/progress";
import LeadTable from "./LeadTable";
import LeadDialog from "./LeadDialog";
import { 
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from "@/components/ui/dialog";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";

export default function LeadManagement() {
  const queryClient = useQueryClient();
  const { data: leads, isLoading, error } = useQuery<Lead[]>({
    queryKey: ["/api/leads"],
  });
  
  const [currentPage, setCurrentPage] = useState(1);
  const leadsPerPage = 10;
  const indexOfLastLead = currentPage * leadsPerPage;
  const indexOfFirstLead = indexOfLastLead - leadsPerPage;

  const { 
    setIsDialogOpen, 
    selectedLead, 
    setSelectedLead,
    deleteLead,
    createLead,
    selectedLeadIds,
    setSelectedLeadIds,
    updateLeadsInBatch,
    deleteLeadsInBatch
  } = useLeadContext();
  
  const { toast } = useToast();

  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [batchDeleteDialogOpen, setBatchDeleteDialogOpen] = useState(false);
  const [searchTerm, setSearchTerm] = useState("");
  type FilterState = {
    source: string;
    status: string;
    campaign: string;
    state: string;
    startDate: string;
    endDate: string;
    tag: string;
    dateRange: string;
  };

  const [filters, setFilters] = useState<FilterState>({
    source: "",
    status: "",
    campaign: "",
    state: "",
    startDate: "",
    endDate: "",
    tag: "",
    dateRange: ""
  });
  
  // Função que retorna todas as tags únicas dos leads
  const getUniqueTags = () => {
    if (!leads) return [];
    
    // Obter todas as tags
    const allTags = leads.flatMap(lead => lead.tags || []);
    
    // Criar um objeto para rastrear tags únicas
    const uniqueTagsObj: Record<string, boolean> = {};
    allTags.forEach(tag => {
      if (tag.trim() !== "") {
        uniqueTagsObj[tag] = true;
      }
    });
    
    // Converter de volta para array e ordenar
    return Object.keys(uniqueTagsObj).sort();
  };
  
  // Função para configurar data inicial e final com base no período selecionado
  const handleDateRangeChange = (range: string) => {
    const today = new Date();
    let startDate = "";
    let endDate = today.toISOString().split('T')[0]; // Formato YYYY-MM-DD
    
    switch(range) {
      case "today":
        startDate = today.toISOString().split('T')[0];
        break;
      case "last7days":
        const last7Days = new Date(today);
        last7Days.setDate(today.getDate() - 7);
        startDate = last7Days.toISOString().split('T')[0];
        break;
      case "last30days":
        const last30Days = new Date(today);
        last30Days.setDate(today.getDate() - 30);
        startDate = last30Days.toISOString().split('T')[0];
        break;
      case "thisMonth":
        const thisMonth = new Date(today.getFullYear(), today.getMonth(), 1);
        startDate = thisMonth.toISOString().split('T')[0];
        break;
      case "lastMonth":
        const lastMonth = new Date(today.getFullYear(), today.getMonth() - 1, 1);
        const lastDayLastMonth = new Date(today.getFullYear(), today.getMonth(), 0);
        startDate = lastMonth.toISOString().split('T')[0];
        endDate = lastDayLastMonth.toISOString().split('T')[0];
        break;
      case "thisYear":
        const thisYear = new Date(today.getFullYear(), 0, 1);
        startDate = thisYear.toISOString().split('T')[0];
        break;
      case "custom":
        // Mantém as datas atuais para entrada manual
        return;
      default:
        // Limpa as datas
        startDate = "";
        endDate = "";
    }
    
    setFilters(prev => ({ ...prev, startDate, endDate, dateRange: range }));
  };
  const [filterMenuOpen, setFilterMenuOpen] = useState(false);
  const [importDialogOpen, setImportDialogOpen] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const [batchStatusValue, setBatchStatusValue] = useState("");
  const [batchSourceValue, setBatchSourceValue] = useState("");
  const [exportLoading, setExportLoading] = useState(false);
  const [exportProgress, setExportProgress] = useState(0);
  const [exportFormat, setExportFormat] = useState<"csv" | "json" | "excel">("csv");
  const [exportDialogOpen, setExportDialogOpen] = useState(false);
  const csvLinkRef = useRef<HTMLAnchorElement>(null);
  const [importLoading, setImportLoading] = useState(false);
  const [importProgress, setImportProgress] = useState(0);
  const [previewData, setPreviewData] = useState<any[]>([]);
  const [showPreview, setShowPreview] = useState(false);
  const [parsedLeads, setParsedLeads] = useState<InsertLead[]>([]);
  const [importStats, setImportStats] = useState<{
    currentBatch: number;
    totalBatches: number; 
    processedCount: number;
    successCount: number;
    errorCount: number;
    updatedCount: number;
    totalCount: number;
    currentBatchSize: number;
    statusMessage: string;
    batchResults: Array<{
      batch: number;
      success: number;
      updated: number;
      errors: number;
    }>;
  }>({
    currentBatch: 0,
    totalBatches: 0,
    processedCount: 0,
    successCount: 0,
    errorCount: 0,
    updatedCount: 0,
    totalCount: 0,
    currentBatchSize: 0,
    statusMessage: 'Aguardando início da importação',
    batchResults: []
  });

  // Parse CSV content and extract lead data
  const parseCSV = (content: string) => {
    const rows = content.split('\n');
    
    if (rows.length < 2) {
      throw new Error("O arquivo não contém dados válidos.");
    }
    
    // Extract headers and normalize them
    const headers = rows[0]
      .split(',')
      .map(header => header.trim().toLowerCase());
    
    const requiredHeaders = ['nome', 'email'];
    const missingHeaders = requiredHeaders.filter(header => !headers.includes(header));
    
    if (missingHeaders.length > 0) {
      throw new Error(`O arquivo não contém os cabeçalhos obrigatórios: ${missingHeaders.join(', ')}.`);
    }
    
    // Process each row
    const leadsToImport: InsertLead[] = [];
    const errorRows: number[] = [];
    const parsedRows: any[] = [];
    
    for (let i = 1; i < rows.length; i++) {
      if (!rows[i].trim()) continue;
      
      const values = rows[i].split(',');
      if (values.length !== headers.length) {
        errorRows.push(i);
        continue;
      }
      
      // Create lead object from CSV row
      try {
        const leadData: Record<string, any> = {};
        const rowData: Record<string, any> = {};
        
        headers.forEach((header, index) => {
          const value = values[index]?.trim() || "";
          rowData[header] = value;
          
          switch(header) {
            case 'nome':
            case 'name':
              leadData.name = value;
              break;
            case 'email':
              leadData.email = value;
              break;
            case 'telefone':
            case 'phone':
              leadData.phone = value;
              break;
            case 'estado':
            case 'state':
              leadData.state = value;
              break;
            case 'campanha':
            case 'campaign':
              leadData.campaign = value;
              break;
            case 'origem':
            case 'fonte':
            case 'source':
              leadData.source = value;
              break;
            case 'status':
              leadData.status = value || "Lead";
              break;
            case 'tags':
              leadData.tags = value ? value.split(/[,;]/).map(tag => tag.trim()) : [];
              break;
            case 'data_entrada':
            case 'data de entrada':
              try {
                leadData.entryDate = value ? new Date(value).toISOString() : new Date().toISOString();
              } catch (e) {
                leadData.entryDate = new Date().toISOString();
              }
              break;
            case 'observacoes':
            case 'observações':
              leadData.notes = value;
              break;
          }
        });
        
        // Validate required fields
        if (!leadData.name || !leadData.email) {
          errorRows.push(i);
          continue;
        }
        
        // Set defaults for missing fields
        if (!leadData.status) leadData.status = "Lead";
        if (!leadData.source) leadData.source = "Favale";
        if (!leadData.tags) leadData.tags = [];
        if (!leadData.entryDate) leadData.entryDate = new Date().toISOString();
        
        leadsToImport.push(leadData as InsertLead);
        parsedRows.push(rowData);
      } catch (error) {
        console.error(`Erro ao processar linha ${i}:`, error);
        errorRows.push(i);
      }
    }
    
    if (leadsToImport.length === 0) {
      throw new Error("Nenhum lead válido encontrado no arquivo.");
    }
    
    return { leadsToImport, errorRows, parsedRows };
  };
  
  const handleNewLead = () => {
    setSelectedLead(null);
    setIsDialogOpen(true);
  };

  const handleDelete = (lead: Lead) => {
    setSelectedLead(lead);
    setDeleteDialogOpen(true);
  };

  const confirmDelete = async () => {
    if (selectedLead) {
      await deleteLead(selectedLead.id);
      setDeleteDialogOpen(false);
    }
  };

  const handleBatchStatusUpdate = async () => {
    if (selectedLeadIds.length > 0 && batchStatusValue) {
      await updateLeadsInBatch(selectedLeadIds, { status: batchStatusValue });
      setBatchStatusValue("");
    }
  };

  const handleBatchSourceUpdate = async () => {
    if (selectedLeadIds.length > 0 && batchSourceValue) {
      await updateLeadsInBatch(selectedLeadIds, { source: batchSourceValue });
      setBatchSourceValue("");
    }
  };

  const handleBatchDelete = () => {
    if (selectedLeadIds.length > 0) {
      setBatchDeleteDialogOpen(true);
    }
  };

  const confirmBatchDelete = async () => {
    if (selectedLeadIds.length > 0) {
      await deleteLeadsInBatch(selectedLeadIds);
      setBatchDeleteDialogOpen(false);
    }
  };

  const handleFileUpload = async (e: ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = async (event) => {
      try {
        const content = event.target?.result as string;
        
        // Pré-processamento para garantir quebras de linha consistentes (CRLF -> LF)
        const normalizedContent = content.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
        const rows = normalizedContent.split('\n');
        
        console.log(`Total de linhas no arquivo: ${rows.length}`);
        
        if (rows.length < 2) {
          toast({
            title: "Erro na importação",
            description: "O arquivo não contém dados válidos.",
            variant: "destructive",
          });
          return;
        }
        
        // Extrair cabeçalhos com tratamento especial para vírgulas em aspas
        let headerRow = rows[0];
        const headerValues: string[] = [];
        let insideHeaderQuotes = false;
        let currentHeader = "";
        
        for (let j = 0; j < headerRow.length; j++) {
          const char = headerRow[j];
          
          if (char === '"') {
            insideHeaderQuotes = !insideHeaderQuotes;
          } else if (char === ',' && !insideHeaderQuotes) {
            headerValues.push(currentHeader.trim().toLowerCase());
            currentHeader = "";
          } else {
            currentHeader += char;
          }
        }
        
        // Adicionar o último cabeçalho
        headerValues.push(currentHeader.trim().toLowerCase());
        
        // Limpar aspas nos cabeçalhos
        const headers = headerValues.map(header => {
          let cleaned = header.trim();
          if (cleaned.startsWith('"') && cleaned.endsWith('"')) {
            cleaned = cleaned.substring(1, cleaned.length - 1);
          }
          return cleaned;
        });
        
        console.log('Cabeçalhos encontrados:', headers);
        
        // Map para normalização de cabeçalhos
        const headerMap: Record<string, string[]> = {
          'nome': ['nome', 'name', 'Nome'],
          'email': ['email', 'Email'],
          'telefone': ['telefone', 'phone', 'Telefone'],
          'estado': ['estado', 'state', 'Estado'],
          'status': ['status', 'Status'],
          'fonte': ['fonte', 'source', 'origem', 'Fonte'],
          'campanha': ['campanha', 'campaign', 'Campanha'],
          'tags': ['tags', 'Tags'],
          'data_entrada': ['data_entrada', 'data de entrada', 'data', 'Data de Entrada'],
          'observacoes': ['observacoes', 'observações', 'notas', 'notes', 'Observações']
        };
        
        // Verificar se os cabeçalhos necessários estão presentes usando o mapa
        const requiredFields = ['nome', 'email'];
        const missingHeaders = [];
        
        for (const required of requiredFields) {
          const possibleHeaders = headerMap[required];
          if (!possibleHeaders.some(h => headers.includes(h))) {
            missingHeaders.push(required);
          }
        }
        
        if (missingHeaders.length > 0) {
          toast({
            title: "Erro na importação",
            description: `O arquivo não contém os cabeçalhos obrigatórios: ${missingHeaders.join(', ')}.`,
            variant: "destructive",
          });
          return;
        }
        
        // Process each row
        const leadsToImport: InsertLead[] = [];
        const errorRows: number[] = [];
        
        // Iniciar da linha 1 (após o cabeçalho)
        for (let i = 1; i < rows.length; i++) {
          if (!rows[i] || !rows[i].trim()) continue;
          
          // Process each row - tratamento especial para campos com vírgulas dentro de aspas
          const row = rows[i];
          const values: string[] = [];
          let insideQuotes = false;
          let currentValue = "";
          
          for (let j = 0; j < row.length; j++) {
            const char = row[j];
            
            if (char === '"') {
              insideQuotes = !insideQuotes;
              // Mantém aspas apenas para processamento posterior
              currentValue += char;
            } else if (char === ',' && !insideQuotes) {
              values.push(currentValue);
              currentValue = "";
            } else {
              currentValue += char;
            }
          }
          
          // Adicionar o último valor
          values.push(currentValue);
          
          // Limpar aspas externas e espaços em branco
          const cleanValues = values.map(val => {
            let cleaned = val.trim();
            if (cleaned.startsWith('"') && cleaned.endsWith('"')) {
              cleaned = cleaned.substring(1, cleaned.length - 1);
            }
            return cleaned;
          });
          
          console.log('Linha processada:', cleanValues);
          
          if (cleanValues.length !== headers.length) {
            console.error(`Linha ${i} tem ${cleanValues.length} valores, mas esperava ${headers.length}`);
            errorRows.push(i);
            continue;
          }
          
          // Create lead object from CSV row
          try {
            const leadData: Record<string, any> = {};
            
            // Criar um mapa inverso para encontrar o campo de destino com base no header
            const reverseHeaderMap: Record<string, string> = {};
            Object.entries(headerMap).forEach(([key, values]) => {
              values.forEach(value => {
                reverseHeaderMap[value] = key;
              });
            });

            headers.forEach((header, index) => {
              const value = cleanValues[index] || "";
              const normalizedHeader = reverseHeaderMap[header] || header;
              
              switch(normalizedHeader) {
                case 'nome':
                  leadData.name = value;
                  break;
                case 'email':
                  leadData.email = value;
                  break;
                case 'telefone':
                  leadData.phone = value;
                  break;
                case 'estado':
                  leadData.state = value;
                  break;
                case 'campanha':
                  leadData.campaign = value;
                  break;
                case 'fonte':
                  leadData.source = value;
                  break;
                case 'status':
                  leadData.status = value || "Lead";
                  break;
                case 'tags':
                  // Processamento mais robusto para tags
                  if (value) {
                    // Primeiro verifica se está entre aspas duplas
                    let processedValue = value;
                    if (processedValue.startsWith('"') && processedValue.endsWith('"')) {
                      // Remove as aspas e divide pelos delimitadores
                      processedValue = processedValue.substring(1, processedValue.length - 1);
                    }
                    // Divide por vírgulas ou ponto-e-vírgulas
                    leadData.tags = processedValue
                      .split(/[,;]/)
                      .map(tag => tag.trim())
                      .filter(tag => tag.length > 0); // Remove tags vazias
                  } else {
                    leadData.tags = [];
                  }
                  break;
                case 'data_entrada':
                  try {
                    // Tenta converter a data de entrada para formato de string que o servidor conseguirá processar
                    if (value) {
                      // Formatar corretamente a data brasileira (DD/MM/YYYY)
                      if (/^\d{2}\/\d{2}\/\d{4}$/.test(value)) {
                        const [day, month, year] = value.split('/');
                        // Armazenar como string no formato ISO sem conversão para Date
                        leadData.entryDate = `${year}-${month}-${day}`;
                      } 
                      // Tenta lidar com o formato americano (MM/DD/YYYY)
                      else if (/^\d{2}\/\d{2}\/\d{4}$/.test(value)) {
                        const [month, day, year] = value.split('/');
                        leadData.entryDate = `${year}-${month}-${day}`;
                      }
                      // Formato ISO (YYYY-MM-DD)
                      else if (/^\d{4}-\d{2}-\d{2}$/.test(value)) {
                        leadData.entryDate = value;
                      }
                      // Formato apenas o ano (YYYY)
                      else if (/^\d{4}$/.test(value)) {
                        leadData.entryDate = `${value}-01-01`;
                      }
                      else {
                        // Usar a data atual para qualquer formato não reconhecido
                        console.warn(`Formato de data não reconhecido: ${value}`);
                        leadData.entryDate = new Date().toISOString().split('T')[0];
                      }
                      
                      console.log(`Processamento de data: original='${value}', processada='${leadData.entryDate}'`);
                    } else {
                      // Se não tem valor, usa a data atual sem a parte de hora
                      leadData.entryDate = new Date().toISOString().split('T')[0];
                    }
                  } catch (e) {
                    console.error('Erro ao processar data:', e);
                    leadData.entryDate = new Date().toISOString().split('T')[0];
                  }
                  break;
                case 'observacoes':
                case 'observações':
                  leadData.notes = value;
                  break;
              }
            });
            
            // Validate required fields
            if (!leadData.name || !leadData.email) {
              errorRows.push(i);
              continue;
            }
            
            // Set defaults for missing fields
            if (!leadData.status) leadData.status = "Lead";
            if (!leadData.source) leadData.source = "Favale";
            if (!leadData.tags) leadData.tags = [];
            if (!leadData.entryDate) leadData.entryDate = new Date().toISOString();
            
            leadsToImport.push(leadData as InsertLead);
          } catch (error) {
            console.error(`Erro ao processar linha ${i}:`, error);
            errorRows.push(i);
          }
        }
        
        // Report results
        if (leadsToImport.length === 0) {
          toast({
            title: "Erro na importação",
            description: "Nenhum lead válido encontrado no arquivo.",
            variant: "destructive",
          });
          return;
        }
        
        // Enviar leads em lote para a API em chunks para evitar problemas com tamanho de payload
        try {
          setImportProgress(50);
          
          // Processar em lotes de no máximo 250 leads para evitar problemas de tamanho de payload
          const BATCH_SIZE = 250;
          const totalBatches = Math.ceil(leadsToImport.length / BATCH_SIZE);
          console.log(`Processando ${leadsToImport.length} leads em ${totalBatches} lotes de ${BATCH_SIZE}`);
          
          // Reset estatísticas de importação
          setImportStats({
            currentBatch: 0,
            totalBatches,
            processedCount: 0,
            successCount: 0,
            errorCount: 0,
            updatedCount: 0,
            totalCount: leadsToImport.length,
            currentBatchSize: 0,
            statusMessage: 'Iniciando importação...',
            batchResults: []
          });
          
          let successCount = 0;
          let updatedCount = 0;
          let errorCount = 0;
          let details: Array<{index: number, id?: number, error?: string, action?: string, data?: any}> = [];
          
          for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
            const start = batchIndex * BATCH_SIZE;
            const end = Math.min(start + BATCH_SIZE, leadsToImport.length);
            const currentBatch = leadsToImport.slice(start, end);
            
            console.log(`Enviando lote ${batchIndex + 1}/${totalBatches} (${currentBatch.length} leads)`);
            
            // Atualizar estatísticas antes de iniciar o processamento do lote
            setImportStats(prev => ({
              ...prev,
              currentBatch: batchIndex + 1,
              currentBatchSize: currentBatch.length,
              statusMessage: `Processando lote ${batchIndex + 1} de ${totalBatches}...`
            }));
            
            setImportProgress(50 + Math.floor((batchIndex / totalBatches) * 40));
            const response = await fetch('/api/leads/batch/import', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({ leads: currentBatch })
            });
            
            if (!response.ok) {
              let errorText;
              try {
                // Tenta obter o erro como JSON
                const errorJson = await response.json();
                errorText = errorJson.message || 'Erro desconhecido';
              } catch (e) {
                // Se não for JSON, tenta obter como texto
                errorText = await response.text();
              }
              throw new Error(`Erro na importação do lote ${batchIndex + 1}: ${errorText}`);
            }
            
            try {
              const batchResult = await response.json();
              console.log(`Resultado do lote ${batchIndex + 1}:`, batchResult);
              
              // Acumular resultados
              successCount += batchResult.successCount || 0;
              updatedCount += batchResult.updatedCount || 0;
              errorCount += batchResult.errorCount || 0;
              
              if (batchResult.details && Array.isArray(batchResult.details)) {
                details = [...details, ...batchResult.details];
              }
              
              // Atualizar estatísticas com os resultados deste lote
              setImportStats(prev => {
                const processedCount = prev.processedCount + currentBatch.length;
                const newSuccessCount = prev.successCount + (batchResult.successCount || 0);
                const newUpdatedCount = prev.updatedCount + (batchResult.updatedCount || 0);
                const newErrorCount = prev.errorCount + (batchResult.errorCount || 0);
                
                // Adicionar resultado do lote atual ao histórico
                const newBatchResults = [...prev.batchResults, {
                  batch: batchIndex + 1,
                  success: batchResult.successCount || 0,
                  updated: batchResult.updatedCount || 0,
                  errors: batchResult.errorCount || 0
                }];
                
                return {
                  ...prev,
                  currentBatch: batchIndex + 1,
                  processedCount,
                  successCount: newSuccessCount,
                  updatedCount: newUpdatedCount,
                  errorCount: newErrorCount,
                  statusMessage: `Lote ${batchIndex + 1} finalizado: ${batchResult.successCount || 0} leads importados, ${batchResult.updatedCount || 0} atualizados, ${batchResult.errorCount || 0} erros`,
                  batchResults: newBatchResults
                };
              });
            } catch (e) {
              console.error(`Erro ao parsear resultado JSON do lote ${batchIndex + 1}:`, e);
              throw new Error('Erro ao processar resposta do servidor');
            }
          }
          
          // Consolidar resultados de todos os lotes
          const result = {
            successCount,
            updatedCount,
            errorCount,
            details
          };
          
          console.log('Resultado final da importação em lotes:', result);
          
          // Atualizar a lista de leads após a importação bem-sucedida
          try {
            // Primeiro, invalidamos a consulta
            await queryClient.invalidateQueries({ queryKey: ["/api/leads"] });
            
            // Em seguida, disparamos manualmente uma nova consulta com await para garantir que seja concluída
            await queryClient.fetchQuery({ queryKey: ["/api/leads"] });
            console.log('Dados atualizados com sucesso após importação');
          } catch (e) {
            console.error('Erro ao atualizar dados após importação:', e);
          }
          
          // Atualizar mensagem final das estatísticas
          setImportStats(prev => ({
            ...prev,
            statusMessage: 'Importação finalizada com sucesso!',
          }));
          
          setImportProgress(100);
          
          // Show results
          setImportDialogOpen(false);
          const totalSuccess = (result.successCount || 0) + (result.updatedCount || 0);
          
          toast({
            title: "Importação concluída",
            description: `${result.successCount || 0} leads importados${result.updatedCount > 0 ? ` e ${result.updatedCount} atualizados` : ''} com sucesso.${result.errorCount > 0 ? ` ${result.errorCount} leads com erro.` : ''}`,
            variant: totalSuccess > 0 ? "default" : "destructive",
          });
        } catch (error) {
          console.error('Erro ao importar leads em lote:', error);
          
          toast({
            title: "Erro na importação",
            description: error instanceof Error ? error.message : "Ocorreu um erro ao importar os leads.",
            variant: "destructive",
          });
        }
        
      } catch (error) {
        console.error('Erro ao processar arquivo:', error);
        toast({
          title: "Erro na importação",
          description: "Ocorreu um erro ao processar o arquivo.",
          variant: "destructive",
        });
      }
    };
    
    reader.onerror = () => {
      toast({
        title: "Erro na importação",
        description: "Erro ao ler o arquivo.",
        variant: "destructive",
      });
    };
    
    reader.readAsText(file);
    e.target.value = ''; // Reset the input
  };
  
  const handleExportLeads = async () => {
    if (!filteredLeads || filteredLeads.length === 0) return;
    
    setExportLoading(true);
    setExportProgress(10);
    
    try {
      // Define headers
      const headers = [
        'ID', 'Nome', 'Email', 'Telefone', 'Estado', 'Status', 
        'Fonte', 'Campanha', 'Tags', 'Data de Entrada', 'Observações'
      ];
      
      setExportProgress(25);
      
      // Process data based on format
      let blob: Blob;
      let filename: string;
      
      if (exportFormat === 'json') {
        // Create JSON export
        const jsonData = filteredLeads.map(lead => ({
          id: lead.id,
          nome: lead.name,
          email: lead.email,
          telefone: lead.phone,
          estado: lead.state,
          status: lead.status,
          fonte: lead.source,
          campanha: lead.campaign,
          tags: lead.tags.join(', '),
          data_entrada: new Date(lead.entryDate).toLocaleDateString('pt-BR'),
          observacoes: lead.notes
        }));
        
        setExportProgress(50);
        const jsonContent = JSON.stringify(jsonData, null, 2);
        blob = new Blob([jsonContent], { type: 'application/json' });
        filename = `leads_${new Date().toISOString().slice(0, 10)}.json`;
      } 
      else if (exportFormat === 'excel') {
        // Create Excel-compatible CSV (UTF-8 with BOM)
        setExportProgress(40);
        
        // Map leads to CSV rows
        const csvRows = filteredLeads.map(lead => {
          const values = [
            lead.id,
            lead.name,
            lead.email,
            lead.phone,
            lead.state,
            lead.status,
            lead.source,
            lead.campaign,
            lead.tags.join('; '), // Use semicolon for tags in Excel format
            new Date(lead.entryDate).toLocaleDateString('pt-BR'),
            lead.notes
          ];
          
          // Escape values that might contain separators
          return values.map(value => 
            typeof value === 'string' && (value.includes(';') || value.includes('"'))
              ? `"${value.replace(/"/g, '""')}"`
              : value
          ).join(';'); // Use semicolon as separator for Excel
        });
        
        setExportProgress(60);
        // Add BOM for Excel UTF-8 compatibility
        const BOM = '\uFEFF';
        const csvContent = BOM + [headers.join(';'), ...csvRows].join('\n');
        blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        filename = `leads_${new Date().toISOString().slice(0, 10)}.csv`;
      } 
      else {
        // Default CSV format
        setExportProgress(40);
        
        // Map leads to CSV rows
        const csvRows = filteredLeads.map(lead => {
          const values = [
            lead.id,
            lead.name,
            lead.email,
            lead.phone,
            lead.state,
            lead.status,
            lead.source,
            lead.campaign,
            lead.tags.join(', '),
            new Date(lead.entryDate).toLocaleDateString('pt-BR'),
            lead.notes
          ];
          
          // Escape values that might contain commas
          return values.map(value => 
            typeof value === 'string' && (value.includes(',') || value.includes('"'))
              ? `"${value.replace(/"/g, '""')}"`
              : value
          ).join(',');
        });
        
        setExportProgress(60);
        const csvContent = [headers.join(','), ...csvRows].join('\n');
        blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        filename = `leads_${new Date().toISOString().slice(0, 10)}.csv`;
      }
      
      setExportProgress(80);
      
      // Create download link
      const url = URL.createObjectURL(blob);
      
      if (csvLinkRef.current) {
        csvLinkRef.current.href = url;
        csvLinkRef.current.download = filename;
        csvLinkRef.current.click();
      }
      
      setExportProgress(100);
      
      // Show toast notification
      toast({
        title: "Exportação concluída",
        description: `${filteredLeads.length} leads exportados com sucesso no formato ${exportFormat.toUpperCase()}.`,
        variant: "default",
      });
      
      // Close dialog after successful export
      setTimeout(() => {
        setExportDialogOpen(false);
      }, 1500);
      
    } catch (error) {
      console.error('Erro ao exportar leads:', error);
      toast({
        title: "Erro na exportação",
        description: "Ocorreu um erro ao exportar os leads.",
        variant: "destructive",
      });
    } finally {
      setExportLoading(false);
      // Reset progress after a short delay to allow for animation
      setTimeout(() => setExportProgress(0), 1000);
    }
  };

  const confirmImport = async () => {
    if (parsedLeads.length === 0) return;
    
    // Reset estatísticas de importação
    setImportStats({
      currentBatch: 0,
      totalBatches: 1,
      processedCount: 0,
      successCount: 0,
      errorCount: 0,
      updatedCount: 0,
      totalCount: parsedLeads.length,
      currentBatchSize: parsedLeads.length,
      statusMessage: 'Iniciando importação...',
      batchResults: []
    });
    
    try {
      setImportProgress(60);
      setImportStats(prev => ({
        ...prev,
        statusMessage: 'Enviando dados para o servidor...'
      }));
      
      // Enviar leads em lote para a API
      const response = await fetch('/api/leads/batch/import', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ leads: parsedLeads })
      });
      
      let result;
      if (!response.ok) {
        let errorText;
        try {
          // Tenta obter o erro como JSON
          const errorJson = await response.json();
          errorText = errorJson.message || 'Erro desconhecido';
        } catch (e) {
          // Se não for JSON, tenta obter como texto
          errorText = await response.text();
        }
        
        setImportStats(prev => ({
          ...prev,
          statusMessage: `Erro: ${errorText}`,
        }));
        
        throw new Error(`Erro na importação em lote: ${errorText}`);
      }
      
      try {
        result = await response.json();
      } catch (e) {
        console.error('Erro ao parsear resultado JSON:', e);
        throw new Error('Erro ao processar resposta do servidor');
      }
      console.log('Resultado da importação em lote:', result);
      
      // Atualizar estatísticas com os resultados
      setImportStats(prev => {
        const successCount = result.successCount || 0;
        const updatedCount = result.updatedCount || 0;
        const errorCount = result.errorCount || 0;
        
        // Adicionar resultado do lote ao histórico
        const newBatchResults = [...prev.batchResults, {
          batch: 1,
          success: successCount,
          updated: updatedCount,
          errors: errorCount
        }];
        
        return {
          ...prev,
          currentBatch: 1,
          processedCount: parsedLeads.length,
          successCount,
          updatedCount,
          errorCount,
          statusMessage: 'Processamento concluído, atualizando dados...',
          batchResults: newBatchResults
        };
      });
      
      // Atualizar a lista de leads após a importação bem-sucedida
      try {
        // Primeiro, invalidamos a consulta
        await queryClient.invalidateQueries({ queryKey: ["/api/leads"] });
        
        // Em seguida, disparamos manualmente uma nova consulta com await para garantir que seja concluída
        await queryClient.fetchQuery({ queryKey: ["/api/leads"] });
        console.log('Dados atualizados com sucesso após importação');
        
        // Atualizar mensagem final
        setImportStats(prev => ({
          ...prev,
          statusMessage: 'Importação finalizada com sucesso!'
        }));
      } catch (e) {
        console.error('Erro ao atualizar dados após importação:', e);
      }
      
      // Show results
      setImportProgress(100);
      setImportDialogOpen(false);
      setShowPreview(false);
      setPreviewData([]);
      setParsedLeads([]);
      
      const updatedCount = result.updatedCount || 0;
      const totalSuccess = (result.successCount || 0) + updatedCount;
      
      toast({
        title: "Importação concluída",
        description: `${result.successCount || 0} leads importados${updatedCount > 0 ? ` e ${updatedCount} atualizados` : ''} com sucesso.${result.errorCount > 0 ? ` ${result.errorCount} leads com erro.` : ''}`,
        variant: totalSuccess > 0 ? "default" : "destructive",
      });
      
    } catch (error) {
      console.error('Erro ao processar importação:', error);
      
      setImportStats(prev => ({
        ...prev,
        statusMessage: error instanceof Error ? error.message : 'Erro desconhecido durante a importação'
      }));
      
      toast({
        title: "Erro na importação",
        description: error instanceof Error ? error.message : "Ocorreu um erro ao importar os leads.",
        variant: "destructive",
      });
    } finally {
      setImportLoading(false);
      setImportProgress(0);
    }
  };
  
  // Reset progress and data when dialog closes
  useEffect(() => {
    if (!importDialogOpen) {
      setImportProgress(0);
      setImportLoading(false);
      
      // Only reset preview data if not in the middle of import
      if (!importLoading) {
        setShowPreview(false);
        setPreviewData([]);
        setParsedLeads([]);
      }
    }
  }, [importDialogOpen, importLoading]);
  
  // Filtered leads processing
  const filteredLeads = leads?.filter(lead => {
    // Search term filter
    const matchesSearch = searchTerm === "" ||
      lead.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
      lead.email.toLowerCase().includes(searchTerm.toLowerCase()) ||
      lead.phone.toLowerCase().includes(searchTerm.toLowerCase());
    
    // Dropdown filters
    const matchesSource = filters.source === "" || lead.source === filters.source;
    const matchesStatus = filters.status === "" || lead.status === filters.status;
    const matchesCampaign = filters.campaign === "" || lead.campaign === filters.campaign;
    
    // Advanced filters
    const matchesState = filters.state === "" || lead.state === filters.state;
    
    // Tag filter
    const matchesTag = filters.tag === "" || (lead.tags && lead.tags.includes(filters.tag));
    
    // Date filters
    let matchesDateRange = true;
    if (filters.startDate && filters.endDate) {
      const leadDate = new Date(lead.entryDate);
      const startDate = new Date(filters.startDate);
      const endDate = new Date(filters.endDate);
      // Add one day to end date to include the end date itself
      endDate.setDate(endDate.getDate() + 1);
      
      matchesDateRange = leadDate >= startDate && leadDate < endDate;
    } else if (filters.startDate) {
      const leadDate = new Date(lead.entryDate);
      const startDate = new Date(filters.startDate);
      matchesDateRange = leadDate >= startDate;
    } else if (filters.endDate) {
      const leadDate = new Date(lead.entryDate);
      const endDate = new Date(filters.endDate);
      // Add one day to end date to include the end date itself
      endDate.setDate(endDate.getDate() + 1);
      matchesDateRange = leadDate < endDate;
    }
    
    return matchesSearch && matchesSource && matchesStatus && matchesCampaign && 
           matchesState && matchesDateRange && matchesTag;
  });

  // Check if there are active filters
  const hasActiveFilters = [
    filters.source,
    filters.status,
    filters.campaign,
    filters.state,
    filters.startDate,
    filters.endDate,
    filters.tag,
    filters.dateRange
  ].some(filter => filter !== "");
  
  // Count active filters
  const activeFilterCount = [
    filters.source,
    filters.status,
    filters.campaign,
    filters.state,
    filters.tag,
    (filters.startDate || filters.endDate || filters.dateRange) ? 1 : 0, // Count date range as one filter
  ].filter(Boolean).length;

  if (error) {
    return (
      <div className="bg-red-50 p-4 rounded-md text-red-600">
        <p>Erro ao carregar leads. Por favor, tente novamente mais tarde.</p>
      </div>
    );
  }

  return (
    <div>
      {/* Header with actions */}
      <div className="flex flex-col md:flex-row md:justify-between md:items-center mb-6">
        <div className="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-2">
          <button 
            className={`${hasActiveFilters 
              ? 'bg-primary-50 dark:bg-primary-900/20 border-primary-200 dark:border-primary-700' 
              : 'bg-white dark:bg-gray-800 border-gray-300 dark:border-gray-700'} 
              border rounded-md px-4 py-2 text-sm 
              ${hasActiveFilters 
                ? 'text-primary-700 dark:text-primary-300' 
                : 'text-gray-700 dark:text-gray-300'} 
              hover:bg-primary-50 dark:hover:bg-primary-900/20 
              flex items-center transition-colors duration-200 relative`
            }
            onClick={() => setFilterMenuOpen(!filterMenuOpen)}
          >
            <span className={`material-icons text-sm mr-1 
              ${hasActiveFilters ? 'text-primary-600 dark:text-primary-400' : 'text-primary-400 dark:text-pink-400'}`}>
              filter_list
            </span>
            Filtrar
            {hasActiveFilters && (
              <span className="absolute -top-2 -right-2 bg-primary text-white text-xs rounded-full w-5 h-5 flex items-center justify-center dark:glow-xs">
                {activeFilterCount}
              </span>
            )}
          </button>
          <button 
            className="bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded-md px-4 py-2 text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700 flex items-center transition-colors duration-200"
            onClick={() => setExportDialogOpen(true)}
            disabled={!filteredLeads || filteredLeads.length === 0}
          >
            <span className="material-icons text-sm mr-1 text-primary-400 dark:text-pink-400">file_download</span>
            Exportar
          </button>
          
          <button 
            className="bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded-md px-4 py-2 text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700 flex items-center transition-colors duration-200"
            onClick={() => setImportDialogOpen(true)}
          >
            <span className="material-icons text-sm mr-1 text-primary-400 dark:text-pink-400">upload_file</span>
            Importar
          </button>
          <a ref={csvLinkRef} style={{ display: 'none' }} />
          

          <button 
            className="bg-primary text-white rounded-md px-4 py-2 text-sm flex items-center hover:bg-primary/90 dark:glow-button-sm transition-all duration-200"
            onClick={handleNewLead}
          >
            <span className="material-icons text-sm mr-1">add</span>
            Novo Lead
          </button>
        </div>
      </div>

      {/* Search and filter bar */}
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow-md p-4 mb-6 transition-colors duration-200">
        <div className="grid grid-cols-1 md:grid-cols-3 lg:grid-cols-5 gap-4">
          <div className="col-span-1 md:col-span-3 lg:col-span-2">
            <div className="relative">
              <input 
                type="text" 
                placeholder="Pesquisar leads..." 
                className="w-full border dark:border-gray-700 rounded-md pl-10 pr-4 py-2 text-sm dark:bg-gray-800 dark:text-white transition-colors duration-200"
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
              />
              <span className="material-icons absolute left-3 top-2 text-gray-400 dark:text-gray-300 text-sm">search</span>
            </div>
          </div>
          <div>
            <select 
              className="w-full border dark:border-gray-700 rounded-md px-3 py-2 text-sm dark:bg-gray-800 dark:text-white transition-colors duration-200"
              value={filters.source}
              onChange={(e) => setFilters({...filters, source: e.target.value})}
            >
              <option value="">Origem</option>
              <option value="Favale">Favale</option>
              <option value="Pink">Pink</option>
            </select>
          </div>
          <div>
            <select 
              className="w-full border dark:border-gray-700 rounded-md px-3 py-2 text-sm dark:bg-gray-800 dark:text-white transition-colors duration-200"
              value={filters.status}
              onChange={(e) => setFilters({...filters, status: e.target.value})}
            >
              <option value="">Status</option>
              <option value="Lead">Lead</option>
              <option value="Aluno">Aluno</option>
            </select>
          </div>
          <div>
            <select 
              className="w-full border dark:border-gray-700 rounded-md px-3 py-2 text-sm dark:bg-gray-800 dark:text-white transition-colors duration-200"
              value={filters.campaign}
              onChange={(e) => setFilters({...filters, campaign: e.target.value})}
            >
              <option value="">Campanha</option>
              <option value="Instagram">Instagram</option>
              <option value="Facebook">Facebook</option>
              <option value="Email">E-mail</option>
              <option value="Site">Site</option>
              <option value="Indicação">Indicação</option>
            </select>
          </div>
        </div>
        
        {/* Advanced filter panel */}
        {filterMenuOpen && (
          <div className="mt-4 pt-4 border-t border-gray-200 dark:border-gray-700">
            <h3 className="text-sm font-medium text-gray-700 dark:text-gray-300 mb-3">Filtros Avançados</h3>
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
              <div>
                <label className="block text-xs font-medium text-gray-500 dark:text-gray-400 mb-1">Estado</label>
                <select 
                  className="w-full border dark:border-gray-700 rounded-md px-3 py-2 text-sm dark:bg-gray-800 dark:text-white transition-colors duration-200"
                  value={filters.state || ""}
                  onChange={(e) => setFilters({...filters, state: e.target.value})}
                >
                  <option value="">Todos</option>
                  <option value="SP">São Paulo</option>
                  <option value="RJ">Rio de Janeiro</option>
                  <option value="MG">Minas Gerais</option>
                  <option value="RS">Rio Grande do Sul</option>
                  <option value="PR">Paraná</option>
                  <option value="SC">Santa Catarina</option>
                  <option value="BA">Bahia</option>
                  <option value="DF">Distrito Federal</option>
                </select>
              </div>
              
              <div>
                <label className="block text-xs font-medium text-gray-500 dark:text-gray-400 mb-1">Data de Entrada</label>
                <div className="flex items-center space-x-2">
                  <input 
                    type="date" 
                    className="flex-1 border dark:border-gray-700 rounded-md px-3 py-2 text-sm dark:bg-gray-800 dark:text-white transition-colors duration-200"
                    value={filters.startDate || ""}
                    onChange={(e) => setFilters({...filters, startDate: e.target.value})}
                  />
                  <span className="text-gray-500 dark:text-gray-400">até</span>
                  <input 
                    type="date" 
                    className="flex-1 border dark:border-gray-700 rounded-md px-3 py-2 text-sm dark:bg-gray-800 dark:text-white transition-colors duration-200"
                    value={filters.endDate || ""}
                    onChange={(e) => setFilters({...filters, endDate: e.target.value})}
                  />
                </div>
              </div>
              
              <div>
                <label className="block text-xs font-medium text-gray-500 dark:text-gray-400 mb-1">Tag</label>
                <select 
                  className="w-full border dark:border-gray-700 rounded-md px-3 py-2 text-sm dark:bg-gray-800 dark:text-white transition-colors duration-200"
                  value={filters.tag || ""}
                  onChange={(e) => setFilters({...filters, tag: e.target.value})}
                >
                  <option value="">Todas</option>
                  {getUniqueTags().map((tag, index) => (
                    <option key={index} value={tag}>{tag}</option>
                  ))}
                </select>
              </div>
              
              <div>
                <label className="block text-xs font-medium text-gray-500 dark:text-gray-400 mb-1">Período</label>
                <select 
                  className="w-full border dark:border-gray-700 rounded-md px-3 py-2 text-sm dark:bg-gray-800 dark:text-white transition-colors duration-200"
                  value={filters.dateRange || ""}
                  onChange={(e) => handleDateRangeChange(e.target.value)}
                >
                  <option value="">Todos</option>
                  <option value="today">Hoje</option>
                  <option value="last7days">Últimos 7 dias</option>
                  <option value="last30days">Últimos 30 dias</option>
                  <option value="thisMonth">Este mês</option>
                  <option value="lastMonth">Mês passado</option>
                  <option value="thisYear">Este ano</option>
                  <option value="custom">Período personalizado</option>
                </select>
              </div>
              
              <div className="flex items-end">
                <button 
                  className="w-full bg-primary text-white rounded-md px-4 py-2 text-sm flex items-center justify-center hover:bg-primary/90 dark:glow-button-xs transition-all duration-200"
                  onClick={() => setFilters({ 
                    source: "", 
                    status: "", 
                    campaign: "", 
                    state: "", 
                    startDate: "", 
                    endDate: "",
                    tag: "",
                    dateRange: ""
                  })}
                >
                  <span className="material-icons text-sm mr-1">clear</span>
                  Limpar Filtros
                </button>
              </div>
            </div>
          </div>
        )}
      </div>
      
      {/* Batch Operations Bar - only visible when leads are selected */}
      {selectedLeadIds.length > 0 && (
        <div className="bg-primary-50 dark:bg-gray-800 border border-primary-200 dark:border-gray-700 rounded-lg p-4 mb-6 flex flex-wrap items-center gap-4 transition-colors duration-200">
          <div className="flex flex-col">
            <div className="flex items-center">
              <span className="font-semibold text-primary dark:text-pink-400 mr-2">{selectedLeadIds.length}</span>
              <span className="text-gray-700 dark:text-gray-300">leads selecionados</span>
            </div>
            <div className="flex items-center space-x-3 mt-1 text-sm">
              <button 
                onClick={() => setSelectedLeadIds([])}
                className="text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-200 text-xs transition-colors duration-200"
              >
                Limpar seleção
              </button>
              
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <button className="text-xs font-medium text-primary dark:text-primary-light hover:text-primary/80 dark:hover:text-primary-light/80 transition-colors duration-200 flex items-center">
                    Selecionar mais <span className="material-icons text-xs ml-0.5">arrow_drop_down</span>
                  </button>
                </DropdownMenuTrigger>
                <DropdownMenuContent 
                  align="start" 
                  className="bg-white dark:bg-gray-700 border dark:border-gray-600 rounded-md shadow-lg dark:shadow-gray-900/50 z-50"
                >
                  <DropdownMenuItem 
                    className="text-sm px-3 py-2 cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-600 text-gray-800 dark:text-gray-200 flex items-center"
                    onClick={() => {
                      // Selecionar todos os leads da página atual
                      const pageLeads = (filteredLeads || []).slice(indexOfFirstLead, indexOfLastLead).map(lead => lead.id);
                      const newSelection = [...new Set([...selectedLeadIds, ...pageLeads])];
                      setSelectedLeadIds(newSelection);
                    }}
                  >
                    <span className="material-icons text-xs mr-2">view_list</span>
                    Todos da página atual
                  </DropdownMenuItem>
                  <DropdownMenuItem 
                    className="text-sm px-3 py-2 cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-600 text-gray-800 dark:text-gray-200 flex items-center"
                    onClick={() => {
                      // Selecionar todos os leads
                      const allIds = (filteredLeads || []).map(lead => lead.id);
                      setSelectedLeadIds(allIds);
                    }}
                  >
                    <span className="material-icons text-xs mr-2">select_all</span>
                    Todos os leads ({filteredLeads?.length || 0})
                  </DropdownMenuItem>
                </DropdownMenuContent>
              </DropdownMenu>
            </div>
          </div>
          
          <div className="flex items-center space-x-2">
            <Select
              value={batchStatusValue}
              onValueChange={setBatchStatusValue}
            >
              <SelectTrigger className="w-[180px] h-9 text-sm">
                <SelectValue placeholder="Alterar status" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="Lead">Lead</SelectItem>
                <SelectItem value="Aluno">Aluno</SelectItem>
              </SelectContent>
            </Select>
            
            <button 
              className="bg-primary text-white rounded-md px-3 py-1 text-sm hover:bg-primary/90 dark:glow-button-xs transition-all duration-200"
              onClick={handleBatchStatusUpdate}
              disabled={!batchStatusValue}
            >
              Aplicar
            </button>
          </div>
          
          <div className="flex items-center space-x-2">
            <Select
              value={batchSourceValue}
              onValueChange={setBatchSourceValue}
            >
              <SelectTrigger className="w-[180px] h-9 text-sm">
                <SelectValue placeholder="Alterar origem" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="Favale">Favale</SelectItem>
                <SelectItem value="Pink">Pink</SelectItem>
              </SelectContent>
            </Select>
            
            <button 
              className="bg-primary text-white rounded-md px-3 py-1 text-sm hover:bg-primary/90 dark:glow-button-xs transition-all duration-200"
              onClick={handleBatchSourceUpdate}
              disabled={!batchSourceValue}
            >
              Aplicar
            </button>
          </div>
          
          <button 
            className="ml-auto bg-red-100 dark:bg-red-900/30 text-red-600 dark:text-red-400 hover:bg-red-200 dark:hover:bg-red-900/50 rounded-md px-3 py-1 text-sm transition-colors duration-200"
            onClick={handleBatchDelete}
          >
            Excluir selecionados
          </button>
        </div>
      )}

      {/* Lead table */}
      <LeadTable 
        leads={filteredLeads || []} 
        isLoading={isLoading} 
        onDelete={handleDelete}
        indexOfFirstLead={indexOfFirstLead}
      />

      {/* Lead Dialog */}
      <LeadDialog />
      
      {/* Export Dialog */}
      <Dialog open={exportDialogOpen} onOpenChange={setExportDialogOpen}>
        <DialogContent className="max-w-md">
          <DialogHeader>
            <DialogTitle>Exportar Leads</DialogTitle>
            <DialogDescription>
              Selecione o formato para exportar {filteredLeads?.length || 0} leads.
            </DialogDescription>
          </DialogHeader>
          
          <div className="my-6 space-y-4">
            <div className="space-y-2">
              <label className="text-sm font-medium">Formato de exportação</label>
              <Select
                value={exportFormat}
                onValueChange={(value) => setExportFormat(value as "csv" | "json" | "excel")}
              >
                <SelectTrigger className="w-full h-10">
                  <SelectValue placeholder="Formato" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="csv">CSV</SelectItem>
                  <SelectItem value="excel">Excel CSV (compatível)</SelectItem>
                  <SelectItem value="json">JSON</SelectItem>
                </SelectContent>
              </Select>
              
              <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                {exportFormat === "csv" && "Formato padrão CSV, fácil de importar em qualquer sistema."}
                {exportFormat === "excel" && "Formato otimizado para importação no Excel, com suporte a caracteres especiais."}
                {exportFormat === "json" && "Formato estruturado para uso em sistemas e aplicações."}
              </p>
            </div>
            
            {exportLoading && (
              <div>
                <div className="flex items-center justify-between mb-2">
                  <span className="text-sm text-gray-500 dark:text-gray-400">
                    {exportProgress < 50 ? 'Preparando dados...' : 
                    exportProgress < 100 ? 'Gerando arquivo...' : 'Download concluído!'}
                  </span>
                  <span className="text-sm font-medium">{exportProgress}%</span>
                </div>
                <Progress value={exportProgress} className="h-2" />
              </div>
            )}
          </div>
          
          <DialogFooter>
            <button
              className="px-4 py-2 text-sm text-gray-700 dark:text-gray-300 border border-gray-300 dark:border-gray-700 rounded-md hover:bg-gray-50 dark:hover:bg-gray-800"
              onClick={() => setExportDialogOpen(false)}
              disabled={exportLoading}
            >
              Cancelar
            </button>
            <button
              className="px-4 py-2 text-sm text-white bg-primary hover:bg-primary/90 rounded-md disabled:opacity-50"
              onClick={handleExportLeads}
              disabled={exportLoading || !filteredLeads || filteredLeads.length === 0}
            >
              {exportLoading ? 'Exportando...' : 'Exportar agora'}
            </button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
      
      {/* Import Dialog */}
      <Dialog open={importDialogOpen} onOpenChange={setImportDialogOpen}>
        <DialogContent className="max-w-3xl">
          <DialogHeader>
            <DialogTitle>Importar Leads</DialogTitle>
            <DialogDescription>
              Importe leads a partir de um arquivo CSV. O arquivo deve seguir o seguinte formato:
            </DialogDescription>
          </DialogHeader>
          
          {importLoading && (
            <div className="my-4 space-y-4">
              {/* Barra de progresso principal */}
              <div>
                <div className="flex items-center justify-between mb-2">
                  <span className="text-sm text-gray-500 dark:text-gray-400">
                    {importProgress < 60 ? 'Processando arquivo...' : 
                     importProgress < 100 ? 'Importando leads...' : 'Concluído!'}
                  </span>
                  <span className="text-sm font-medium">{importProgress}%</span>
                </div>
                <Progress value={importProgress} className="h-2" />
              </div>
              
              {/* Detalhes das estatísticas */}
              <div className="bg-gray-50 dark:bg-gray-900 p-4 rounded-lg border dark:border-gray-800">
                <div className="mb-3">
                  <h4 className="text-sm font-medium mb-1">Status da importação</h4>
                  <p className="text-sm text-gray-600 dark:text-gray-400">{importStats.statusMessage}</p>
                </div>
                
                <div className="grid grid-cols-2 md:grid-cols-4 gap-3 mb-3">
                  <div className="bg-white dark:bg-gray-800 p-3 rounded-md shadow-sm">
                    <div className="text-xs text-gray-500 dark:text-gray-400">Lote atual</div>
                    <div className="text-lg font-semibold">{importStats.currentBatch} / {importStats.totalBatches}</div>
                  </div>
                  
                  <div className="bg-white dark:bg-gray-800 p-3 rounded-md shadow-sm">
                    <div className="text-xs text-gray-500 dark:text-gray-400">Processados</div>
                    <div className="text-lg font-semibold">{importStats.processedCount} / {importStats.totalCount}</div>
                  </div>
                  
                  <div className="bg-white dark:bg-gray-800 p-3 rounded-md shadow-sm">
                    <div className="text-xs text-gray-500 dark:text-gray-400">Importados</div>
                    <div className="text-lg font-semibold text-green-600 dark:text-green-500">{importStats.successCount + importStats.updatedCount}</div>
                    <div className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                      <span className="text-emerald-600 dark:text-emerald-500">{importStats.successCount} novos</span> / 
                      <span className="text-blue-600 dark:text-blue-500"> {importStats.updatedCount} atualizados</span>
                    </div>
                  </div>
                  
                  <div className="bg-white dark:bg-gray-800 p-3 rounded-md shadow-sm">
                    <div className="text-xs text-gray-500 dark:text-gray-400">Erros</div>
                    <div className="text-lg font-semibold text-red-600 dark:text-red-500">{importStats.errorCount}</div>
                  </div>
                </div>
                
                {/* Histórico de lotes processados */}
                {importStats.batchResults.length > 0 && (
                  <div>
                    <h4 className="text-sm font-medium mb-2">Histórico de lotes</h4>
                    <div className="bg-white dark:bg-gray-800 rounded-md overflow-hidden">
                      <div className="max-h-32 overflow-y-auto">
                        <table className="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
                          <thead className="bg-gray-50 dark:bg-gray-800">
                            <tr>
                              <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 dark:text-gray-400">Lote</th>
                              <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 dark:text-gray-400">Novos</th>
                              <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 dark:text-gray-400">Atualizados</th>
                              <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 dark:text-gray-400">Erros</th>
                            </tr>
                          </thead>
                          <tbody className="divide-y divide-gray-200 dark:divide-gray-700">
                            {importStats.batchResults.map((batch, index) => (
                              <tr key={index} className={index % 2 === 0 ? 'bg-white dark:bg-gray-900' : 'bg-gray-50 dark:bg-gray-800/50'}>
                                <td className="px-3 py-2 text-xs">{batch.batch}</td>
                                <td className="px-3 py-2 text-xs text-emerald-600 dark:text-emerald-500">{batch.success}</td>
                                <td className="px-3 py-2 text-xs text-blue-600 dark:text-blue-500">{batch.updated}</td>
                                <td className="px-3 py-2 text-xs text-red-600 dark:text-red-500">{batch.errors}</td>
                              </tr>
                            ))}
                          </tbody>
                        </table>
                      </div>
                    </div>
                  </div>
                )}
              </div>
            </div>
          )}
          
          {!showPreview ? (
            <div className="my-4">
              <div className="bg-gray-50 dark:bg-gray-900 p-4 rounded border dark:border-gray-700 mb-4 overflow-x-auto">
                <code className="text-xs">
                  <span className="text-blue-600 dark:text-blue-400">nome</span>,
                  <span className="text-blue-600 dark:text-blue-400">email</span>,
                  <span className="text-blue-600 dark:text-blue-400">telefone</span>,
                  <span className="text-blue-600 dark:text-blue-400">estado</span>,
                  <span className="text-blue-600 dark:text-blue-400">campanha</span>,
                  <span className="text-blue-600 dark:text-blue-400">origem</span>,
                  <span className="text-blue-600 dark:text-blue-400">status</span>,
                  <span className="text-blue-600 dark:text-blue-400">tags</span>,
                  <span className="text-blue-600 dark:text-blue-400">data_entrada</span>,
                  <span className="text-blue-600 dark:text-blue-400">observacoes</span>
                </code>
              </div>
              
              <ul className="space-y-2 text-sm mb-4">
                <li><span className="font-medium">nome</span>: Nome completo do lead (obrigatório)</li>
                <li><span className="font-medium">email</span>: Email do lead (obrigatório)</li>
                <li><span className="font-medium">telefone</span>: Número de telefone</li>
                <li><span className="font-medium">estado</span>: Sigla do estado (ex: SP, RJ)</li>
                <li><span className="font-medium">campanha</span>: Canal de origem (Instagram, Facebook, Email, Site, Indicação)</li>
                <li><span className="font-medium">origem</span>: Deve ser "Favale" ou "Pink"</li>
                <li><span className="font-medium">status</span>: Deve ser "Lead" ou "Aluno"</li>
                <li><span className="font-medium">tags</span>: Lista de tags separadas por ponto-e-vírgula (ex: "tag1;tag2;tag3")</li>
                <li><span className="font-medium">data_entrada</span>: Data no formato DD/MM/YYYY (ex: 31/01/2023)</li>
                <li><span className="font-medium">observacoes</span>: Notas adicionais</li>
              </ul>
              
              <div className="mb-4">
                <input 
                  type="file" 
                  accept=".csv" 
                  ref={fileInputRef} 
                  className="hidden" 
                  onChange={handleFileUpload}
                />
                <button 
                  className="w-full py-8 border-2 border-dashed border-gray-300 dark:border-gray-700 rounded-lg flex flex-col items-center justify-center cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-900 transition-colors duration-200"
                  onClick={() => fileInputRef.current?.click()}
                  disabled={importLoading}
                >
                  <span className="material-icons text-3xl text-gray-400 mb-2">upload_file</span>
                  <span className="text-gray-600 dark:text-gray-300">Clique para selecionar um arquivo CSV</span>
                  <span className="text-gray-400 text-sm mt-1">ou arraste e solte aqui</span>
                </button>
              </div>
            </div>
          ) : (
            <div className="my-4">
              <h3 className="text-lg font-medium mb-2">Pré-visualização ({previewData.length} leads)</h3>
              
              <div className="border dark:border-gray-700 rounded-lg overflow-hidden mb-4">
                <div className="max-h-64 overflow-y-auto">
                  <table className="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
                    <thead className="bg-gray-50 dark:bg-gray-800">
                      <tr>
                        {previewData.length > 0 && Object.keys(previewData[0]).map((header, index) => (
                          <th key={index} className="px-3 py-2 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">
                            {header}
                          </th>
                        ))}
                      </tr>
                    </thead>
                    <tbody className="bg-white dark:bg-gray-900 divide-y divide-gray-200 dark:divide-gray-700">
                      {previewData.slice(0, 5).map((row, rowIndex) => (
                        <tr key={rowIndex} className={rowIndex % 2 === 0 ? 'bg-white dark:bg-gray-900' : 'bg-gray-50 dark:bg-gray-800/50'}>
                          {Object.values(row).map((cell: any, cellIndex) => (
                            <td key={cellIndex} className="px-3 py-2 text-xs text-gray-800 dark:text-gray-200">
                              {typeof cell === 'string' && cell.length > 30 ? `${cell.substring(0, 30)}...` : cell}
                            </td>
                          ))}
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
                {previewData.length > 5 && (
                  <div className="px-3 py-2 bg-gray-50 dark:bg-gray-800 text-xs text-gray-500 dark:text-gray-400">
                    Mostrando 5 de {previewData.length} leads
                  </div>
                )}
              </div>
              
              <div className="flex justify-end space-x-2">
                <button
                  className="px-4 py-2 text-sm text-gray-700 dark:text-gray-300 border border-gray-300 dark:border-gray-700 rounded-md hover:bg-gray-50 dark:hover:bg-gray-800"
                  onClick={() => {
                    setShowPreview(false);
                    setPreviewData([]);
                    setParsedLeads([]);
                  }}
                  disabled={importLoading}
                >
                  Cancelar
                </button>
                <button
                  className="px-4 py-2 text-sm text-white bg-primary hover:bg-primary/90 rounded-md disabled:opacity-50"
                  onClick={confirmImport}
                  disabled={importLoading || parsedLeads.length === 0}
                >
                  {importLoading ? 'Importando...' : `Importar ${parsedLeads.length} leads`}
                </button>
              </div>
            </div>
          )}
        </DialogContent>
      </Dialog>

      {/* Delete Confirmation Dialog */}
      <AlertDialog open={deleteDialogOpen} onOpenChange={setDeleteDialogOpen}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Excluir Lead</AlertDialogTitle>
            <AlertDialogDescription>
              Tem certeza que deseja excluir o lead {selectedLead?.name}?
              Esta ação não pode ser desfeita.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancelar</AlertDialogCancel>
            <AlertDialogAction 
              onClick={confirmDelete}
              className="bg-red-600 hover:bg-red-700 dark:glow-red-sm transition-all duration-200"
            >
              Excluir
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      {/* Batch Delete Confirmation Dialog */}
      <AlertDialog open={batchDeleteDialogOpen} onOpenChange={setBatchDeleteDialogOpen}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Excluir Leads Selecionados</AlertDialogTitle>
            <AlertDialogDescription className="space-y-2">
              <p>
                Você está prestes a excluir <span className="font-bold text-red-600 dark:text-red-400">{selectedLeadIds.length}</span> leads.
              </p>
              <p>
                {selectedLeadIds.length > 100 && 
                  <span className="block font-semibold text-amber-600 dark:text-amber-400 mb-2">
                    Atenção: Você selecionou um grande número de leads!
                  </span>
                }
                Esta ação <span className="font-bold">não pode ser desfeita</span> e os dados serão excluídos permanentemente.
              </p>
              <p className="text-sm opacity-80">
                Você tem certeza que deseja continuar?
              </p>
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancelar</AlertDialogCancel>
            <AlertDialogAction 
              onClick={confirmBatchDelete}
              className="bg-red-600 hover:bg-red-700 dark:glow-red-sm transition-all duration-200"
            >
              Excluir {selectedLeadIds.length} leads
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}
</file>

<file path="client/src/components/leads/LeadStatusChangeNotification.tsx">
import { useState } from 'react';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { Lead } from '@shared/schema';
import { apiRequest } from '@/lib/queryClient';
import { useToast } from '@/hooks/use-toast';
import { AlertTriangle, Check, MessageSquare } from 'lucide-react';
import { Button } from '@/components/ui/button';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogFooter,
} from '@/components/ui/dialog';
import { Label } from '@/components/ui/label';
import { Switch } from '@/components/ui/switch';
import { Textarea } from '@/components/ui/textarea';

interface LeadStatusChangeNotificationProps {
  lead: Lead;
  isOpen: boolean;
  onClose: () => void;
  onSubmitChange: (sendNotification: boolean, message?: string) => void;
}

const DEFAULT_MESSAGE = `Olá {nome}, 

Estamos felizes em informar que sua inscrição foi confirmada com sucesso! 

Agora você é oficialmente um aluno da Favale&Pink Personal Training. Entraremos em contato para agendar sua primeira sessão.

Bem-vindo à nossa equipe!`;

export default function LeadStatusChangeNotification({
  lead,
  isOpen,
  onClose,
  onSubmitChange
}: LeadStatusChangeNotificationProps) {
  const [sendNotification, setSendNotification] = useState(true);
  const [message, setMessage] = useState(DEFAULT_MESSAGE.replace('{nome}', lead.name));
  const { toast } = useToast();
  const queryClient = useQueryClient();

  const sendNotificationMutation = useMutation({
    mutationFn: async () => {
      return apiRequest('POST', '/api/whatsapp/send', {
        leadId: lead.id,
        content: message,
        direction: 'outgoing',
        status: 'pending'
      });
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [`/api/whatsapp/lead/${lead.id}`] });
      toast({
        title: 'Notificação enviada',
        description: `Mensagem enviada para ${lead.name} (${lead.phone})`,
      });
      onSubmitChange(true, message);
    },
    onError: (error: any) => {
      console.error('Erro ao enviar notificação:', error);
      
      let errorMessage = 'Não foi possível enviar a notificação';
      if (error?.response?.data?.isUnauthorizedNumber) {
        errorMessage = `Número ${lead.phone} não autorizado. Apenas números verificados podem receber mensagens no ambiente de teste.`;
      } else if (error?.response?.data?.error) {
        errorMessage = error.response.data.error;
      }
      
      toast({
        title: 'Erro ao enviar notificação',
        description: errorMessage,
        variant: 'destructive',
      });
      
      // Mesmo com erro, permitimos alterar o status (só a notificação falhou)
      onSubmitChange(false);
    },
  });

  const handleSubmit = () => {
    if (sendNotification) {
      sendNotificationMutation.mutate();
    } else {
      onSubmitChange(false);
    }
  };

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-md">
        <DialogHeader>
          <DialogTitle>Alterar status para Aluno</DialogTitle>
          <DialogDescription>
            Este lead está sendo promovido para aluno. Deseja enviar uma notificação por WhatsApp?
          </DialogDescription>
        </DialogHeader>
        
        <div className="space-y-4 py-4">
          <div className="flex items-center space-x-2">
            <Switch
              id="send-notification"
              checked={sendNotification}
              onCheckedChange={setSendNotification}
            />
            <Label htmlFor="send-notification" className="cursor-pointer">
              Enviar notificação via WhatsApp
            </Label>
          </div>
          
          {sendNotification && (
            <div className="space-y-2">
              <Label htmlFor="message">Mensagem:</Label>
              <Textarea
                id="message"
                value={message}
                onChange={(e) => setMessage(e.target.value)}
                rows={8}
                className="min-h-[100px]"
                placeholder="Digite a mensagem para o novo aluno..."
              />
              
              <div className="flex items-start gap-2 text-xs text-muted-foreground mt-2">
                <AlertTriangle size={14} className="mt-0.5 min-w-[14px]" />
                <p>
                  Esta mensagem será enviada para {lead.phone}. 
                  Certifique-se de que o número está correto.
                </p>
              </div>
            </div>
          )}
        </div>
        
        <DialogFooter className="flex items-center justify-end gap-2">
          <Button variant="outline" onClick={onClose}>
            Cancelar
          </Button>
          <Button 
            type="submit"
            onClick={handleSubmit}
            disabled={sendNotificationMutation.isPending}
            className="flex items-center gap-1.5"
          >
            {sendNotificationMutation.isPending ? (
              "Enviando..."
            ) : (
              <>
                <Check size={16} />
                <span>Confirmar mudança</span>
              </>
            )}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="client/src/components/leads/LeadTable.tsx">
import { useState, useEffect } from "react";
import { Lead } from "@shared/schema";
import { useLeadContext } from "@/context/LeadContext";
import { useWhatsappContext } from "@/context/WhatsappContext";
import { formatDate } from "@/utils/formatters";
import WhatsappButton from "../whatsapp/WhatsappButton";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";

interface LeadTableProps {
  leads: Lead[];
  isLoading: boolean;
  onDelete: (lead: Lead) => void;
  indexOfFirstLead?: number;
}

export default function LeadTable({ leads, isLoading, onDelete, indexOfFirstLead: externalIndexOfFirstLead }: LeadTableProps) {
  const { 
    setSelectedLead, 
    setIsDialogOpen,
    selectedLeadIds,
    setSelectedLeadIds 
  } = useLeadContext();
  const { openWhatsappChat } = useWhatsappContext();
  const [currentPage, setCurrentPage] = useState(1);
  const leadsPerPage = 10;
  const [selectMode, setSelectMode] = useState<'page' | 'all'>('page');
  
  const handleEdit = (lead: Lead) => {
    setSelectedLead(lead);
    setIsDialogOpen(true);
  };
  
  const handleSelectLead = (leadId: number, checked: boolean) => {
    if (checked) {
      setSelectedLeadIds([...selectedLeadIds, leadId]);
    } else {
      setSelectedLeadIds(selectedLeadIds.filter(id => id !== leadId));
    }
  };
  
  const handleSelectAll = (checked: boolean) => {
    if (checked) {
      if (selectMode === 'page') {
        // Selecionar apenas os leads da página atual
        const allPageIds = currentLeads.map(lead => lead.id);
        setSelectedLeadIds(allPageIds);
      } else {
        // Selecionar todos os leads
        const allIds = leads.map(lead => lead.id);
        setSelectedLeadIds(allIds);
      }
    } else {
      setSelectedLeadIds([]);
    }
  };
  
  // Calculate pagination
  const indexOfLastLead = currentPage * leadsPerPage;
  const indexOfFirstLead = indexOfLastLead - leadsPerPage;
  const currentLeads = leads.slice(indexOfFirstLead, indexOfLastLead);
  const totalPages = Math.ceil(leads.length / leadsPerPage);
  
  // Generate page numbers for pagination
  const pageNumbers = [];
  for (let i = 1; i <= totalPages; i++) {
    if (
      i === 1 || 
      i === totalPages || 
      (i >= currentPage - 1 && i <= currentPage + 1)
    ) {
      pageNumbers.push(i);
    } else if (i === currentPage - 2 || i === currentPage + 2) {
      pageNumbers.push('...');
    }
  }
  
  // Remove duplicate ellipses
  const displayPageNumbers = pageNumbers.filter((number, index, self) => {
    return number === '...' ? self.indexOf(number) === index : true;
  });
  
  const getStatusBadgeClasses = (status: string) => {
    return status === "Aluno" 
      ? "inline-flex items-center px-1.5 sm:px-2 py-0.5 rounded-full text-[10px] sm:text-xs font-medium bg-green-100 text-green-800 dark:bg-green-900/30 dark:text-green-400 transition-colors duration-200 shadow-sm hover:shadow hover:-translate-y-0.5 transform"
      : "inline-flex items-center px-1.5 sm:px-2 py-0.5 rounded-full text-[10px] sm:text-xs font-medium bg-gray-100 text-gray-800 dark:bg-gray-700/50 dark:text-gray-300 transition-colors duration-200 shadow-sm hover:shadow hover:-translate-y-0.5 transform";
  };
  
  const getSourceBadgeClasses = (source: string) => {
    return source === "Favale" 
      ? "inline-flex items-center px-1.5 sm:px-2 py-0.5 rounded-full text-[10px] sm:text-xs font-medium bg-pink-100 text-primary dark:bg-pink-900/30 dark:text-pink-400 transition-colors duration-200 shadow-sm hover:shadow hover:-translate-y-0.5 transform"
      : "inline-flex items-center px-1.5 sm:px-2 py-0.5 rounded-full text-[10px] sm:text-xs font-medium bg-purple-100 text-secondary dark:bg-purple-900/30 dark:text-purple-400 transition-colors duration-200 shadow-sm hover:shadow hover:-translate-y-0.5 transform";
  };
  
  if (isLoading) {
    return (
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow-md dark:shadow-gray-900/30 p-6 flex justify-center items-center transition-all duration-200 min-h-[300px]">
        <div className="animate-spin rounded-full h-12 w-12 border-4 border-gray-200 dark:border-gray-700 border-t-primary dark:border-t-primary-light dark:shadow-glow-xs"></div>
      </div>
    );
  }
  
  return (
    <div className="bg-white dark:bg-gray-800 rounded-lg shadow-md dark:shadow-gray-900/30 overflow-hidden transition-all duration-200 hover:shadow-lg dark:hover:shadow-gray-900/40">
      <div className="overflow-x-auto">
        <table className="min-w-full">
          <thead>
            <tr className="bg-gray-50 dark:bg-gray-700 border-b dark:border-gray-600 transition-colors duration-200">
              <th className="px-2 sm:px-6 py-2 sm:py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">
                <input 
                  type="checkbox" 
                  className="mr-1 sm:mr-2 h-3 w-3 sm:h-4 sm:w-4 rounded border-primary/30 text-primary focus:ring-primary/30 transition-all duration-200"
                  checked={currentLeads.length > 0 && currentLeads.every(lead => selectedLeadIds.includes(lead.id))}
                  onChange={(e) => {
                    setSelectMode('page');
                    handleSelectAll(e.target.checked);
                  }}
                />
              </th>
              <th className="px-2 sm:px-6 py-2 sm:py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider hidden sm:table-cell">
                Data
              </th>
              <th className="px-2 sm:px-6 py-2 sm:py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">
                Nome
              </th>
              <th className="px-2 sm:px-6 py-2 sm:py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider hidden md:table-cell">
                Telefone
              </th>
              <th className="px-2 sm:px-6 py-2 sm:py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider hidden md:table-cell">
                Estado
              </th>
              <th className="px-2 sm:px-6 py-2 sm:py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider hidden lg:table-cell">
                Campanha
              </th>
              <th className="px-2 sm:px-6 py-2 sm:py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider hidden lg:table-cell">
                Tags
              </th>
              <th className="px-2 sm:px-6 py-2 sm:py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider hidden sm:table-cell">
                Origem
              </th>
              <th className="px-2 sm:px-6 py-2 sm:py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">
                Status
              </th>
              <th className="px-2 sm:px-6 py-2 sm:py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">
                Ações
              </th>
            </tr>
          </thead>
          <tbody className="bg-white dark:bg-gray-800 divide-y divide-gray-200 dark:divide-gray-700">
            {currentLeads.length > 0 ? (
              currentLeads.map((lead) => (
                <tr key={lead.id} className="hover:bg-gray-50 dark:hover:bg-gray-700/70 transition-all duration-200 hover:shadow-md dark:hover:shadow-gray-900/20">
                  <td className="px-2 sm:px-6 py-2 sm:py-4 whitespace-nowrap">
                    <input 
                      type="checkbox" 
                      className="h-3 w-3 sm:h-4 sm:w-4 rounded border-primary/30 text-primary focus:ring-primary/30 transition-all duration-200"
                      checked={selectedLeadIds.includes(lead.id)}
                      onChange={(e) => handleSelectLead(lead.id, e.target.checked)}
                    />
                  </td>
                  <td className="px-2 sm:px-6 py-2 sm:py-4 whitespace-nowrap text-xs sm:text-sm text-gray-600 dark:text-gray-300 hidden sm:table-cell">
                    {formatDate(lead.entryDate)}
                  </td>
                  <td className="px-2 sm:px-6 py-2 sm:py-4 whitespace-nowrap">
                    <div className="text-xs sm:text-sm font-medium text-gray-800 dark:text-gray-100 truncate max-w-[100px] sm:max-w-none">{lead.name}</div>
                    <div className="text-xs sm:text-sm text-gray-500 dark:text-gray-400 truncate max-w-[100px] sm:max-w-none">{lead.email}</div>
                  </td>
                  <td className="px-2 sm:px-6 py-2 sm:py-4 whitespace-nowrap text-xs sm:text-sm text-gray-600 dark:text-gray-300 hidden md:table-cell">
                    {lead.phone}
                  </td>
                  <td className="px-2 sm:px-6 py-2 sm:py-4 whitespace-nowrap text-xs sm:text-sm text-gray-600 dark:text-gray-300 hidden md:table-cell">
                    {lead.state}
                  </td>
                  <td className="px-2 sm:px-6 py-2 sm:py-4 whitespace-nowrap text-xs sm:text-sm text-gray-600 dark:text-gray-300 hidden lg:table-cell">
                    {lead.campaign}
                  </td>
                  <td className="px-2 sm:px-6 py-2 sm:py-4 whitespace-nowrap hidden lg:table-cell">
                    <div className="flex flex-wrap gap-1">
                      {lead.tags && lead.tags.map((tag, index) => (
                        <span 
                          key={index} 
                          className="bg-primary/10 text-primary dark:bg-primary/20 dark:text-pink-300 text-[10px] sm:text-xs px-1.5 sm:px-2 py-0.5 rounded-full font-medium transition-all duration-200 hover:bg-primary/20 dark:hover:bg-primary/30 dark:hover:shadow-glow-xs"
                        >
                          {tag}
                        </span>
                      ))}
                    </div>
                  </td>
                  <td className="px-2 sm:px-6 py-2 sm:py-4 whitespace-nowrap hidden sm:table-cell">
                    <span className={getSourceBadgeClasses(lead.source)}>
                      {lead.source}
                    </span>
                  </td>
                  <td className="px-2 sm:px-6 py-2 sm:py-4 whitespace-nowrap">
                    <span className={getStatusBadgeClasses(lead.status)}>
                      {lead.status}
                    </span>
                  </td>
                  <td className="px-2 sm:px-6 py-2 sm:py-4 whitespace-nowrap text-xs sm:text-sm font-medium">
                    <div className="flex space-x-1 sm:space-x-3">
                      <WhatsappButton onClick={() => openWhatsappChat(lead)} />
                      <button 
                        className="p-1 sm:p-1.5 rounded-full text-indigo-600 hover:text-indigo-500 hover:bg-indigo-50 dark:text-indigo-400 dark:hover:text-indigo-300 dark:hover:bg-indigo-900/30 transition-all duration-200"
                        onClick={() => handleEdit(lead)}
                        title="Editar"
                      >
                        <span className="material-icons text-xs sm:text-sm">edit</span>
                      </button>
                      <button 
                        className="p-1 sm:p-1.5 rounded-full text-red-600 hover:text-red-500 hover:bg-red-50 dark:text-red-400 dark:hover:text-red-300 dark:hover:bg-red-900/30 transition-all duration-200"
                        onClick={() => onDelete(lead)}
                        title="Excluir"
                      >
                        <span className="material-icons text-xs sm:text-sm">delete</span>
                      </button>
                    </div>
                  </td>
                </tr>
              ))
            ) : (
              <tr className="transition-colors duration-200">
                <td colSpan={10} className="px-2 sm:px-6 py-2 sm:py-4 text-center text-xs sm:text-sm text-gray-500 dark:text-gray-400 transition-colors duration-200">
                  Nenhum lead encontrado
                </td>
              </tr>
            )}
          </tbody>
        </table>
      </div>
      
      {/* Pagination */}
      {leads.length > 0 && (
        <div className="px-3 sm:px-6 py-3 sm:py-4 flex flex-col sm:flex-row items-center space-y-3 sm:space-y-0 justify-between border-t dark:border-gray-700">
          <div className="flex w-full sm:w-auto justify-between sm:hidden">
            <button 
              className="relative inline-flex items-center px-3 py-1.5 text-xs border border-gray-300 dark:border-gray-600 font-medium rounded-md text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-800 hover:bg-gray-50 dark:hover:bg-gray-700 focus:outline-none focus:ring-1 focus:ring-primary transition-all duration-200 hover:shadow-md dark:hover:shadow-glow-xs hover:-translate-y-0.5 transform"
              onClick={() => setCurrentPage(Math.max(currentPage - 1, 1))}
              disabled={currentPage === 1}
            >
              Anterior
            </button>
            <span className="inline-flex items-center text-xs text-gray-700 dark:text-gray-300">
              {currentPage} de {totalPages}
            </span>
            <button 
              className="relative inline-flex items-center px-3 py-1.5 text-xs border border-gray-300 dark:border-gray-600 font-medium rounded-md text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-800 hover:bg-gray-50 dark:hover:bg-gray-700 focus:outline-none focus:ring-1 focus:ring-primary transition-all duration-200 hover:shadow-md dark:hover:shadow-glow-xs hover:-translate-y-0.5 transform"
              onClick={() => setCurrentPage(Math.min(currentPage + 1, totalPages))}
              disabled={currentPage === totalPages}
            >
              Próximo
            </button>
          </div>
          <div className="hidden sm:flex-1 sm:flex sm:items-center sm:justify-between">
            <div>
              <p className="text-xs sm:text-sm text-gray-700 dark:text-gray-300">
                Mostrando <span className="font-medium">{indexOfFirstLead + 1}</span> a{" "}
                <span className="font-medium">
                  {Math.min(indexOfLastLead, leads.length)}
                </span>{" "}
                de <span className="font-medium">{leads.length}</span> resultados
              </p>
            </div>
            <div>
              <nav className="relative z-0 inline-flex rounded-md shadow-sm -space-x-px" aria-label="Pagination">
                <button 
                  className="relative inline-flex items-center px-2 py-1.5 sm:py-2 rounded-l-md border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 text-xs sm:text-sm font-medium text-gray-500 dark:text-gray-400 hover:bg-gray-50 dark:hover:bg-gray-700 focus:outline-none focus:ring-1 focus:ring-primary dark:focus:ring-offset-gray-800 transition-all duration-200 dark:hover:shadow-glow-xs hover:-translate-y-0.5 transform"
                  onClick={() => setCurrentPage(Math.max(currentPage - 1, 1))}
                  disabled={currentPage === 1}
                >
                  <span className="material-icons text-xs sm:text-sm">chevron_left</span>
                </button>
                {displayPageNumbers.map((number, index) => (
                  <button
                    key={index}
                    className={`relative inline-flex items-center px-3 sm:px-4 py-1.5 sm:py-2 border border-gray-300 dark:border-gray-600 text-xs sm:text-sm font-medium transition-all duration-200 ${
                      number === currentPage
                        ? "bg-primary text-white border-primary dark:border-primary dark:shadow-glow-sm"
                        : "bg-white dark:bg-gray-800 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700 hover:-translate-y-0.5 transform"
                    } focus:outline-none focus:ring-1 focus:ring-primary dark:focus:ring-offset-gray-800 ${number !== '...' ? 'hover:shadow-md dark:hover:shadow-glow-xs' : ''}`}
                    onClick={() => number !== '...' && setCurrentPage(number as number)}
                    disabled={number === '...'}
                  >
                    {number}
                  </button>
                ))}
                <button 
                  className="relative inline-flex items-center px-2 py-1.5 sm:py-2 rounded-r-md border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 text-xs sm:text-sm font-medium text-gray-500 dark:text-gray-400 hover:bg-gray-50 dark:hover:bg-gray-700 focus:outline-none focus:ring-1 focus:ring-primary dark:focus:ring-offset-gray-800 transition-all duration-200 dark:hover:shadow-glow-xs hover:-translate-y-0.5 transform"
                  onClick={() => setCurrentPage(Math.min(currentPage + 1, totalPages))}
                  disabled={currentPage === totalPages}
                >
                  <span className="material-icons text-xs sm:text-sm">chevron_right</span>
                </button>
              </nav>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="client/src/components/leads/TagInput.tsx">
import { useState, KeyboardEvent } from "react";

interface TagInputProps {
  tags: string[];
  setTags: (tags: string[]) => void;
}

export default function TagInput({ tags, setTags }: TagInputProps) {
  const [inputValue, setInputValue] = useState("");
  
  const addTag = (tag: string) => {
    const trimmedTag = tag.trim();
    if (trimmedTag && !tags.includes(trimmedTag)) {
      setTags([...tags, trimmedTag]);
      setInputValue("");
    }
  };
  
  const removeTag = (index: number) => {
    setTags(tags.filter((_, i) => i !== index));
  };
  
  const handleKeyDown = (e: KeyboardEvent<HTMLInputElement>) => {
    if (e.key === "Enter" || e.key === ",") {
      e.preventDefault();
      addTag(inputValue);
    }
  };
  
  return (
    <div className="flex flex-wrap gap-2 p-2 border rounded-md min-h-[42px] focus-within:ring-2 focus-within:ring-primary dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100 dark:focus-within:ring-primary/60 transition-colors duration-200">
      {tags.map((tag, index) => (
        <span 
          key={index} 
          className="bg-primary-light text-primary-dark dark:bg-primary/20 dark:text-pink-300 text-xs px-2 py-1 rounded-full flex items-center transition-all duration-200 hover:bg-primary/20 dark:hover:bg-primary/30 dark:hover:shadow-glow-xs"
        >
          {tag}
          <button 
            type="button"
            className="ml-1"
            onClick={() => removeTag(index)}
          >
            <span className="material-icons text-xs">close</span>
          </button>
        </span>
      ))}
      <input 
        type="text" 
        placeholder="Adicionar tag..." 
        className="border-none outline-none flex-grow text-sm min-w-[120px] bg-transparent dark:text-gray-100 dark:placeholder-gray-400 transition-colors duration-200"
        value={inputValue}
        onChange={(e) => setInputValue(e.target.value)}
        onKeyDown={handleKeyDown}
        onBlur={() => inputValue && addTag(inputValue)}
      />
    </div>
  );
}
</file>

<file path="client/src/components/oauth/GoogleCalendarConfig.tsx">
import { useState, useEffect } from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Separator } from '@/components/ui/separator';
import { toast } from '@/hooks/use-toast';
import { Loader2, Calendar, Check, X, RefreshCw } from 'lucide-react';
import { apiRequest } from '@/lib/queryClient';

interface TokenStatus {
  authorized: boolean;
  isExpired?: boolean;
  hasRefreshToken?: boolean;
  expiryDate?: string;
  message?: string;
}

export default function GoogleCalendarConfig() {
  const [tokenStatus, setTokenStatus] = useState<TokenStatus | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [isAuthenticating, setIsAuthenticating] = useState(false);

  const fetchTokenStatus = async () => {
    try {
      setIsLoading(true);
      const response = await apiRequest('GET', '/api/oauth/google/status');
      setTokenStatus(response);
    } catch (error) {
      console.error('Erro ao verificar status:', error);
      toast({
        title: 'Erro',
        description: 'Não foi possível verificar o status da autorização',
        variant: 'destructive',
      });
    } finally {
      setIsLoading(false);
    }
  };

  const handleGoogleAuth = async () => {
    try {
      setIsAuthenticating(true);
      const response = await apiRequest('GET', '/api/oauth/google/auth-url');
      
      // Abrir janela de autorização
      const authWindow = window.open(
        response.authUrl,
        'google-auth',
        'width=500,height=600,scrollbars=yes,resizable=yes'
      );

      // Monitorar o fechamento da janela
      const checkClosed = setInterval(() => {
        if (authWindow?.closed) {
          clearInterval(checkClosed);
          setIsAuthenticating(false);
          // Recarregar status após autorização
          setTimeout(fetchTokenStatus, 1000);
        }
      }, 1000);

      // Timeout após 5 minutos
      setTimeout(() => {
        if (!authWindow?.closed) {
          authWindow?.close();
          clearInterval(checkClosed);
          setIsAuthenticating(false);
        }
      }, 300000);

    } catch (error) {
      setIsAuthenticating(false);
      toast({
        title: 'Erro',
        description: 'Não foi possível iniciar a autorização',
        variant: 'destructive',
      });
    }
  };

  const handleRevokeAccess = async () => {
    if (!confirm('Tem certeza que deseja revogar o acesso ao Google Calendar?')) {
      return;
    }

    try {
      setIsLoading(true);
      await apiRequest('DELETE', '/api/oauth/google/revoke');
      
      toast({
        title: 'Acesso revogado',
        description: 'O acesso ao Google Calendar foi revogado com sucesso',
      });
      
      await fetchTokenStatus();
    } catch (error) {
      toast({
        title: 'Erro',
        description: 'Não foi possível revogar o acesso',
        variant: 'destructive',
      });
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchTokenStatus();
  }, []);

  const getStatusBadge = () => {
    if (!tokenStatus) return null;

    if (!tokenStatus.authorized) {
      return <Badge variant="destructive">Não autorizado</Badge>;
    }

    if (tokenStatus.isExpired) {
      return <Badge variant="outline">Token expirado</Badge>;
    }

    return <Badge variant="default" className="bg-green-500">Autorizado</Badge>;
  };

  return (
    <Card className="border-gray-100 dark:border-gray-700 shadow-sm rounded-xl">
      <CardHeader className="pb-3">
        <CardTitle className="text-lg font-medium text-gray-800 dark:text-white flex items-center gap-2">
          <Calendar className="h-5 w-5" />
          Integração Google Calendar
        </CardTitle>
        <CardDescription className="text-gray-500 dark:text-gray-400">
          Configure a integração com o Google Calendar para sincronizar agendamentos
        </CardDescription>
      </CardHeader>
      
      <CardContent className="space-y-4">
        {isLoading ? (
          <div className="flex items-center justify-center py-8">
            <Loader2 className="h-8 w-8 animate-spin text-primary" />
          </div>
        ) : (
          <>
            <div className="flex items-center justify-between">
              <span className="text-sm font-medium">Status da Autorização:</span>
              {getStatusBadge()}
            </div>

            {tokenStatus?.authorized && (
              <>
                <Separator />
                <div className="space-y-2 text-sm">
                  <div className="flex items-center justify-between">
                    <span>Token de Atualização:</span>
                    {tokenStatus.hasRefreshToken ? (
                      <Check className="h-4 w-4 text-green-500" />
                    ) : (
                      <X className="h-4 w-4 text-red-500" />
                    )}
                  </div>
                  
                  {tokenStatus.expiryDate && (
                    <div className="flex items-center justify-between">
                      <span>Expira em:</span>
                      <span className="text-muted-foreground">
                        {new Date(tokenStatus.expiryDate).toLocaleString('pt-BR')}
                      </span>
                    </div>
                  )}
                </div>
              </>
            )}

            <Separator />

            <div className="flex gap-2">
              {!tokenStatus?.authorized || tokenStatus.isExpired ? (
                <Button 
                  onClick={handleGoogleAuth} 
                  disabled={isAuthenticating}
                  className="flex-1"
                >
                  {isAuthenticating ? (
                    <>
                      <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                      Autorizando...
                    </>
                  ) : (
                    <>
                      <Calendar className="mr-2 h-4 w-4" />
                      Autorizar Google Calendar
                    </>
                  )}
                </Button>
              ) : (
                <>
                  <Button 
                    onClick={fetchTokenStatus} 
                    variant="outline"
                    disabled={isLoading}
                  >
                    <RefreshCw className="mr-2 h-4 w-4" />
                    Atualizar
                  </Button>
                  
                  <Button 
                    onClick={handleRevokeAccess} 
                    variant="destructive"
                    disabled={isLoading}
                  >
                    Revogar Acesso
                  </Button>
                </>
              )}
            </div>

            {!tokenStatus?.authorized && (
              <div className="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-md p-3">
                <p className="text-sm text-blue-700 dark:text-blue-300">
                  Para sincronizar agendamentos com o Google Calendar, você precisa autorizar o acesso. 
                  Clique no botão acima para iniciar o processo de autorização.
                </p>
              </div>
            )}
          </>
        )}
      </CardContent>
    </Card>
  );
}
</file>

<file path="client/src/components/professors/ProfessorDialog.tsx">
import { useState, useEffect } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { z } from "zod";
import { User, Mail, Phone, CreditCard, Shield, MapPin } from "lucide-react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Checkbox } from "@/components/ui/checkbox";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { useToast } from "@/hooks/use-toast";
import type { IProfessor } from "@/types";

// Form validation schema
const professorFormSchema = z.object({
  username: z.string().min(3, "Username deve ter pelo menos 3 caracteres"),
  password: z.string().optional(),
  name: z.string().min(2, "Nome deve ter pelo menos 2 caracteres"),
  email: z.string().email("Email inválido").optional().or(z.literal("")),
  phone: z.string().optional(),
  address: z.string().optional(),
  specialty: z.string().optional(),
  bio: z.string().optional(),
  hourlyRate: z.number().min(0, "Taxa horária deve ser maior ou igual a zero").optional(),
  active: z.boolean().default(true),
});

type ProfessorFormData = z.infer<typeof professorFormSchema>;

interface ProfessorDialogProps {
  professor?: IProfessor | null;
  open: boolean;
  onClose: () => void;
}

export function ProfessorDialog({ professor, open, onClose }: ProfessorDialogProps) {
  const { toast } = useToast();
  const queryClient = useQueryClient();
  const isEditing = !!professor;

  const form = useForm<ProfessorFormData>({
    resolver: zodResolver(professorFormSchema),
    defaultValues: {
      username: "",
      password: "",
      name: "",
      email: "",
      phone: "",
      address: "",
      specialty: "",
      bio: "",
      hourlyRate: 0,
      active: true,
    },
  });

  // Reset form when professor changes
  useEffect(() => {
    if (professor && open) {
      form.reset({
        username: professor.username || "",
        password: "", // Don't show existing password
        name: professor.name || "",
        email: professor.email || "",
        phone: professor.phone || "",
        address: professor.address || "",
        specialty: professor.specialty || "",
        bio: professor.bio || "",
        hourlyRate: professor.hourlyRate ? professor.hourlyRate / 100 : 0, // Convert from cents
        active: professor.active ?? true,
      });
    } else if (!professor && open) {
      form.reset({
        username: "",
        password: "",
        name: "",
        email: "",
        phone: "",
        address: "",
        specialty: "",
        bio: "",
        hourlyRate: 0,
        active: true,
      });
    }
  }, [professor, open, form]);

  // Create professor mutation
  const createProfessorMutation = useMutation({
    mutationFn: async (data: ProfessorFormData) => {
      const response = await fetch("/api/users/professors", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          username: data.username,
          password: data.password,
          name: data.name,
          email: data.email || null,
          phone: data.phone || null,
          address: data.address || null,
          specialty: data.specialty || null,
          bio: data.bio || null,
          hourlyRate: data.hourlyRate ? Math.round(data.hourlyRate * 100) : null, // Convert to cents
          active: data.active,
          role: "professor",
        }),
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.message || "Erro ao criar professor");
      }
      
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/users/professors"] });
      toast({
        title: "Professor criado",
        description: "Professor criado com sucesso",
      });
      onClose();
      form.reset();
    },
    onError: (error: Error) => {
      toast({
        title: "Erro ao criar professor",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  // Update professor mutation
  const updateProfessorMutation = useMutation({
    mutationFn: async (data: ProfessorFormData) => {
      const updateData: any = {
        username: data.username,
        name: data.name,
        email: data.email || null,
        phone: data.phone || null,
        address: data.address || null,
        specialty: data.specialty || null,
        bio: data.bio || null,
        hourlyRate: data.hourlyRate ? Math.round(data.hourlyRate * 100) : null, // Convert to cents
        active: data.active,
      };

      // Only include password if it's provided
      if (data.password && data.password.trim() !== "") {
        updateData.password = data.password;
      }

      const response = await fetch(`/api/users/professors/${professor!.id}`, {
        method: "PATCH",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(updateData),
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.message || "Erro ao atualizar professor");
      }
      
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/users/professors"] });
      toast({
        title: "Professor atualizado",
        description: "Professor atualizado com sucesso",
      });
      onClose();
    },
    onError: (error: Error) => {
      toast({
        title: "Erro ao atualizar professor",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  const onSubmit = (data: ProfessorFormData) => {
    if (isEditing) {
      updateProfessorMutation.mutate(data);
    } else {
      createProfessorMutation.mutate(data);
    }
  };

  const isLoading = createProfessorMutation.isPending || updateProfessorMutation.isPending;

  return (
    <Dialog open={open} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-[600px] max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <User className="h-5 w-5" />
            {isEditing ? "Editar Professor" : "Novo Professor"}
          </DialogTitle>
        </DialogHeader>

        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
            {/* Basic Information */}
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <FormField
                control={form.control}
                name="username"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel className="flex items-center gap-2">
                      <User className="h-4 w-4" />
                      Username *
                    </FormLabel>
                    <FormControl>
                      <Input {...field} placeholder="Digite o username" />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="password"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel className="flex items-center gap-2">
                      <Shield className="h-4 w-4" />
                      {isEditing ? "Nova Senha (opcional)" : "Senha *"}
                    </FormLabel>
                    <FormControl>
                      <Input
                        {...field}
                        type="password"
                        placeholder={isEditing ? "Deixe em branco para manter atual" : "Digite a senha"}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
            </div>

            <FormField
              control={form.control}
              name="name"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Nome Completo *</FormLabel>
                  <FormControl>
                    <Input {...field} placeholder="Digite o nome completo" />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            {/* Contact Information */}
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <FormField
                control={form.control}
                name="email"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel className="flex items-center gap-2">
                      <Mail className="h-4 w-4" />
                      Email
                    </FormLabel>
                    <FormControl>
                      <Input {...field} type="email" placeholder="professor@exemplo.com" />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="phone"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel className="flex items-center gap-2">
                      <Phone className="h-4 w-4" />
                      Telefone
                    </FormLabel>
                    <FormControl>
                      <Input {...field} placeholder="(11) 99999-9999" />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
            </div>

            {/* Address */}
            <FormField
              control={form.control}
              name="address"
              render={({ field }) => (
                <FormItem>
                  <FormLabel className="flex items-center gap-2">
                    <MapPin className="h-4 w-4" />
                    Endereço
                  </FormLabel>
                  <FormControl>
                    <Input {...field} placeholder="Digite o endereço completo" />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            {/* Professional Information */}
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <FormField
                control={form.control}
                name="specialty"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Especialidade</FormLabel>
                    <FormControl>
                      <Input {...field} placeholder="Ex: Personal Trainer, Pilates..." />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="hourlyRate"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel className="flex items-center gap-2">
                      <CreditCard className="h-4 w-4" />
                      Taxa Horária (R$)
                    </FormLabel>
                    <FormControl>
                      <Input
                        {...field}
                        type="number"
                        step="0.01"
                        min="0"
                        placeholder="0.00"
                        onChange={(e) => field.onChange(parseFloat(e.target.value) || 0)}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
            </div>

            {/* Bio */}
            <FormField
              control={form.control}
              name="bio"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Biografia</FormLabel>
                  <FormControl>
                    <Textarea
                      {...field}
                      placeholder="Digite uma breve biografia do professor..."
                      rows={3}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            {/* Active Status */}
            <FormField
              control={form.control}
              name="active"
              render={({ field }) => (
                <FormItem className="flex flex-row items-center space-x-3 space-y-0">
                  <FormControl>
                    <Checkbox
                      checked={field.value}
                      onCheckedChange={field.onChange}
                    />
                  </FormControl>
                  <div className="space-y-1 leading-none">
                    <FormLabel>Professor Ativo</FormLabel>
                    <p className="text-sm text-muted-foreground">
                      Desmarque para desativar temporariamente o professor
                    </p>
                  </div>
                </FormItem>
              )}
            />

            {/* Buttons */}
            <div className="flex justify-end gap-3 pt-4">
              <Button
                type="button"
                variant="outline"
                onClick={onClose}
                disabled={isLoading}
              >
                Cancelar
              </Button>
              <Button type="submit" disabled={isLoading}>
                {isLoading ? "Salvando..." : isEditing ? "Atualizar" : "Criar Professor"}
              </Button>
            </div>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="client/src/components/ProtectedRoute.tsx">
import { useAuth } from "@/hooks/use-auth";
import { Loader2 } from "lucide-react";
import { Redirect, Route, RouteComponentProps } from "wouter";

interface ProtectedRouteProps {
  path: string;
  component: React.ComponentType<any>;
}

export default function ProtectedRoute({ path, component: Component }: ProtectedRouteProps) {
  const { user, isLoading } = useAuth();

  if (isLoading) {
    return (
      <Route path={path}>
        {() => (
          <div className="flex items-center justify-center min-h-screen">
            <Loader2 className="h-8 w-8 animate-spin text-primary" />
          </div>
        )}
      </Route>
    );
  }

  if (!user) {
    return (
      <Route path={path}>
        {() => <Redirect to="/auth" />}
      </Route>
    );
  }

  return (
    <Route path={path}>
      {(params) => <Component {...params} />}
    </Route>
  );
}
</file>

<file path="client/src/components/scheduling/AppointmentDetailsDialog.tsx">
import { useState } from "react";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Separator } from "@/components/ui/separator";
import { useToast } from "@/hooks/use-toast";
import {
  Calendar,
  Clock,
  MapPin,
  DollarSign,
  User,
  Building,
  Phone,
  Mail,
  FileText,
  Trash2,
  Edit3,
  CheckCircle,
  XCircle,
  AlertTriangle,
} from "lucide-react";
import { format } from "date-fns";
import { ptBR } from "date-fns/locale";
import type { IAula } from "@/types";

interface AppointmentDetailsDialogProps {
  isOpen: boolean;
  onClose: () => void;
  appointment: IAula | null;
  onEdit?: (appointment: IAula) => void;
}

const statusConfig = {
  agendado: { label: "Agendado", color: "bg-blue-500", icon: Calendar },
  em_andamento: { label: "Em Andamento", color: "bg-amber-500", icon: Clock },
  concluido: { label: "Concluído", color: "bg-green-500", icon: CheckCircle },
  cancelado: { label: "Cancelado", color: "bg-red-500", icon: XCircle },
  remarcado: { label: "Remarcado", color: "bg-purple-500", icon: AlertTriangle },
};

export default function AppointmentDetailsDialog({
  isOpen,
  onClose,
  appointment,
  onEdit,
}: AppointmentDetailsDialogProps) {
  const [isDeleting, setIsDeleting] = useState(false);
  const { toast } = useToast();
  const queryClient = useQueryClient();

  const deleteAppointment = useMutation({
    mutationFn: async (id: number) => {
      const response = await fetch(`/api/appointments/${id}`, {
        method: "DELETE",
      });
      if (!response.ok) {
        throw new Error("Erro ao deletar agendamento");
      }
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/appointments"] });
      toast({
        title: "Agendamento deletado",
        description: "O agendamento foi removido com sucesso.",
      });
      onClose();
    },
    onError: (error) => {
      toast({
        title: "Erro ao deletar",
        description: "Não foi possível deletar o agendamento. Tente novamente.",
        variant: "destructive",
      });
    },
  });

  const handleDelete = async () => {
    if (!appointment) return;
    
    setIsDeleting(true);
    try {
      await deleteAppointment.mutateAsync(appointment.id);
    } finally {
      setIsDeleting(false);
    }
  };

  const handleEdit = () => {
    if (appointment && onEdit) {
      onEdit(appointment);
      onClose();
    }
  };

  if (!appointment) return null;

  const status = statusConfig[appointment.status] || statusConfig.agendado;
  const StatusIcon = status.icon;

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-2xl max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-3">
            <StatusIcon className="h-6 w-6" />
            Detalhes do Agendamento
          </DialogTitle>
          <DialogDescription>
            Informações completas sobre este agendamento
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-6">
          {/* Status e Informações Básicas */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center justify-between">
                <span className="flex items-center gap-2">
                  <Calendar className="h-5 w-5" />
                  {appointment.service || "Serviço"}
                </span>
                <Badge className={`${status.color} text-white`}>
                  {status.label}
                </Badge>
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div className="flex items-center gap-2">
                  <Clock className="h-4 w-4 text-gray-500" />
                  <div>
                    <p className="font-medium">Data e Horário</p>
                    <p className="text-sm text-gray-600">
                      {format(new Date(appointment.startTime), "EEEE, dd 'de' MMMM 'de' yyyy", { locale: ptBR })}
                    </p>
                    <p className="text-sm text-gray-600">
                      {format(new Date(appointment.startTime), "HH:mm", { locale: ptBR })} - {format(new Date(appointment.endTime), "HH:mm", { locale: ptBR })}
                    </p>
                  </div>
                </div>

                {appointment.location && (
                  <div className="flex items-center gap-2">
                    <MapPin className="h-4 w-4 text-gray-500" />
                    <div>
                      <p className="font-medium">Local</p>
                      <p className="text-sm text-gray-600">{appointment.location}</p>
                    </div>
                  </div>
                )}

                {appointment.value && appointment.value > 0 && (
                  <div className="flex items-center gap-2">
                    <DollarSign className="h-4 w-4 text-gray-500" />
                    <div>
                      <p className="font-medium">Valor</p>
                      <p className="text-sm text-gray-600">
                        R$ {appointment.value.toFixed(2).replace('.', ',')}
                      </p>
                    </div>
                  </div>
                )}
              </div>
            </CardContent>
          </Card>

          {/* Informações do Aluno */}
          {appointment.student && (
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <User className="h-5 w-5" />
                  Informações do Aluno
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-3">
                <div>
                  <p className="font-medium text-lg">{appointment.student.name}</p>
                </div>
                
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  {appointment.student.email && (
                    <div className="flex items-center gap-2">
                      <Mail className="h-4 w-4 text-gray-500" />
                      <span className="text-sm">{appointment.student.email}</span>
                    </div>
                  )}
                  {appointment.student.phone && (
                    <div className="flex items-center gap-2">
                      <Phone className="h-4 w-4 text-gray-500" />
                      <span className="text-sm">{appointment.student.phone}</span>
                    </div>
                  )}
                </div>

                {appointment.student.notes && (
                  <div>
                    <p className="font-medium text-sm mb-1">Observações do Aluno:</p>
                    <p className="text-sm text-gray-600 bg-gray-50 p-2 rounded">
                      {appointment.student.notes}
                    </p>
                  </div>
                )}
              </CardContent>
            </Card>
          )}

          {/* Informações do Professor */}
          {appointment.professor && (
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <User className="h-5 w-5" />
                  Informações do Professor
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-3">
                <div>
                  <p className="font-medium text-lg">
                    {appointment.professor.name || appointment.professor.username}
                  </p>
                  {appointment.professor.specialty && (
                    <p className="text-sm text-gray-600">{appointment.professor.specialty}</p>
                  )}
                </div>
                
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  {appointment.professor.email && (
                    <div className="flex items-center gap-2">
                      <Mail className="h-4 w-4 text-gray-500" />
                      <span className="text-sm">{appointment.professor.email}</span>
                    </div>
                  )}
                  {appointment.professor.hourlyRate && (
                    <div className="flex items-center gap-2">
                      <DollarSign className="h-4 w-4 text-gray-500" />
                      <span className="text-sm">R$ {appointment.professor.hourlyRate}/hora</span>
                    </div>
                  )}
                </div>

                {appointment.professor.bio && (
                  <div>
                    <p className="font-medium text-sm mb-1">Sobre o Professor:</p>
                    <p className="text-sm text-gray-600 bg-gray-50 p-2 rounded">
                      {appointment.professor.bio}
                    </p>
                  </div>
                )}
              </CardContent>
            </Card>
          )}

          {/* Observações do Agendamento */}
          {appointment.notes && (
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <FileText className="h-5 w-5" />
                  Observações
                </CardTitle>
              </CardHeader>
              <CardContent>
                <p className="text-sm text-gray-600 bg-gray-50 p-3 rounded">
                  {appointment.notes}
                </p>
              </CardContent>
            </Card>
          )}
        </div>

        <Separator />

        <DialogFooter className="flex justify-between">
          <div className="flex gap-2">
            <Button
              variant="outline"
              onClick={handleEdit}
              disabled={isDeleting}
            >
              <Edit3 className="h-4 w-4 mr-2" />
              Editar
            </Button>
            <Button
              variant="destructive"
              onClick={handleDelete}
              disabled={isDeleting}
            >
              <Trash2 className="h-4 w-4 mr-2" />
              {isDeleting ? "Deletando..." : "Deletar"}
            </Button>
          </div>
          <Button variant="outline" onClick={onClose}>
            Fechar
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="client/src/components/scheduling/AppointmentDialog.tsx">
import { useState, useEffect } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { useMutation, useQueryClient, useQuery } from "@tanstack/react-query";
import { z } from "zod";
import { Calendar, Clock, User, MapPin, DollarSign, FileText, AlertCircle } from "lucide-react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Badge } from "@/components/ui/badge";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { useToast } from "@/hooks/use-toast";
import type { IAula, IProfessor } from "@/types";

// Form validation schema
const aulaFormSchema = z.object({
  startTime: z.string().min(1, "Horário de início é obrigatório"),
  endTime: z.string().min(1, "Horário de término é obrigatório"),
  location: z.string().min(1, "Local é obrigatório"),
  value: z.number().min(1, "Valor deve ser maior que zero"),
  service: z.string().min(1, "Serviço é obrigatório"),
  notes: z.string().optional(),
  status: z.enum(["agendado", "em_andamento", "concluido", "cancelado", "remarcado"]),
});

type AulaFormData = z.infer<typeof aulaFormSchema>;

interface AppointmentDialogProps {
  aula?: IAula | null;
  open: boolean;
  onClose: () => void;
}

export function AppointmentDialog({ aula, open, onClose }: AppointmentDialogProps) {
  const { toast } = useToast();
  const queryClient = useQueryClient();

  const form = useForm<AulaFormData>({
    resolver: zodResolver(aulaFormSchema),
    defaultValues: {
      startTime: "",
      endTime: "",
      location: "",
      value: 0,
      service: "",
      notes: "",
      status: "agendado",
    },
  });

  // Fetch professors for display
  const { data: professors = [] } = useQuery({
    queryKey: ["/api/users/professors"],
    select: (data) => data as IProfessor[]
  });

  // Fetch leads for display
  const { data: leads = [] } = useQuery({
    queryKey: ["/api/leads"],
    select: (data: any) => data as any[]
  });

  // Reset form when aula changes
  useEffect(() => {
    if (aula && open) {
      const startTime = new Date(aula.startTime);
      const endTime = new Date(aula.endTime);
      
      form.reset({
        startTime: startTime.toISOString().slice(0, 16), // Format for datetime-local input
        endTime: endTime.toISOString().slice(0, 16),
        location: aula.location,
        value: aula.value / 100, // Convert from cents to reais
        service: aula.service,
        notes: aula.notes || "",
        status: aula.status,
      });
    }
  }, [aula, open, form]);

  // Update aula mutation
  const updateAulaMutation = useMutation({
    mutationFn: async (data: AulaFormData) => {
      const response = await fetch(`/api/new-scheduling/classes/${aula!.id}`, {
        method: "PATCH",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          startTime: new Date(data.startTime).toISOString(),
          endTime: new Date(data.endTime).toISOString(),
          location: data.location,
          value: Math.round(data.value * 100), // Convert to cents
          service: data.service,
          notes: data.notes,
          status: data.status,
        }),
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.message || "Erro ao atualizar aula");
      }
      
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/new-scheduling/classes"] });
      toast({
        title: "Aula atualizada",
        description: "Aula atualizada com sucesso",
      });
      onClose();
    },
    onError: (error: Error) => {
      toast({
        title: "Erro ao atualizar aula",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  const onSubmit = (data: AulaFormData) => {
    updateAulaMutation.mutate(data);
  };

  if (!aula) return null;

  const professor = professors.find(p => p.id === aula.professorId);
  const student = leads.find(l => l.id === aula.studentId);

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'agendado': return 'bg-blue-500';
      case 'em_andamento': return 'bg-amber-500';
      case 'concluido': return 'bg-green-500';
      case 'cancelado': return 'bg-red-500';
      case 'remarcado': return 'bg-purple-500';
      default: return 'bg-gray-500';
    }
  };

  const getStatusLabel = (status: string) => {
    switch (status) {
      case 'agendado': return 'Agendado';
      case 'em_andamento': return 'Em Andamento';
      case 'concluido': return 'Concluído';
      case 'cancelado': return 'Cancelado';
      case 'remarcado': return 'Remarcado';
      default: return status;
    }
  };

  return (
    <Dialog open={open} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-[600px] max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <Calendar className="h-5 w-5" />
            Detalhes da Aula
            <Badge className={`ml-2 ${getStatusColor(aula.status)} text-white`}>
              {getStatusLabel(aula.status)}
            </Badge>
          </DialogTitle>
        </DialogHeader>

        {/* Basic Information Display */}
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 p-4 bg-muted/30 rounded-lg">
          <div className="flex items-center gap-2">
            <User className="h-4 w-4 text-muted-foreground" />
            <div>
              <p className="text-sm font-medium">Professor</p>
              <p className="text-sm text-muted-foreground">
                {professor?.name || professor?.username || "Não encontrado"}
              </p>
            </div>
          </div>
          <div className="flex items-center gap-2">
            <User className="h-4 w-4 text-muted-foreground" />
            <div>
              <p className="text-sm font-medium">Aluno</p>
              <p className="text-sm text-muted-foreground">
                {student?.name || "Não encontrado"}
              </p>
            </div>
          </div>
        </div>

        {/* Conflict Warning */}
        {aula.isModified && (
          <div className="flex items-center gap-2 p-3 bg-amber-50 border border-amber-200 rounded-lg">
            <AlertCircle className="h-4 w-4 text-amber-600" />
            <div className="text-sm">
              <p className="font-medium text-amber-800">Aula Modificada</p>
              <p className="text-amber-700">
                Esta aula foi alterada em relação ao agendamento original.
              </p>
            </div>
          </div>
        )}

        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
            {/* Date and Time */}
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <FormField
                control={form.control}
                name="startTime"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel className="flex items-center gap-2">
                      <Clock className="h-4 w-4" />
                      Horário de Início
                    </FormLabel>
                    <FormControl>
                      <Input
                        {...field}
                        type="datetime-local"
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="endTime"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel className="flex items-center gap-2">
                      <Clock className="h-4 w-4" />
                      Horário de Término
                    </FormLabel>
                    <FormControl>
                      <Input
                        {...field}
                        type="datetime-local"
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
            </div>

            {/* Location and Service */}
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <FormField
                control={form.control}
                name="location"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel className="flex items-center gap-2">
                      <MapPin className="h-4 w-4" />
                      Local
                    </FormLabel>
                    <FormControl>
                      <Input {...field} placeholder="Digite o local da aula" />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="service"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Serviço</FormLabel>
                    <FormControl>
                      <Input {...field} placeholder="Digite o tipo de serviço" />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
            </div>

            {/* Value and Status */}
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <FormField
                control={form.control}
                name="value"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel className="flex items-center gap-2">
                      <DollarSign className="h-4 w-4" />
                      Valor (R$)
                    </FormLabel>
                    <FormControl>
                      <Input
                        {...field}
                        type="number"
                        step="0.01"
                        min="0"
                        placeholder="0.00"
                        onChange={(e) => field.onChange(parseFloat(e.target.value) || 0)}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="status"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Status</FormLabel>
                    <Select onValueChange={field.onChange} defaultValue={field.value}>
                      <FormControl>
                        <SelectTrigger>
                          <SelectValue placeholder="Selecione o status" />
                        </SelectTrigger>
                      </FormControl>
                      <SelectContent>
                        <SelectItem value="agendado">Agendado</SelectItem>
                        <SelectItem value="em_andamento">Em Andamento</SelectItem>
                        <SelectItem value="concluido">Concluído</SelectItem>
                        <SelectItem value="cancelado">Cancelado</SelectItem>
                        <SelectItem value="remarcado">Remarcado</SelectItem>
                      </SelectContent>
                    </Select>
                    <FormMessage />
                  </FormItem>
                )}
              />
            </div>

            {/* Notes */}
            <FormField
              control={form.control}
              name="notes"
              render={({ field }) => (
                <FormItem>
                  <FormLabel className="flex items-center gap-2">
                    <FileText className="h-4 w-4" />
                    Observações
                  </FormLabel>
                  <FormControl>
                    <Textarea
                      {...field}
                      placeholder="Digite observações sobre a aula..."
                      rows={3}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            {/* Buttons */}
            <div className="flex justify-end gap-3 pt-4">
              <Button
                type="button"
                variant="outline"
                onClick={onClose}
                disabled={updateAulaMutation.isPending}
              >
                Cancelar
              </Button>
              <Button type="submit" disabled={updateAulaMutation.isPending}>
                {updateAulaMutation.isPending ? "Salvando..." : "Salvar Alterações"}
              </Button>
            </div>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="client/src/components/scheduling/AppointmentsManagement.tsx">
import { useState, useMemo } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { format, parseISO } from "date-fns";
import { ptBR } from "date-fns/locale";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Input } from "@/components/ui/input";
import { Separator } from "@/components/ui/separator";
import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle, AlertDialogTrigger } from "@/components/ui/alert-dialog";
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from "@/components/ui/dropdown-menu";
import { Calendar, Clock, MapPin, User, MoreVertical, Trash2, Repeat, Filter, Search } from "lucide-react";
import { useToast } from "@/hooks/use-toast";

interface IAula {
  id: number;
  service: string;
  startTime: string;
  endTime: string;
  location: string;
  source: 'Favale' | 'Pink' | 'FavalePink';
  notes?: string;
  status: string;
  leadId: number;
  trainerId: number;
  value?: number;
  recurrenceType?: string;
  recurrenceGroupId?: string;
  isRecurrenceParent?: boolean;
  parentSessionId?: number;
  lead?: {
    id: number;
    name: string;
    phone: string;
    email?: string;
  };
  trainer?: {
    id: number;
    name: string;
    email?: string;
  };
}

interface Professor {
  id: number;
  username: string;
  role: string;
}

interface Lead {
  id: number;
  name: string;
  phone: string;
  email?: string;
  tags?: string[];
}

interface RecurringGroup {
  id: string;
  sessions: IAula[];
  pattern: string;
  studentName: string;
  trainerName: string;
  source: 'Favale' | 'Pink' | 'FavalePink';
  location: string;
  timeSlot: string;
  nextSession?: IAula;
  status: string;
}

interface AppointmentsManagementProps {
  onRefresh: () => void;
}

const STATUS_LABELS = {
  SCHEDULED: { label: "Agendada", color: "bg-blue-500", textColor: "text-white" },
  DESM_DIA: { label: "Desmarcada no dia", color: "bg-red-500", textColor: "text-white" },
  DESM_ANTEC: { label: "Desmarcada com antecedência", color: "bg-orange-500", textColor: "text-white" },
  DESM_MANUF: { label: "Desmarcada pelo professor/academia", color: "bg-purple-500", textColor: "text-white" },
  REP: { label: "Reposição", color: "bg-yellow-500", textColor: "text-black" },
  REP_DESM_DIA: { label: "Reposição desmarcada no dia", color: "bg-red-700", textColor: "text-white" },
  AULA_ADIC: { label: "Aula adicional", color: "bg-green-500", textColor: "text-white" },
  COMPLETED: { label: "Realizada", color: "bg-emerald-500", textColor: "text-white" },
  CANCELLED: { label: "Cancelada definitivamente", color: "bg-gray-500", textColor: "text-white" },
  agendado: { label: "Agendada", color: "bg-blue-500", textColor: "text-white" },
  em_andamento: { label: "Em andamento", color: "bg-blue-600", textColor: "text-white" },
  concluido: { label: "Concluída", color: "bg-green-500", textColor: "text-white" },
  cancelado: { label: "Cancelada", color: "bg-red-500", textColor: "text-white" },
  remarcado: { label: "Remarcada", color: "bg-orange-500", textColor: "text-white" }
};

const AppointmentsManagement = ({ onRefresh }: AppointmentsManagementProps) => {
  const [filterProfessor, setFilterProfessor] = useState<string>("all");
  const [filterStudent, setFilterStudent] = useState<string>("all");
  const [filterStatus, setFilterStatus] = useState<string>("all");
  const [searchTerm, setSearchTerm] = useState<string>("");
  const [viewMode, setViewMode] = useState<"individual" | "grouped">("grouped");

  const { toast } = useToast();
  const queryClient = useQueryClient();

  // Fetch appointments
  const { data: appointments = [], isLoading, refetch } = useQuery<IAula[]>({
    queryKey: ['/api/appointments'],
  });

  // Fetch professors
  const { data: professors = [] } = useQuery<Professor[]>({
    queryKey: ['/api/users/professors'],
  });

  // Fetch students (leads with "Alunos" tag)
  const { data: allLeads = [] } = useQuery<Lead[]>({
    queryKey: ['/api/leads'],
  });

  const students = allLeads.filter(lead => 
    lead.tags?.includes("Alunos")
  );

  // Delete recurring group mutation
  const deleteRecurringGroupMutation = useMutation({
    mutationFn: async (groupId: string) => {
      const response = await fetch(`/api/appointments/recurring/${groupId}`, {
        method: 'DELETE',
      });
      if (!response.ok) {
        throw new Error('Erro ao excluir recorrência');
      }
      return response.json();
    },
    onSuccess: () => {
      toast({
        title: "Sucesso",
        description: "Recorrência excluída com sucesso",
      });
      refetch();
      onRefresh();
    },
    onError: () => {
      toast({
        title: "Erro",
        description: "Erro ao excluir recorrência",
        variant: "destructive",
      });
    },
  });

  // Update appointment status mutation
  const updateStatusMutation = useMutation({
    mutationFn: async ({ id, status }: { id: number; status: string }) => {
      const response = await fetch(`/api/appointments/${id}/status`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ status }),
      });
      if (!response.ok) {
        throw new Error('Erro ao atualizar status');
      }
      return response.json();
    },
    onSuccess: () => {
      toast({
        title: "Sucesso",
        description: "Status atualizado com sucesso",
      });
      refetch();
      onRefresh();
    },
    onError: () => {
      toast({
        title: "Erro",
        description: "Erro ao atualizar status",
        variant: "destructive",
      });
    },
  });

  // Group appointments by recurrence
  const recurringGroups = useMemo(() => {
    const groups: { [key: string]: RecurringGroup } = {};
    
    appointments.forEach(appointment => {
      if (appointment.recurrenceGroupId) {
        const groupId = appointment.recurrenceGroupId;
        if (!groups[groupId]) {
          groups[groupId] = {
            id: groupId,
            sessions: [],
            pattern: appointment.recurrenceType || 'Recorrente',
            studentName: appointment.lead?.name || 'N/A',
            trainerName: appointment.trainer?.name || 'N/A',
            source: appointment.source,
            location: appointment.location,
            timeSlot: `${format(parseISO(appointment.startTime), 'HH:mm')} - ${format(parseISO(appointment.endTime), 'HH:mm')}`,
            status: appointment.status,
          };
        }
        groups[groupId].sessions.push(appointment);
        
        // Find next session
        const now = new Date();
        const futureSessions = groups[groupId].sessions
          .filter(s => parseISO(s.startTime) > now)
          .sort((a, b) => parseISO(a.startTime).getTime() - parseISO(b.startTime).getTime());
        
        if (futureSessions.length > 0) {
          groups[groupId].nextSession = futureSessions[0];
        }
      }
    });
    
    return Object.values(groups);
  }, [appointments]);

  // Filter appointments
  const filteredAppointments = useMemo(() => {
    return appointments.filter(appointment => {
      const matchesProfessor = !filterProfessor || filterProfessor === 'all' || appointment.trainerId.toString() === filterProfessor;
      const matchesStudent = !filterStudent || filterStudent === 'all' || appointment.leadId.toString() === filterStudent;
      const matchesStatus = !filterStatus || filterStatus === 'all' || appointment.status === filterStatus;
      const matchesSearch = !searchTerm || 
        appointment.lead?.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
        appointment.trainer?.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
        appointment.service.toLowerCase().includes(searchTerm.toLowerCase());
      
      return matchesProfessor && matchesStudent && matchesStatus && matchesSearch;
    });
  }, [appointments, filterProfessor, filterStudent, filterStatus, searchTerm]);

  // Filter recurring groups
  const filteredRecurringGroups = useMemo(() => {
    return recurringGroups.filter(group => {
      const matchesProfessor = !filterProfessor || filterProfessor === 'all' || group.sessions.some(s => s.trainerId.toString() === filterProfessor);
      const matchesStudent = !filterStudent || filterStudent === 'all' || group.sessions.some(s => s.leadId.toString() === filterStudent);
      const matchesStatus = !filterStatus || filterStatus === 'all' || group.status === filterStatus;
      const matchesSearch = !searchTerm || 
        group.studentName.toLowerCase().includes(searchTerm.toLowerCase()) ||
        group.trainerName.toLowerCase().includes(searchTerm.toLowerCase());
      
      return matchesProfessor && matchesStudent && matchesStatus && matchesSearch;
    });
  }, [recurringGroups, filterProfessor, filterStudent, filterStatus, searchTerm]);

  const getSourceColor = (source: string) => {
    switch (source) {
      case 'Favale':
        return 'bg-blue-100 text-blue-800';
      case 'Pink':
        return 'bg-pink-100 text-pink-800';
      case 'FavalePink':
        return 'bg-purple-100 text-purple-800';
      default:
        return 'bg-gray-100 text-gray-800';
    }
  };

  // Statistics calculation
  const statistics = useMemo(() => {
    const total = appointments.length;
    const recurring = appointments.filter(a => a.recurrenceGroupId).length;
    const individual = total - recurring;
    const scheduled = appointments.filter(a => a.status === 'agendado' || a.status === 'SCHEDULED').length;
    const completed = appointments.filter(a => a.status === 'concluido' || a.status === 'COMPLETED').length;
    const cancelled = appointments.filter(a => a.status === 'cancelado' || a.status === 'CANCELLED').length;
    
    return { total, recurring, individual, scheduled, completed, cancelled };
  }, [appointments]);

  if (isLoading) {
    return <div>Carregando agendamentos...</div>;
  }

  return (
    <div className="space-y-6">
      {/* Statistics */}
      <div className="grid grid-cols-2 md:grid-cols-6 gap-4">
        <Card>
          <CardContent className="pt-4">
            <div className="text-center">
              <div className="text-2xl font-bold text-gray-900">{statistics.total}</div>
              <div className="text-sm text-gray-600">Total</div>
            </div>
          </CardContent>
        </Card>
        <Card>
          <CardContent className="pt-4">
            <div className="text-center">
              <div className="text-2xl font-bold text-blue-600">{statistics.scheduled}</div>
              <div className="text-sm text-gray-600">Agendadas</div>
            </div>
          </CardContent>
        </Card>
        <Card>
          <CardContent className="pt-4">
            <div className="text-center">
              <div className="text-2xl font-bold text-green-600">{statistics.completed}</div>
              <div className="text-sm text-gray-600">Realizadas</div>
            </div>
          </CardContent>
        </Card>
        <Card>
          <CardContent className="pt-4">
            <div className="text-center">
              <div className="text-2xl font-bold text-red-600">{statistics.cancelled}</div>
              <div className="text-sm text-gray-600">Canceladas</div>
            </div>
          </CardContent>
        </Card>
        <Card>
          <CardContent className="pt-4">
            <div className="text-center">
              <div className="text-2xl font-bold text-purple-600">{statistics.recurring}</div>
              <div className="text-sm text-gray-600">Recorrentes</div>
            </div>
          </CardContent>
        </Card>
        <Card>
          <CardContent className="pt-4">
            <div className="text-center">
              <div className="text-2xl font-bold text-orange-600">{statistics.individual}</div>
              <div className="text-sm text-gray-600">Individuais</div>
            </div>
          </CardContent>
        </Card>
      </div>

      {/* Filters */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Filter className="h-5 w-5" />
            Filtros
          </CardTitle>
        </CardHeader>
        <CardContent>
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-4">
            <div className="space-y-2">
              <label className="text-sm font-medium">Buscar</label>
              <div className="relative">
                <Search className="h-4 w-4 absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400" />
                <Input
                  placeholder="Nome, professor, serviço..."
                  value={searchTerm}
                  onChange={(e) => setSearchTerm(e.target.value)}
                  className="pl-10"
                />
              </div>
            </div>
            
            <div className="space-y-2">
              <label className="text-sm font-medium">Professor</label>
              <Select value={filterProfessor} onValueChange={setFilterProfessor}>
                <SelectTrigger>
                  <SelectValue placeholder="Todos os professores" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="all">Todos os professores</SelectItem>
                  {professors.map((professor) => (
                    <SelectItem key={professor.id} value={professor.id.toString()}>
                      {professor.username}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
            
            <div className="space-y-2">
              <label className="text-sm font-medium">Aluno</label>
              <Select value={filterStudent} onValueChange={setFilterStudent}>
                <SelectTrigger>
                  <SelectValue placeholder="Todos os alunos" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="all">Todos os alunos</SelectItem>
                  {students.map((student) => (
                    <SelectItem key={student.id} value={student.id.toString()}>
                      {student.name}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
            
            <div className="space-y-2">
              <label className="text-sm font-medium">Status</label>
              <Select value={filterStatus} onValueChange={setFilterStatus}>
                <SelectTrigger>
                  <SelectValue placeholder="Todos os status" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="all">Todos os status</SelectItem>
                  {Object.entries(STATUS_LABELS).map(([key, value]) => (
                    <SelectItem key={key} value={key}>
                      {value.label}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
            
            <div className="space-y-2">
              <label className="text-sm font-medium">Visualização</label>
              <Select value={viewMode} onValueChange={(value: "individual" | "grouped") => setViewMode(value)}>
                <SelectTrigger>
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="grouped">Agrupado por Recorrência</SelectItem>
                  <SelectItem value="individual">Individual</SelectItem>
                </SelectContent>
              </Select>
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Appointments List */}
      <div className="space-y-4">
        {viewMode === "grouped" ? (
          // Grouped view
          <>
            {filteredRecurringGroups.length > 0 && (
              <div className="space-y-4">
                <h3 className="text-lg font-semibold">Serviços Recorrentes</h3>
                {filteredRecurringGroups.map((group) => (
                  <Card key={group.id}>
                    <CardHeader>
                      <div className="flex items-center justify-between">
                        <div className="flex items-center gap-3">
                          <Repeat className="h-5 w-5 text-blue-500" />
                          <div>
                            <CardTitle className="text-lg">{group.pattern}</CardTitle>
                            <p className="text-sm text-gray-600">
                              {group.studentName} • {group.trainerName}
                            </p>
                          </div>
                        </div>
                        <div className="flex items-center gap-2">
                          <Badge className={getSourceColor(group.source)}>
                            {group.source}
                          </Badge>
                          <Badge className={`${STATUS_LABELS[group.status as keyof typeof STATUS_LABELS]?.color || "bg-gray-500"} ${STATUS_LABELS[group.status as keyof typeof STATUS_LABELS]?.textColor || "text-white"}`}>
                            {STATUS_LABELS[group.status as keyof typeof STATUS_LABELS]?.label || group.status}
                          </Badge>
                          <AlertDialog>
                            <AlertDialogTrigger asChild>
                              <Button variant="outline" size="sm">
                                <Trash2 className="h-4 w-4" />
                              </Button>
                            </AlertDialogTrigger>
                            <AlertDialogContent>
                              <AlertDialogHeader>
                                <AlertDialogTitle>Excluir Recorrência</AlertDialogTitle>
                                <AlertDialogDescription>
                                  Tem certeza que deseja excluir esta recorrência? Todas as aulas agendadas desta recorrência serão removidas. Esta ação não pode ser desfeita.
                                </AlertDialogDescription>
                              </AlertDialogHeader>
                              <AlertDialogFooter>
                                <AlertDialogCancel>Cancelar</AlertDialogCancel>
                                <AlertDialogAction
                                  onClick={() => deleteRecurringGroupMutation.mutate(group.id)}
                                  className="bg-red-500 hover:bg-red-600"
                                >
                                  Excluir
                                </AlertDialogAction>
                              </AlertDialogFooter>
                            </AlertDialogContent>
                          </AlertDialog>
                        </div>
                      </div>
                    </CardHeader>
                    <CardContent>
                      <div className="grid grid-cols-1 md:grid-cols-3 gap-4 text-sm mb-4">
                        <div className="flex items-center gap-2">
                          <Clock className="h-4 w-4 text-gray-500" />
                          <span>{group.timeSlot}</span>
                        </div>
                        <div className="flex items-center gap-2">
                          <MapPin className="h-4 w-4 text-gray-500" />
                          <span>{group.location}</span>
                        </div>
                        <div className="flex items-center gap-2">
                          <Calendar className="h-4 w-4 text-gray-500" />
                          <span>{group.sessions.length} aulas agendadas</span>
                        </div>
                      </div>
                      
                      {/* Status breakdown for this group */}
                      <div className="mb-4">
                        <p className="text-sm font-medium mb-2">Status das aulas:</p>
                        <div className="flex flex-wrap gap-2">
                          {Object.entries(
                            group.sessions.reduce((acc, session) => {
                              acc[session.status] = (acc[session.status] || 0) + 1;
                              return acc;
                            }, {} as Record<string, number>)
                          ).map(([status, count]) => (
                            <div key={status} className="flex items-center gap-1">
                              <Badge className={`${STATUS_LABELS[status as keyof typeof STATUS_LABELS]?.color || "bg-gray-500"} ${STATUS_LABELS[status as keyof typeof STATUS_LABELS]?.textColor || "text-white"} text-xs`}>
                                {STATUS_LABELS[status as keyof typeof STATUS_LABELS]?.label || status}
                              </Badge>
                              <span className="text-xs text-gray-600">({count})</span>
                            </div>
                          ))}
                        </div>
                      </div>
                      {group.nextSession && (
                        <div className="mt-3 pt-3 border-t">
                          <p className="text-sm font-medium">Próxima aula:</p>
                          <p className="text-sm text-gray-600">
                            {format(parseISO(group.nextSession.startTime), "dd/MM/yyyy 'às' HH:mm", { locale: ptBR })}
                          </p>
                        </div>
                      )}
                    </CardContent>
                  </Card>
                ))}
              </div>
            )}
            
            {/* Individual appointments (non-recurring) */}
            {filteredAppointments.filter(a => !a.recurrenceGroupId).length > 0 && (
              <div className="space-y-4">
                <Separator />
                <h3 className="text-lg font-semibold">Aulas Individuais</h3>
                {filteredAppointments
                  .filter(appointment => !appointment.recurrenceGroupId)
                  .map((appointment) => (
                    <Card key={appointment.id}>
                      <CardContent className="pt-4">
                        <div className="flex items-center justify-between">
                          <div className="flex items-center gap-3">
                            <User className="h-5 w-5 text-gray-500" />
                            <div>
                              <h4 className="font-medium">{appointment.service}</h4>
                              <p className="text-sm text-gray-600">
                                {appointment.lead?.name} • {appointment.trainer?.name}
                              </p>
                              <p className="text-sm text-gray-500">
                                {format(parseISO(appointment.startTime), "dd/MM/yyyy 'às' HH:mm", { locale: ptBR })}
                              </p>
                            </div>
                          </div>
                          <div className="flex items-center gap-2">
                            <Badge className={getSourceColor(appointment.source)}>
                              {appointment.source}
                            </Badge>
                            <DropdownMenu>
                              <DropdownMenuTrigger asChild>
                                <Button variant="outline" size="sm">
                                  <Badge className={STATUS_LABELS[appointment.status as keyof typeof STATUS_LABELS]?.color || "bg-gray-500"}>
                                    {STATUS_LABELS[appointment.status as keyof typeof STATUS_LABELS]?.label || appointment.status}
                                  </Badge>
                                  <MoreVertical className="h-4 w-4 ml-2" />
                                </Button>
                              </DropdownMenuTrigger>
                              <DropdownMenuContent>
                                {Object.entries(STATUS_LABELS).map(([key, value]) => (
                                  <DropdownMenuItem
                                    key={key}
                                    onClick={() => updateStatusMutation.mutate({ id: appointment.id, status: key })}
                                  >
                                    {value.label}
                                  </DropdownMenuItem>
                                ))}
                              </DropdownMenuContent>
                            </DropdownMenu>
                          </div>
                        </div>
                      </CardContent>
                    </Card>
                  ))}
              </div>
            )}
          </>
        ) : (
          // Individual view
          <div className="space-y-4">
            <h3 className="text-lg font-semibold">Todos os Agendamentos</h3>
            {filteredAppointments.map((appointment) => (
              <Card key={appointment.id}>
                <CardContent className="pt-4">
                  <div className="flex items-center justify-between">
                    <div className="flex items-center gap-3">
                      {appointment.recurrenceGroupId ? (
                        <Repeat className="h-5 w-5 text-blue-500" />
                      ) : (
                        <User className="h-5 w-5 text-gray-500" />
                      )}
                      <div>
                        <h4 className="font-medium">{appointment.service}</h4>
                        <p className="text-sm text-gray-600">
                          {appointment.lead?.name} • {appointment.trainer?.name}
                        </p>
                        <p className="text-sm text-gray-500">
                          {format(parseISO(appointment.startTime), "dd/MM/yyyy 'às' HH:mm", { locale: ptBR })} • {appointment.location}
                        </p>
                        {appointment.recurrenceGroupId && (
                          <p className="text-xs text-blue-600">Parte de serviço recorrente</p>
                        )}
                      </div>
                    </div>
                    <div className="flex items-center gap-2">
                      <Badge className={getSourceColor(appointment.source)}>
                        {appointment.source}
                      </Badge>
                      <DropdownMenu>
                        <DropdownMenuTrigger asChild>
                          <Button variant="outline" size="sm">
                            <Badge className={`${STATUS_LABELS[appointment.status as keyof typeof STATUS_LABELS]?.color || "bg-gray-500"} ${STATUS_LABELS[appointment.status as keyof typeof STATUS_LABELS]?.textColor || "text-white"}`}>
                              {STATUS_LABELS[appointment.status as keyof typeof STATUS_LABELS]?.label || appointment.status}
                            </Badge>
                            <MoreVertical className="h-4 w-4 ml-2" />
                          </Button>
                        </DropdownMenuTrigger>
                        <DropdownMenuContent>
                          {Object.entries(STATUS_LABELS).map(([key, value]) => (
                            <DropdownMenuItem
                              key={key}
                              onClick={() => updateStatusMutation.mutate({ id: appointment.id, status: key })}
                            >
                              {value.label}
                            </DropdownMenuItem>
                          ))}
                        </DropdownMenuContent>
                      </DropdownMenu>
                    </div>
                  </div>
                </CardContent>
              </Card>
            ))}
          </div>
        )}
        
        {filteredAppointments.length === 0 && filteredRecurringGroups.length === 0 && (
          <Card>
            <CardContent className="pt-6">
              <div className="text-center py-8">
                <Calendar className="h-12 w-12 text-gray-400 mx-auto mb-4" />
                <h3 className="text-lg font-medium text-gray-900 mb-2">Nenhum agendamento encontrado</h3>
                <p className="text-gray-500">Ajuste os filtros ou crie um novo agendamento.</p>
              </div>
            </CardContent>
          </Card>
        )}

        {/* Status Legend */}
        <Card>
          <CardHeader>
            <CardTitle>Legenda de Status</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-3">
              {Object.entries(STATUS_LABELS).map(([key, value]) => (
                <div key={key} className="flex items-center gap-2">
                  <Badge className={`${value.color} ${value.textColor} text-xs`}>
                    {key}
                  </Badge>
                  <span className="text-sm text-gray-600">{value.label}</span>
                </div>
              ))}
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  );
};

export default AppointmentsManagement;
</file>

<file path="client/src/components/scheduling/MultiDateAppointmentDialog.tsx">
import { useState, useEffect } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { Calendar } from "@/components/ui/calendar";
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { apiRequest } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import { format, addDays, differenceInDays } from "date-fns";
import { ptBR } from "date-fns/locale";
import { CalendarIcon, Clock, Users, DollarSign, MapPin } from "lucide-react";
import { Badge } from "@/components/ui/badge";
import { Separator } from "@/components/ui/separator";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";

// Schema for the appointment form
const appointmentSchema = z.object({
  professorId: z.number().min(1, "Selecione um professor"),
  studentId: z.number().min(1, "Selecione um aluno"),
  startTime: z.string().min(1, "Horário é obrigatório"),
  endTime: z.string().min(1, "Horário de fim é obrigatório"),
  location: z.string().min(1, "Local é obrigatório"),
  value: z.number().min(0, "Valor deve ser positivo"),
  service: z.string().min(1, "Serviço é obrigatório"),
  notes: z.string().optional(),
  isRecurring: z.boolean().default(false),
  recurrenceType: z.enum(["weekly", "daily"]).optional(),
  recurrenceInterval: z.number().min(1).default(1).optional(),
});

type AppointmentFormData = z.infer<typeof appointmentSchema>;

interface MultiDateAppointmentDialogProps {
  isOpen: boolean;
  onClose: () => void;
  selectedDate?: Date;
  onSuccess: () => void;
}

export default function MultiDateAppointmentDialog({
  isOpen,
  onClose,
  selectedDate,
  onSuccess,
}: MultiDateAppointmentDialogProps) {
  const [selectedDates, setSelectedDates] = useState<Date[]>([]);
  const [showRecurrenceOptions, setShowRecurrenceOptions] = useState(false);
  const { toast } = useToast();
  const queryClient = useQueryClient();

  // Fetch professors
  const { data: professors = [] } = useQuery({
    queryKey: ["/api/users/professors"],
    enabled: isOpen,
  });

  // Fetch leads/students
  const { data: leads = [] } = useQuery({
    queryKey: ["/api/leads"],
    enabled: isOpen,
  });

  // Filter only students from leads
  const students = Array.isArray(leads) ? leads.filter((lead: any) => lead.status === "Aluno") : [];

  const form = useForm<AppointmentFormData>({
    resolver: zodResolver(appointmentSchema),
    defaultValues: {
      professorId: 0,
      studentId: 0,
      startTime: "09:00",
      endTime: "10:00",
      location: "",
      value: 0,
      service: "",
      notes: "",
      isRecurring: false,
      recurrenceType: "weekly",
      recurrenceInterval: 1,
    },
  });

  // Create appointment mutation
  const createAppointmentMutation = useMutation({
    mutationFn: async (data: any) => {
      if (selectedDates.length === 1 || !data.isRecurring) {
        // Single appointment
        const appointmentData = {
          ...data,
          startTime: `${format(selectedDates[0], "yyyy-MM-dd")} ${data.startTime}:00`,
          endTime: `${format(selectedDates[0], "yyyy-MM-dd")} ${data.endTime}:00`,
        };
        return fetch("/api/appointments", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(appointmentData),
        }).then(res => res.json());
      } else {
        // Multiple appointments or recurring
        const appointments = selectedDates.map(date => ({
          ...data,
          startTime: `${format(date, "yyyy-MM-dd")} ${data.startTime}:00`,
          endTime: `${format(date, "yyyy-MM-dd")} ${data.endTime}:00`,
        }));

        // Create batch appointments
        return Promise.all(
          appointments.map(appointment =>
            fetch("/api/appointments", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(appointment),
            }).then(res => res.json())
          )
        );
      }
    },
    onSuccess: () => {
      toast({
        title: "Sucesso!",
        description: `${selectedDates.length > 1 ? 'Agendamentos criados' : 'Agendamento criado'} com sucesso.`,
      });
      queryClient.invalidateQueries({ queryKey: ["/api/appointments"] });
      queryClient.invalidateQueries({ queryKey: ["/api/aulas"] });
      onSuccess();
      handleClose();
    },
    onError: (error: any) => {
      console.error("Erro ao criar agendamento:", error);
      toast({
        title: "Erro",
        description: "Falha ao criar agendamento. Tente novamente.",
        variant: "destructive",
      });
    },
  });

  // Initialize with selected date
  useEffect(() => {
    if (selectedDate && isOpen) {
      setSelectedDates([selectedDate]);
      setShowRecurrenceOptions(false);
    }
  }, [selectedDate, isOpen]);

  // Check if should show recurrence options
  useEffect(() => {
    if (selectedDates.length > 1) {
      setShowRecurrenceOptions(true);
      form.setValue("isRecurring", true);
    } else {
      setShowRecurrenceOptions(false);
      form.setValue("isRecurring", false);
    }
  }, [selectedDates, form]);

  const handleClose = () => {
    form.reset();
    setSelectedDates([]);
    setShowRecurrenceOptions(false);
    onClose();
  };

  const handleDateSelect = (date: Date | undefined) => {
    if (!date) return;

    setSelectedDates(prev => {
      const isAlreadySelected = prev.some(d => 
        format(d, "yyyy-MM-dd") === format(date, "yyyy-MM-dd")
      );

      if (isAlreadySelected) {
        // Remove date if already selected
        return prev.filter(d => 
          format(d, "yyyy-MM-dd") !== format(date, "yyyy-MM-dd")
        );
      } else {
        // Add date
        return [...prev, date].sort((a, b) => a.getTime() - b.getTime());
      }
    });
  };

  const onSubmit = (data: AppointmentFormData) => {
    if (selectedDates.length === 0) {
      toast({
        title: "Erro",
        description: "Selecione pelo menos uma data no calendário.",
        variant: "destructive",
      });
      return;
    }

    createAppointmentMutation.mutate(data);
  };

  const getRecurrenceDescription = () => {
    if (selectedDates.length <= 1) return "";
    
    const sortedDates = [...selectedDates].sort((a, b) => a.getTime() - b.getTime());
    const firstDate = sortedDates[0];
    const lastDate = sortedDates[sortedDates.length - 1];
    const daysDiff = differenceInDays(lastDate, firstDate);
    
    if (selectedDates.length === 2) {
      const interval = differenceInDays(sortedDates[1], sortedDates[0]);
      if (interval === 7) {
        return "Agendamento semanal";
      } else if (interval === 1) {
        return "Agendamento em dias consecutivos";
      } else {
        return `Agendamento com intervalo de ${interval} dias`;
      }
    }
    
    return `${selectedDates.length} agendamentos selecionados (${format(firstDate, "dd/MM", { locale: ptBR })} - ${format(lastDate, "dd/MM", { locale: ptBR })})`;
  };

  return (
    <Dialog open={isOpen} onOpenChange={handleClose}>
      <DialogContent className="max-w-4xl max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <CalendarIcon className="h-5 w-5" />
            Novo Agendamento
          </DialogTitle>
        </DialogHeader>

        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
          {/* Calendar Section */}
          <div className="space-y-4">
            <div>
              <h3 className="text-lg font-semibold mb-2">Selecione as Datas</h3>
              <p className="text-sm text-muted-foreground mb-4">
                Clique nas datas desejadas. Para múltiplas datas, clique em cada uma.
              </p>
              <Calendar
                mode="multiple"
                selected={selectedDates}
                onSelect={(dates) => {
                  if (dates) {
                    setSelectedDates(Array.isArray(dates) ? dates : [dates]);
                  }
                }}
                className="rounded-md border"
                locale={ptBR}
                disabled={(date) => date < new Date()}
              />
            </div>

            {/* Selected Dates Display */}
            {selectedDates.length > 0 && (
              <Card>
                <CardHeader className="pb-3">
                  <CardTitle className="text-base">Datas Selecionadas</CardTitle>
                  {showRecurrenceOptions && (
                    <CardDescription>{getRecurrenceDescription()}</CardDescription>
                  )}
                </CardHeader>
                <CardContent>
                  <div className="flex flex-wrap gap-2">
                    {selectedDates.map((date, index) => (
                      <Badge key={index} variant="secondary" className="text-xs">
                        {format(date, "dd/MM/yyyy", { locale: ptBR })}
                        <button
                          onClick={() => handleDateSelect(date)}
                          className="ml-2 hover:text-destructive"
                        >
                          ×
                        </button>
                      </Badge>
                    ))}
                  </div>
                </CardContent>
              </Card>
            )}
          </div>

          {/* Form Section */}
          <div className="space-y-4">
            <Form {...form}>
              <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
                {/* Professor Selection */}
                <FormField
                  control={form.control}
                  name="professorId"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel className="flex items-center gap-2">
                        <Users className="h-4 w-4" />
                        Professor
                      </FormLabel>
                      <Select onValueChange={(value) => field.onChange(Number(value))}>
                        <FormControl>
                          <SelectTrigger>
                            <SelectValue placeholder="Selecione um professor" />
                          </SelectTrigger>
                        </FormControl>
                        <SelectContent>
                          {Array.isArray(professors) ? professors.map((professor: any) => (
                            <SelectItem key={professor.id} value={professor.id.toString()}>
                              {professor.name} - {professor.specialty}
                            </SelectItem>
                          )) : []}
                        </SelectContent>
                      </Select>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                {/* Student Selection */}
                <FormField
                  control={form.control}
                  name="studentId"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel className="flex items-center gap-2">
                        <Users className="h-4 w-4" />
                        Aluno
                      </FormLabel>
                      <Select onValueChange={(value) => field.onChange(Number(value))}>
                        <FormControl>
                          <SelectTrigger>
                            <SelectValue placeholder="Selecione um aluno" />
                          </SelectTrigger>
                        </FormControl>
                        <SelectContent>
                          {students.map((student: any) => (
                            <SelectItem key={student.id} value={student.id.toString()}>
                              {student.name}
                            </SelectItem>
                          ))}
                        </SelectContent>
                      </Select>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                {/* Time Selection */}
                <div className="grid grid-cols-2 gap-4">
                  <FormField
                    control={form.control}
                    name="startTime"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel className="flex items-center gap-2">
                          <Clock className="h-4 w-4" />
                          Início
                        </FormLabel>
                        <FormControl>
                          <Input type="time" {...field} />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="endTime"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Fim</FormLabel>
                        <FormControl>
                          <Input type="time" {...field} />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                </div>

                {/* Location and Value */}
                <div className="grid grid-cols-2 gap-4">
                  <FormField
                    control={form.control}
                    name="location"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel className="flex items-center gap-2">
                          <MapPin className="h-4 w-4" />
                          Local
                        </FormLabel>
                        <FormControl>
                          <Input placeholder="Ex: Academia Favale" {...field} />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="value"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel className="flex items-center gap-2">
                          <DollarSign className="h-4 w-4" />
                          Valor (R$)
                        </FormLabel>
                        <FormControl>
                          <Input
                            type="number"
                            step="0.01"
                            min="0"
                            placeholder="0.00"
                            {...field}
                            onChange={(e) => field.onChange(Number(e.target.value))}
                          />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                </div>

                {/* Service */}
                <FormField
                  control={form.control}
                  name="service"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Serviço</FormLabel>
                      <FormControl>
                        <Input placeholder="Ex: Personal Training" {...field} />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                {/* Notes */}
                <FormField
                  control={form.control}
                  name="notes"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Observações</FormLabel>
                      <FormControl>
                        <Textarea
                          placeholder="Observações adicionais..."
                          className="min-h-[80px]"
                          {...field}
                        />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <Separator />

                {/* Action Buttons */}
                <div className="flex justify-end gap-2 pt-4">
                  <Button type="button" variant="outline" onClick={handleClose}>
                    Cancelar
                  </Button>
                  <Button
                    type="submit"
                    disabled={createAppointmentMutation.isPending || selectedDates.length === 0}
                  >
                    {createAppointmentMutation.isPending ? "Criando..." : 
                      selectedDates.length > 1 ? `Criar ${selectedDates.length} Agendamentos` : "Criar Agendamento"
                    }
                  </Button>
                </div>
              </form>
            </Form>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="client/src/components/scheduling/NewRecurrenceForm.tsx">
import { useState, useEffect } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { useMutation, useQueryClient, useQuery } from "@tanstack/react-query";
import { z } from "zod";
import { Plus, Calendar, Clock, User, MapPin, DollarSign, Repeat, X } from "lucide-react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Checkbox } from "@/components/ui/checkbox";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { useToast } from "@/hooks/use-toast";
import type { IProfessor, INewRecurrenceForm, IRegraRecorrencia } from "@/types";

// Form validation schema
const recurrenceFormSchema = z.object({
  professorId: z.number().min(1, "Professor é obrigatório"),
  studentId: z.number().min(1, "Aluno é obrigatório"),
  location: z.string().min(1, "Local é obrigatório"),
  value: z.number().min(1, "Valor deve ser maior que zero"),
  service: z.string().min(1, "Serviço é obrigatório"),
  notes: z.string().optional(),
  startDate: z.string().min(1, "Data de início é obrigatória"),
  startTime: z.string().min(1, "Horário de início é obrigatório"),
  endTime: z.string().min(1, "Horário de término é obrigatório"),
  recurrence: z.object({
    type: z.enum(["daily", "weekly", "monthly", "yearly", "custom"]),
    interval: z.number().min(1, "Intervalo deve ser pelo menos 1"),
    weekDays: z.array(z.string()).optional(),
    monthDay: z.number().optional(),
    endType: z.enum(["never", "date", "count"]),
    endDate: z.string().optional(),
    endCount: z.number().optional(),
  }),
});

type RecurrenceFormData = z.infer<typeof recurrenceFormSchema>;

interface NewRecurrenceFormProps {
  open: boolean;
  onClose: () => void;
}

const weekDayOptions = [
  { value: "monday", label: "Segunda-feira" },
  { value: "tuesday", label: "Terça-feira" },
  { value: "wednesday", label: "Quarta-feira" },
  { value: "thursday", label: "Quinta-feira" },
  { value: "friday", label: "Sexta-feira" },
  { value: "saturday", label: "Sábado" },
  { value: "sunday", label: "Domingo" },
];

export function NewRecurrenceForm({ open, onClose }: NewRecurrenceFormProps) {
  const { toast } = useToast();
  const queryClient = useQueryClient();

  const form = useForm<RecurrenceFormData>({
    resolver: zodResolver(recurrenceFormSchema),
    defaultValues: {
      professorId: 0,
      studentId: 0,
      location: "",
      value: 0,
      service: "",
      notes: "",
      startDate: "",
      startTime: "09:00",
      endTime: "10:00",
      recurrence: {
        type: "weekly",
        interval: 1,
        weekDays: [],
        endType: "never",
      },
    },
  });

  // Fetch professors
  const { data: professors = [] } = useQuery({
    queryKey: ["/api/users/professors"],
    select: (data) => data as IProfessor[]
  });

  // Fetch leads (students)
  const { data: leads = [] } = useQuery({
    queryKey: ["/api/leads"],
    select: (data: any) => data as any[]
  });

  // Filter only students (leads with status "Aluno")
  const students = leads.filter((lead: any) => lead.status === "Aluno");

  // Create recurrence mutation
  const createRecurrenceMutation = useMutation({
    mutationFn: async (data: RecurrenceFormData) => {
      // Combine date and time for start and end
      const startDateTime = new Date(`${data.startDate}T${data.startTime}`);
      const endDateTime = new Date(`${data.startDate}T${data.endTime}`);

      const payload = {
        professorId: data.professorId,
        studentId: data.studentId,
        location: data.location,
        value: Math.round(data.value * 100), // Convert to cents
        service: data.service,
        notes: data.notes,
        regras: data.recurrence,
        startDate: startDateTime.toISOString(),
        endDate: data.recurrence.endType === "date" && data.recurrence.endDate
          ? new Date(data.recurrence.endDate).toISOString()
          : undefined,
        maxOccurrences: data.recurrence.endType === "count"
          ? data.recurrence.endCount
          : undefined,
        active: true,
      };

      const response = await fetch("/api/new-scheduling/recurrent", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(payload),
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.message || "Erro ao criar agendamento recorrente");
      }
      
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/new-scheduling/classes"] });
      toast({
        title: "Agendamento recorrente criado",
        description: "Agendamento criado com sucesso. As aulas foram geradas automaticamente.",
      });
      onClose();
      form.reset();
    },
    onError: (error: Error) => {
      toast({
        title: "Erro ao criar agendamento",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  const onSubmit = (data: RecurrenceFormData) => {
    createRecurrenceMutation.mutate(data);
  };

  const recurrenceType = form.watch("recurrence.type");
  const recurrenceEndType = form.watch("recurrence.endType");

  return (
    <Dialog open={open} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-[700px] max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <Repeat className="h-5 w-5" />
            Novo Agendamento Recorrente
          </DialogTitle>
        </DialogHeader>

        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
            {/* Professor and Student */}
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <FormField
                control={form.control}
                name="professorId"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel className="flex items-center gap-2">
                      <User className="h-4 w-4" />
                      Professor *
                    </FormLabel>
                    <Select onValueChange={(value) => field.onChange(parseInt(value))}>
                      <FormControl>
                        <SelectTrigger>
                          <SelectValue placeholder="Selecione o professor" />
                        </SelectTrigger>
                      </FormControl>
                      <SelectContent>
                        {professors.map((professor) => (
                          <SelectItem key={professor.id} value={professor.id.toString()}>
                            {professor.name || professor.username}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="studentId"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel className="flex items-center gap-2">
                      <User className="h-4 w-4" />
                      Aluno *
                    </FormLabel>
                    <Select onValueChange={(value) => field.onChange(parseInt(value))}>
                      <FormControl>
                        <SelectTrigger>
                          <SelectValue placeholder="Selecione o aluno" />
                        </SelectTrigger>
                      </FormControl>
                      <SelectContent>
                        {students.map((student: any) => (
                          <SelectItem key={student.id} value={student.id.toString()}>
                            {student.name}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                    <FormMessage />
                  </FormItem>
                )}
              />
            </div>

            {/* Service and Location */}
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <FormField
                control={form.control}
                name="service"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Serviço *</FormLabel>
                    <FormControl>
                      <Input {...field} placeholder="Ex: Personal Training, Pilates..." />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="location"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel className="flex items-center gap-2">
                      <MapPin className="h-4 w-4" />
                      Local *
                    </FormLabel>
                    <FormControl>
                      <Input {...field} placeholder="Ex: Academia Pink, Domicílio..." />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
            </div>

            {/* Value */}
            <FormField
              control={form.control}
              name="value"
              render={({ field }) => (
                <FormItem>
                  <FormLabel className="flex items-center gap-2">
                    <DollarSign className="h-4 w-4" />
                    Valor por Aula (R$) *
                  </FormLabel>
                  <FormControl>
                    <Input
                      {...field}
                      type="number"
                      step="0.01"
                      min="0"
                      placeholder="0.00"
                      onChange={(e) => field.onChange(parseFloat(e.target.value) || 0)}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            {/* Date and Time */}
            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
              <FormField
                control={form.control}
                name="startDate"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel className="flex items-center gap-2">
                      <Calendar className="h-4 w-4" />
                      Data de Início *
                    </FormLabel>
                    <FormControl>
                      <Input {...field} type="date" />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="startTime"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel className="flex items-center gap-2">
                      <Clock className="h-4 w-4" />
                      Horário de Início *
                    </FormLabel>
                    <FormControl>
                      <Input {...field} type="time" />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="endTime"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel className="flex items-center gap-2">
                      <Clock className="h-4 w-4" />
                      Horário de Término *
                    </FormLabel>
                    <FormControl>
                      <Input {...field} type="time" />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
            </div>

            {/* Recurrence Settings */}
            <div className="border rounded-lg p-4 space-y-4">
              <h3 className="font-medium flex items-center gap-2">
                <Repeat className="h-4 w-4" />
                Configurações de Recorrência
              </h3>

              {/* Recurrence Type */}
              <FormField
                control={form.control}
                name="recurrence.type"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Tipo de Recorrência</FormLabel>
                    <Select onValueChange={field.onChange} defaultValue={field.value}>
                      <FormControl>
                        <SelectTrigger>
                          <SelectValue />
                        </SelectTrigger>
                      </FormControl>
                      <SelectContent>
                        <SelectItem value="daily">Diário</SelectItem>
                        <SelectItem value="weekly">Semanal</SelectItem>
                        <SelectItem value="monthly">Mensal</SelectItem>
                        <SelectItem value="yearly">Anual</SelectItem>
                      </SelectContent>
                    </Select>
                    <FormMessage />
                  </FormItem>
                )}
              />

              {/* Interval */}
              <FormField
                control={form.control}
                name="recurrence.interval"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>
                      {recurrenceType === "daily" && "A cada quantos dias"}
                      {recurrenceType === "weekly" && "A cada quantas semanas"}
                      {recurrenceType === "monthly" && "A cada quantos meses"}
                      {recurrenceType === "yearly" && "A cada quantos anos"}
                    </FormLabel>
                    <FormControl>
                      <Input
                        {...field}
                        type="number"
                        min="1"
                        onChange={(e) => field.onChange(parseInt(e.target.value) || 1)}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              {/* Week Days (only for weekly) */}
              {recurrenceType === "weekly" && (
                <FormField
                  control={form.control}
                  name="recurrence.weekDays"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Dias da Semana</FormLabel>
                      <div className="grid grid-cols-2 gap-2">
                        {weekDayOptions.map((option) => (
                          <div key={option.value} className="flex items-center space-x-2">
                            <Checkbox
                              id={option.value}
                              checked={field.value?.includes(option.value)}
                              onCheckedChange={(checked) => {
                                const current = field.value || [];
                                if (checked) {
                                  field.onChange([...current, option.value]);
                                } else {
                                  field.onChange(current.filter((day) => day !== option.value));
                                }
                              }}
                            />
                            <label htmlFor={option.value} className="text-sm">
                              {option.label}
                            </label>
                          </div>
                        ))}
                      </div>
                      <FormMessage />
                    </FormItem>
                  )}
                />
              )}

              {/* End Type */}
              <FormField
                control={form.control}
                name="recurrence.endType"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Fim da Recorrência</FormLabel>
                    <Select onValueChange={field.onChange} defaultValue={field.value}>
                      <FormControl>
                        <SelectTrigger>
                          <SelectValue />
                        </SelectTrigger>
                      </FormControl>
                      <SelectContent>
                        <SelectItem value="never">Nunca termina</SelectItem>
                        <SelectItem value="date">Até uma data específica</SelectItem>
                        <SelectItem value="count">Após um número de ocorrências</SelectItem>
                      </SelectContent>
                    </Select>
                    <FormMessage />
                  </FormItem>
                )}
              />

              {/* End Date */}
              {recurrenceEndType === "date" && (
                <FormField
                  control={form.control}
                  name="recurrence.endDate"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Data de Término</FormLabel>
                      <FormControl>
                        <Input {...field} type="date" />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />
              )}

              {/* End Count */}
              {recurrenceEndType === "count" && (
                <FormField
                  control={form.control}
                  name="recurrence.endCount"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Número de Ocorrências</FormLabel>
                      <FormControl>
                        <Input
                          {...field}
                          type="number"
                          min="1"
                          onChange={(e) => field.onChange(parseInt(e.target.value) || 1)}
                        />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />
              )}
            </div>

            {/* Notes */}
            <FormField
              control={form.control}
              name="notes"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Observações</FormLabel>
                  <FormControl>
                    <Textarea
                      {...field}
                      placeholder="Digite observações sobre o agendamento..."
                      rows={3}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            {/* Buttons */}
            <div className="flex justify-end gap-3 pt-4">
              <Button
                type="button"
                variant="outline"
                onClick={onClose}
                disabled={createRecurrenceMutation.isPending}
              >
                Cancelar
              </Button>
              <Button type="submit" disabled={createRecurrenceMutation.isPending}>
                {createRecurrenceMutation.isPending ? "Criando..." : "Criar Agendamento"}
              </Button>
            </div>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="client/src/components/scheduling/NewSessionForm.tsx">
import { useState } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { format } from 'date-fns';
import { ptBR } from 'date-fns/locale';
import { CalendarIcon, Clock, MapPin, User, DollarSign, Repeat, Calendar } from 'lucide-react';
import { cn } from '@/lib/utils';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Calendar as CalendarComponent } from '@/components/ui/calendar';
import { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Checkbox } from '@/components/ui/checkbox';
import { Label } from '@/components/ui/label';
import { Separator } from '@/components/ui/separator';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { useToast } from '@/hooks/use-toast';
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from '@/components/ui/form';

// Schema para o formulário
const sessionFormSchema = z.object({
  leadId: z.number().min(1, 'Selecione um aluno'),
  trainerId: z.number().min(1, 'Selecione um professor'),
  date: z.date({ required_error: 'Selecione uma data' }),
  startTime: z.string().min(1, 'Horário de início é obrigatório'),
  endTime: z.string().min(1, 'Horário de fim é obrigatório'),
  location: z.string().min(1, 'Local é obrigatório'),
  source: z.enum(['Favale', 'Pink', 'FavalePink'], {
    required_error: 'Selecione uma origem'
  }),
  value: z.number().min(1, 'Valor deve ser maior que zero'),
  service: z.string().min(1, 'Tipo de serviço é obrigatório'),
  notes: z.string().optional(),
  // Campos de recorrência
  recurrenceType: z.enum(['none', 'daily', 'weekly', 'monthly', 'yearly', 'custom']).default('none'),
  recurrenceInterval: z.number().min(1).default(1),
  recurrenceWeekDays: z.array(z.enum(['segunda', 'terca', 'quarta', 'quinta', 'sexta', 'sabado', 'domingo'])).optional(),
  recurrenceEndType: z.enum(['never', 'date', 'count']).default('never'),
  recurrenceEndDate: z.date().optional(),
  recurrenceEndCount: z.number().min(1).optional(),
}).refine(data => {
  // Validar horários
  const start = new Date(`2000-01-01T${data.startTime}`);
  const end = new Date(`2000-01-01T${data.endTime}`);
  return end > start;
}, {
  message: 'Horário de fim deve ser posterior ao horário de início',
  path: ['endTime']
}).refine(data => {
  // Validar campos de recorrência
  if (data.recurrenceType === 'weekly' && (!data.recurrenceWeekDays || data.recurrenceWeekDays.length === 0)) {
    return false;
  }
  if (data.recurrenceEndType === 'date' && !data.recurrenceEndDate) {
    return false;
  }
  if (data.recurrenceEndType === 'count' && !data.recurrenceEndCount) {
    return false;
  }
  return true;
}, {
  message: 'Configure corretamente as opções de recorrência',
  path: ['recurrenceType']
});

type SessionFormData = z.infer<typeof sessionFormSchema>;

interface NewSessionFormProps {
  leads: Array<{ id: number; name: string; source: string; status: string }>;
  trainers: Array<{ id: number; name: string; source: string }>;
  onSubmit: (data: SessionFormData) => void;
  onCancel: () => void;
  isLoading?: boolean;
}

export function NewSessionForm({ leads, trainers, onSubmit, onCancel, isLoading }: NewSessionFormProps) {
  const [showRecurrence, setShowRecurrence] = useState(false);
  const { toast } = useToast();

  const form = useForm<SessionFormData>({
    resolver: zodResolver(sessionFormSchema),
    defaultValues: {
      date: new Date(),
      startTime: '09:00',
      endTime: '10:00',
      value: 8000, // R$ 80,00 em centavos
      service: 'Personal Training',
      recurrenceType: 'none',
      recurrenceInterval: 1,
      recurrenceEndType: 'never',
    },
  });

  const watchRecurrenceType = form.watch('recurrenceType');
  const watchRecurrenceEndType = form.watch('recurrenceEndType');
  const watchSource = form.watch('source');

  // Filtrar alunos por origem
  const filteredLeads = leads.filter(lead => 
    lead.status === 'Aluno' && 
    (watchSource ? lead.source === watchSource : true)
  );

  // Filtrar professores por origem
  const filteredTrainers = trainers.filter(trainer => 
    watchSource ? trainer.source === watchSource || trainer.source === 'FavalePink' : true
  );

  const recurrenceOptions = [
    { value: 'none', label: 'Não se repete' },
    { value: 'daily', label: 'Todos os dias' },
    { value: 'weekly', label: 'Semanal' },
    { value: 'monthly', label: 'Mensal' },
    { value: 'yearly', label: 'Anual' },
    { value: 'custom', label: 'Personalizar...' }
  ];

  const weekDaysOptions = [
    { value: 'segunda', label: 'Segunda-feira' },
    { value: 'terca', label: 'Terça-feira' },
    { value: 'quarta', label: 'Quarta-feira' },
    { value: 'quinta', label: 'Quinta-feira' },
    { value: 'sexta', label: 'Sexta-feira' },
    { value: 'sabado', label: 'Sábado' },
    { value: 'domingo', label: 'Domingo' }
  ];

  const handleSubmit = (data: SessionFormData) => {
    try {
      onSubmit(data);
    } catch (error) {
      toast({
        title: 'Erro',
        description: 'Erro ao agendar sessão. Tente novamente.',
        variant: 'destructive'
      });
    }
  };

  return (
    <div className="space-y-6">
      <div className="flex items-center gap-2">
        <Calendar className="h-5 w-5 text-blue-500" />
        <h2 className="text-xl font-semibold">Agendar Nova Sessão</h2>
      </div>

      <Form {...form}>
        <form onSubmit={form.handleSubmit(handleSubmit)} className="space-y-6">
          {/* Informações básicas */}
          <Card>
            <CardHeader>
              <CardTitle className="text-base">Informações Básicas</CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <FormField
                  control={form.control}
                  name="source"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Origem</FormLabel>
                      <Select onValueChange={field.onChange} defaultValue={field.value}>
                        <FormControl>
                          <SelectTrigger>
                            <SelectValue placeholder="Selecione a origem" />
                          </SelectTrigger>
                        </FormControl>
                        <SelectContent>
                          <SelectItem value="Favale">Favale</SelectItem>
                          <SelectItem value="Pink">Pink</SelectItem>
                          <SelectItem value="FavalePink">Favale&Pink</SelectItem>
                        </SelectContent>
                      </Select>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <FormField
                  control={form.control}
                  name="leadId"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Aluno</FormLabel>
                      <Select 
                        onValueChange={(value) => field.onChange(parseInt(value))} 
                        value={field.value?.toString()}
                      >
                        <FormControl>
                          <SelectTrigger>
                            <SelectValue placeholder="Selecione um aluno" />
                          </SelectTrigger>
                        </FormControl>
                        <SelectContent>
                          {filteredLeads.map((lead) => (
                            <SelectItem key={lead.id} value={lead.id.toString()}>
                              <div className="flex items-center gap-2">
                                <User className="h-4 w-4" />
                                {lead.name}
                                <Badge variant="outline" className="text-xs">
                                  {lead.source}
                                </Badge>
                              </div>
                            </SelectItem>
                          ))}
                        </SelectContent>
                      </Select>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <FormField
                  control={form.control}
                  name="trainerId"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Professor</FormLabel>
                      <Select 
                        onValueChange={(value) => field.onChange(parseInt(value))} 
                        value={field.value?.toString()}
                      >
                        <FormControl>
                          <SelectTrigger>
                            <SelectValue placeholder="Selecione um professor" />
                          </SelectTrigger>
                        </FormControl>
                        <SelectContent>
                          {filteredTrainers.map((trainer) => (
                            <SelectItem key={trainer.id} value={trainer.id.toString()}>
                              <div className="flex items-center gap-2">
                                <User className="h-4 w-4" />
                                {trainer.name}
                                <Badge variant="outline" className="text-xs">
                                  {trainer.source}
                                </Badge>
                              </div>
                            </SelectItem>
                          ))}
                        </SelectContent>
                      </Select>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <FormField
                  control={form.control}
                  name="location"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Local</FormLabel>
                      <FormControl>
                        <div className="relative">
                          <MapPin className="absolute left-3 top-3 h-4 w-4 text-gray-400" />
                          <Input {...field} placeholder="Ex: Casa do aluno, Studio..." className="pl-10" />
                        </div>
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <FormField
                  control={form.control}
                  name="service"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Tipo de Serviço</FormLabel>
                      <Select onValueChange={field.onChange} defaultValue={field.value}>
                        <FormControl>
                          <SelectTrigger>
                            <SelectValue placeholder="Selecione o serviço" />
                          </SelectTrigger>
                        </FormControl>
                        <SelectContent>
                          <SelectItem value="Personal Training">Personal Training</SelectItem>
                          <SelectItem value="Treino Funcional">Treino Funcional</SelectItem>
                          <SelectItem value="Musculação">Musculação</SelectItem>
                          <SelectItem value="Pilates">Pilates</SelectItem>
                          <SelectItem value="Yoga">Yoga</SelectItem>
                        </SelectContent>
                      </Select>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <FormField
                  control={form.control}
                  name="value"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Valor (R$)</FormLabel>
                      <FormControl>
                        <div className="relative">
                          <DollarSign className="absolute left-3 top-3 h-4 w-4 text-gray-400" />
                          <Input 
                            {...field}
                            type="number"
                            step="0.01"
                            placeholder="80.00"
                            className="pl-10"
                            onChange={(e) => field.onChange(Math.round(parseFloat(e.target.value || '0') * 100))}
                            value={field.value ? (field.value / 100).toFixed(2) : ''}
                          />
                        </div>
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />
              </div>
            </CardContent>
          </Card>

          {/* Data e horário */}
          <Card>
            <CardHeader>
              <CardTitle className="text-base">Data e Horário</CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                <FormField
                  control={form.control}
                  name="date"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Data</FormLabel>
                      <Popover>
                        <PopoverTrigger asChild>
                          <FormControl>
                            <Button
                              variant="outline"
                              className={cn(
                                "w-full pl-3 text-left font-normal",
                                !field.value && "text-muted-foreground"
                              )}
                            >
                              {field.value ? (
                                format(field.value, "PPP", { locale: ptBR })
                              ) : (
                                <span>Selecione uma data</span>
                              )}
                              <CalendarIcon className="ml-auto h-4 w-4 opacity-50" />
                            </Button>
                          </FormControl>
                        </PopoverTrigger>
                        <PopoverContent className="w-auto p-0" align="start">
                          <CalendarComponent
                            mode="single"
                            selected={field.value}
                            onSelect={field.onChange}
                            disabled={(date) => date < new Date(new Date().setHours(0, 0, 0, 0))}
                            initialFocus
                          />
                        </PopoverContent>
                      </Popover>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <FormField
                  control={form.control}
                  name="startTime"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Horário de Início</FormLabel>
                      <FormControl>
                        <div className="relative">
                          <Clock className="absolute left-3 top-3 h-4 w-4 text-gray-400" />
                          <Input {...field} type="time" className="pl-10" />
                        </div>
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <FormField
                  control={form.control}
                  name="endTime"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Horário de Fim</FormLabel>
                      <FormControl>
                        <div className="relative">
                          <Clock className="absolute left-3 top-3 h-4 w-4 text-gray-400" />
                          <Input {...field} type="time" className="pl-10" />
                        </div>
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />
              </div>
            </CardContent>
          </Card>

          {/* Recorrência */}
          <Card>
            <CardHeader>
              <CardTitle className="text-base flex items-center gap-2">
                <Repeat className="h-4 w-4" />
                Repetir Sessão
              </CardTitle>
              <CardDescription>
                Configure se esta sessão deve se repetir automaticamente
              </CardDescription>
            </CardHeader>
            <CardContent className="space-y-4">
              <FormField
                control={form.control}
                name="recurrenceType"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Tipo de Repetição</FormLabel>
                    <Select onValueChange={(value) => {
                      field.onChange(value);
                      setShowRecurrence(value !== 'none');
                    }} defaultValue={field.value}>
                      <FormControl>
                        <SelectTrigger>
                          <SelectValue placeholder="Selecione como repetir" />
                        </SelectTrigger>
                      </FormControl>
                      <SelectContent>
                        {recurrenceOptions.map((option) => (
                          <SelectItem key={option.value} value={option.value}>
                            {option.label}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                    <FormMessage />
                  </FormItem>
                )}
              />

              {showRecurrence && watchRecurrenceType !== 'none' && (
                <div className="space-y-4 p-4 bg-gray-50 dark:bg-gray-800 rounded-lg">
                  {watchRecurrenceType === 'custom' && (
                    <div className="space-y-4 p-4 bg-blue-50 dark:bg-blue-900/20 rounded-lg border border-blue-200 dark:border-blue-800">
                      <h4 className="font-medium text-blue-900 dark:text-blue-100">Recorrência personalizada</h4>

                      <div className="flex items-center gap-2">
                        <span className="text-sm text-gray-600 dark:text-gray-300">Repetir a cada:</span>
                        <FormField
                          control={form.control}
                          name="recurrenceInterval"
                          render={({ field }) => (
                            <FormItem className="flex-shrink-0">
                              <FormControl>
                                <Input
                                  {...field}
                                  type="number"
                                  min="1"
                                  max="30"
                                  className="w-16 text-center"
                                  onChange={(e) => field.onChange(parseInt(e.target.value || '1'))}
                                />
                              </FormControl>
                            </FormItem>
                          )}
                        />
                        <Select defaultValue="weekly">
                          <SelectTrigger className="w-32">
                            <SelectValue />
                          </SelectTrigger>
                          <SelectContent>
                            <SelectItem value="daily">dia(s)</SelectItem>
                            <SelectItem value="weekly">semana(s)</SelectItem>
                            <SelectItem value="monthly">mês(es)</SelectItem>
                          </SelectContent>
                        </Select>
                      </div>

                      <div>
                        <Label className="text-sm font-medium text-gray-700 dark:text-gray-300">Repetir:</Label>
                        <FormField
                          control={form.control}
                          name="recurrenceWeekDays"
                          render={({ field }) => (
                            <FormItem>
                              <div className="flex gap-1 mt-2">
                                {['D', 'S', 'T', 'Q', 'Q', 'S', 'S'].map((day, index) => {
                                  const dayValues = ['domingo', 'segunda', 'terca', 'quarta', 'quinta', 'sexta', 'sabado'];
                                  const dayValue = dayValues[index];
                                  const isSelected = field.value?.includes(dayValue as any) || false;

                                  return (
                                    <button
                                      key={index}
                                      type="button"
                                      onClick={() => {
                                        const current = field.value || [];
                                        if (isSelected) {
                                          field.onChange(current.filter(d => d !== dayValue));
                                        } else {
                                          field.onChange([...current, dayValue]);
                                        }
                                      }}
                                      className={cn(
                                        "w-8 h-8 rounded-full text-sm font-medium transition-colors",
                                        isSelected 
                                          ? "bg-blue-500 text-white" 
                                          : "bg-gray-100 text-gray-600 hover:bg-gray-200 dark:bg-gray-700 dark:text-gray-300 dark:hover:bg-gray-600"
                                      )}
                                    >
                                      {day}
                                    </button>
                                  );
                                })}
                              </div>
                              <FormMessage />
                            </FormItem>
                          )}
                        />
                      </div>

                      <div>
                        <Label className="text-sm font-medium text-gray-700 dark:text-gray-300">Termina em</Label>
                        <FormField
                          control={form.control}
                          name="recurrenceEndType"
                          render={({ field }) => (
                            <FormItem className="mt-2">
                              <div className="space-y-2">
                                <div className="flex items-center space-x-2">
                                  <input
                                    type="radio"
                                    id="never"
                                    name="endType"
                                    checked={field.value === 'never'}
                                    onChange={() => field.onChange('never')}
                                    className="w-4 h-4 text-blue-600"
                                  />
                                  <Label htmlFor="never" className="text-sm">Nunca</Label>
                                </div>

                                <div className="flex items-center space-x-2">
                                  <input
                                    type="radio"
                                    id="date"
                                    name="endType"
                                    checked={field.value === 'date'}
                                    onChange={() => field.onChange('date')}
                                    className="w-4 h-4 text-blue-600"
                                  />
                                  <Label htmlFor="date" className="text-sm">Em</Label>
                                  {watchRecurrenceEndType === 'date' && (
                                    <FormField
                                      control={form.control}
                                      name="recurrenceEndDate"
                                      render={({ field: dateField }) => (
                                        <FormItem>
                                          <FormControl>
                                            <Input
                                              type="date"
                                              value={dateField.value ? format(dateField.value, 'yyyy-MM-dd') : ''}
                                              onChange={(e) => dateField.onChange(new Date(e.target.value))}
                                              className="text-sm"
                                            />
                                          </FormControl>
                                        </FormItem>
                                      )}
                                    />
                                  )}
                                </div>

                                <div className="flex items-center space-x-2">
                                  <input
                                    type="radio"
                                    id="count"
                                    name="endType"
                                    checked={field.value === 'count'}
                                    onChange={() => field.onChange('count')}
                                    className="w-4 h-4 text-blue-600"
                                  />
                                  <Label htmlFor="count" className="text-sm">Após</Label>
                                  {watchRecurrenceEndType === 'count' && (
                                    <FormField
                                      control={form.control}
                                      name="recurrenceEndCount"
                                      render={({ field: countField }) => (
                                        <FormItem>
                                          <FormControl>
                                            <Input
                                              {...countField}
                                              type="number"
                                              min="1"
                                              max="100"
                                              className="w-16 text-center text-sm"
                                              onChange={(e) => countField.onChange(parseInt(e.target.value || '1'))}
                                            />
                                          </FormControl>
                                        </FormItem>
                                      )}
                                    />
                                  )}
                                  {watchRecurrenceEndType === 'count' && (
                                    <span className="text-sm text-gray-600 dark:text-gray-400">ocorrências</span>
                                  )}
                                </div>
                              </div>
                              <FormMessage />
                            </FormItem>
                          )}
                        />
                      </div>
                    </div>
                  )}

                  {(watchRecurrenceType === 'daily' || watchRecurrenceType === 'weekly' || watchRecurrenceType === 'monthly') && watchRecurrenceType !== 'custom' && (
                    <FormField
                      control={form.control}
                      name="recurrenceInterval"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>
                            {watchRecurrenceType === 'daily' && 'Repetir a cada X dias'}
                            {watchRecurrenceType === 'weekly' && 'Repetir a cada X semanas'}
                            {watchRecurrenceType === 'monthly' && 'Repetir a cada X meses'}
                          </FormLabel>
                          <FormControl>
                            <Input
                              {...field}
                              type="number"
                              min="1"
                              max="30"
                              onChange={(e) => field.onChange(parseInt(e.target.value || '1'))}
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                  )}

                  {watchRecurrenceType === 'weekly' && watchRecurrenceType !== 'custom' && (
                    <FormField
                      control={form.control}
                      name="recurrenceWeekDays"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Dias da Semana</FormLabel>
                          <div className="grid grid-cols-2 md:grid-cols-4 gap-2">
                            {weekDaysOptions.map((day) => (
                              <div key={day.value} className="flex items-center space-x-2">
                                <Checkbox
                                  id={day.value}
                                  checked={field.value?.includes(day.value as any) || false}
                                  onCheckedChange={(checked) => {
                                    const current = field.value || [];
                                    if (checked) {
                                      field.onChange([...current, day.value]);
                                    } else {
                                      field.onChange(current.filter(d => d !== day.value));
                                    }
                                  }}
                                />
                                <Label htmlFor={day.value} className="text-sm">
                                  {day.label}
                                </Label>
                              </div>
                            ))}
                          </div>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                  )}

                  <Separator />

                  <FormField
                    control={form.control}
                    name="recurrenceEndType"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Terminar</FormLabel>
                        <Select onValueChange={field.onChange} defaultValue={field.value}>
                          <FormControl>
                            <SelectTrigger>
                              <SelectValue placeholder="Quando parar de repetir" />
                            </SelectTrigger>
                          </FormControl>
                          <SelectContent>
                            <SelectItem value="never">Nunca</SelectItem>
                            <SelectItem value="date">Em uma data específica</SelectItem>
                            <SelectItem value="count">Após um número de ocorrências</SelectItem>
                          </SelectContent>
                        </Select>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  {watchRecurrenceEndType === 'date' && (
                    <FormField
                      control={form.control}
                      name="recurrenceEndDate"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Data Final</FormLabel>
                          <Popover>
                            <PopoverTrigger asChild>
                              <FormControl>
                                <Button
                                  variant="outline"
                                  className={cn(
                                    "w-full pl-3 text-left font-normal",
                                    !field.value && "text-muted-foreground"
                                  )}
                                >
                                  {field.value ? (
                                    format(field.value, "PPP", { locale: ptBR })
                                  ) : (
                                    <span>Selecione a data final</span>
                                  )}
                                  <CalendarIcon className="ml-auto h-4 w-4 opacity-50" />
                                </Button>
                              </FormControl>
                            </PopoverTrigger>
                            <PopoverContent className="w-auto p-0" align="start">
                              <CalendarComponent
                                mode="single"
                                selected={field.value}
                                onSelect={field.onChange}
                                disabled={(date) => date < new Date()}
                                initialFocus
                              />
                            </PopoverContent>
                          </Popover>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                  )}

                  {watchRecurrenceEndType === 'count' && (
                    <FormField
                      control={form.control}
                      name="recurrenceEndCount"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Número de Ocorrências</FormLabel>
                          <FormControl>
                            <Input
                              {...field}
                              type="number"
                              min="1"
                              max="100"
                              placeholder="Ex: 10"
                              onChange={(e) => field.onChange(parseInt(e.target.value || '1'))}
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                  )}
                </div>
              )}
            </CardContent>
          </Card>

          {/* Observações */}
          <Card>
            <CardHeader>
              <CardTitle className="text-base">Observações</CardTitle>
            </CardHeader>
            <CardContent>
              <FormField
                control={form.control}
                name="notes"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Notas (opcional)</FormLabel>
                    <FormControl>
                      <Textarea
                        {...field}
                        placeholder="Observações sobre a sessão..."
                        className="min-h-[80px]"
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
            </CardContent>
          </Card>

          {/* Ações */}
          <div className="flex gap-3 justify-end">
            <Button type="button" variant="outline" onClick={onCancel}>
              Cancelar
            </Button>
            <Button type="submit" disabled={isLoading}>
              {isLoading ? 'Agendando...' : 'Agendar Sessão'}
            </Button>
          </div>
        </form>
      </Form>
    </div>
  );
}
</file>

<file path="client/src/components/scheduling/RecurringAppointmentDialog.tsx">
import React, { useState, useCallback, useMemo } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription } from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Textarea } from '@/components/ui/textarea';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Checkbox } from '@/components/ui/checkbox';
import { Plus, User, Clock, MapPin, DollarSign, FileText } from 'lucide-react';
import { useToast } from '@/hooks/use-toast';

interface Lead {
  id: number;
  name: string;
  email?: string;
  phone?: string;
  status?: string;
}

interface Service {
  id: number;
  name: string;
  description?: string;
  duration: number;
  price: number;
}

interface Professor {
  id: number;
  name: string;
  email: string;
}

interface TimeSlot {
  hour: number;
  selected: boolean;
}

interface DaySchedule {
  dayOfWeek: number;
  selected: boolean;
  timeSlots: TimeSlot[];
  selectedProfessors: number[];
}

interface RecurringAppointmentDialogProps {
  isOpen: boolean;
  onClose: () => void;
}

const WEEKDAYS = [
  { value: 1, label: 'Segunda-feira', short: 'SEG' },
  { value: 2, label: 'Terça-feira', short: 'TER' },
  { value: 3, label: 'Quarta-feira', short: 'QUA' },
  { value: 4, label: 'Quinta-feira', short: 'QUI' },
  { value: 5, label: 'Sexta-feira', short: 'SEX' },
  { value: 6, label: 'Sábado', short: 'SAB' },
  { value: 0, label: 'Domingo', short: 'DOM' }
];

// Generate time slots from 04:00 to 22:00 (1-hour blocks) - Memoized
const generateTimeSlots = (): TimeSlot[] => {
  const slots: TimeSlot[] = [];
  for (let hour = 4; hour <= 22; hour++) {
    slots.push({ hour, selected: false });
  }
  return slots;
};

// Memoize the initial time slots generation
const INITIAL_TIME_SLOTS = generateTimeSlots();

const formatHour = (hour: number): string => {
  return `${hour.toString().padStart(2, '0')}:00`;
};

export function RecurringAppointmentDialog({ isOpen, onClose }: RecurringAppointmentDialogProps) {
  const { toast } = useToast();
  const queryClient = useQueryClient();

  // Form state
  const [selectedStudentId, setSelectedStudentId] = useState<number | null>(null);
  const [selectedServiceId, setSelectedServiceId] = useState<number | null>(null);
  const [startDate, setStartDate] = useState('');
  const [location, setLocation] = useState('');
  const [value, setValue] = useState<number>(0);
  const [notes, setNotes] = useState('');
  const [weeklySchedule, setWeeklySchedule] = useState<DaySchedule[]>(() =>
    WEEKDAYS.map(day => ({
      dayOfWeek: day.value,
      selected: false,
      timeSlots: INITIAL_TIME_SLOTS.map(slot => ({ ...slot })), // Clone inicial dos slots
      selectedProfessors: []
    }))
  );
  const [showNewStudentForm, setShowNewStudentForm] = useState(false);
  const [newStudentName, setNewStudentName] = useState('');
  const [newStudentEmail, setNewStudentEmail] = useState('');
  const [newStudentPhone, setNewStudentPhone] = useState('');

  // Buscar dados necessários
  const { data: allLeads = [] } = useQuery<Lead[]>({
    queryKey: ["/api/leads"],
    enabled: isOpen,
    staleTime: 5 * 60 * 1000 // 5 minutes
  });

  // Filtrar apenas alunos
  const leads = allLeads.filter(lead => lead.status === "Aluno");

  const { data: services = [] } = useQuery<Service[]>({
    queryKey: ['/api/services'],
    enabled: isOpen,
    staleTime: 5 * 60 * 1000
  });

  const { data: professors = [] } = useQuery<Professor[]>({
    queryKey: ['/api/users/professors'],
    enabled: isOpen,
    staleTime: 5 * 60 * 1000
  });

  // Create new student mutation
  const createStudentMutation = useMutation({
    mutationFn: async (studentData: { name: string; email?: string; phone?: string }) => {
      const response = await fetch('/api/leads', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          ...studentData,
          status: 'ativo',
          source: 'agendamento_recorrente',
          entryDate: new Date().toISOString()
        })
      });
      if (!response.ok) throw new Error('Failed to create student');
      return response.json();
    },
    onSuccess: (newStudent) => {
      queryClient.invalidateQueries({ queryKey: ['/api/leads'] });
      setSelectedStudentId(newStudent.id);
      setShowNewStudentForm(false);
      setNewStudentName('');
      setNewStudentEmail('');
      setNewStudentPhone('');
      toast({
        title: "Aluno criado",
        description: "Novo aluno adicionado com sucesso."
      });
    }
  });

  // Create recurring appointment mutation
  const createRecurringMutation = useMutation({
    mutationFn: async (data: any) => {
      const response = await fetch('/api/appointments/recurring', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data)
      });
      if (!response.ok) throw new Error('Failed to create recurring appointment');
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['/api/appointments'] });
      toast({
        title: "Agendamento criado",
        description: "Agendamento recorrente criado com sucesso!"
      });
      handleClose();
    }
  });

  // Handle day selection - Otimizado com useCallback
  const handleDayToggle = useCallback((dayIndex: number) => {
    setWeeklySchedule(prev => 
      prev.map((day, idx) => 
        idx === dayIndex 
          ? { 
              ...day, 
              selected: !day.selected,
              // Só reseta time slots se o dia está sendo desmarcado
              timeSlots: !day.selected ? day.timeSlots : INITIAL_TIME_SLOTS.map(slot => ({ ...slot })),
              selectedProfessors: !day.selected ? day.selectedProfessors : []
            }
          : day
      )
    );
  }, []);

  // Handle time slot selection - Otimizado com useCallback
  const handleTimeSlotToggle = useCallback((dayIndex: number, slotIndex: number) => {
    setWeeklySchedule(prev => 
      prev.map((day, idx) => 
        idx === dayIndex 
          ? {
              ...day,
              timeSlots: day.timeSlots.map((slot, sIdx) =>
                sIdx === slotIndex ? { ...slot, selected: !slot.selected } : slot
              )
            }
          : day
      )
    );
  }, []);

  // Handle professor selection - Otimizado com useCallback
  const handleProfessorToggle = useCallback((dayIndex: number, professorId: number) => {
    setWeeklySchedule(prev => 
      prev.map((day, idx) => 
        idx === dayIndex 
          ? {
              ...day,
              selectedProfessors: day.selectedProfessors.includes(professorId)
                ? day.selectedProfessors.filter(id => id !== professorId)
                : [...day.selectedProfessors, professorId]
            }
          : day
      )
    );
  }, []);

  // Memoizar selectedService para evitar re-cálculos
  const selectedService = useMemo(() => 
    services.find(s => s.id === selectedServiceId), 
    [services, selectedServiceId]
  );

  // Handle form submission - Otimizado com useCallback
  const handleSubmit = useCallback(() => {
    if (!selectedStudentId || !selectedServiceId || !startDate) {
      toast({
        title: "Campos obrigatórios",
        description: "Preencha aluno, serviço e data de início.",
        variant: "destructive"
      });
      return;
    }

    const selectedDays = weeklySchedule.filter(day => 
      day.selected && 
      day.timeSlots.some(slot => slot.selected) &&
      day.selectedProfessors.length > 0
    );

    if (selectedDays.length === 0) {
      toast({
        title: "Selecione agendamentos",
        description: "Selecione pelo menos um dia com horários e professores.",
        variant: "destructive"
      });
      return;
    }

    const student = leads.find(lead => lead.id === selectedStudentId);
    const service = services.find(s => s.id === selectedServiceId);

    // Build weekly schedule for API
    const weeklyScheduleData = selectedDays.map(day => ({
      dayOfWeek: day.dayOfWeek,
      professorsSchedule: day.selectedProfessors.map(profId => ({
        professorId: profId,
        timeSlots: day.timeSlots
          .filter(slot => slot.selected)
          .map(slot => ({
            startTime: formatHour(slot.hour),
            endTime: formatHour(slot.hour + 1)
          }))
      }))
    }));

    createRecurringMutation.mutate({
      studentName: student?.name,
      service: service?.name,
      location,
      value,
      notes,
      startDate,
      endDate: new Date(new Date(startDate).setMonth(new Date(startDate).getMonth() + 3)).toISOString(),
      weeklySchedule: weeklyScheduleData
    });
  }, [selectedStudentId, selectedServiceId, startDate, weeklySchedule, leads, services, location, value, notes, createRecurringMutation, toast]);

  const handleClose = useCallback(() => {
    setSelectedStudentId(null);
    setSelectedServiceId(null);
    setStartDate('');
    setLocation('');
    setValue(0);
    setNotes('');
    setWeeklySchedule(WEEKDAYS.map(day => ({
      dayOfWeek: day.value,
      selected: false,
      timeSlots: INITIAL_TIME_SLOTS.map(slot => ({ ...slot })),
      selectedProfessors: []
    })));
    setShowNewStudentForm(false);
    setNewStudentName('');
    setNewStudentEmail('');
    setNewStudentPhone('');
    onClose();
  }, [onClose]);

  return (
    <Dialog open={isOpen} onOpenChange={handleClose}>
      <DialogContent className="max-w-5xl max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <Plus className="h-5 w-5" />
            Agendar Serviço Recorrente
          </DialogTitle>
          <DialogDescription>
            Configure agendamentos recorrentes selecionando dias, horários e professores.
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-6">
          {/* Student Selection */}
          <div className="space-y-2">
            <Label className="flex items-center gap-2">
              <User className="h-4 w-4" />
              Aluno
            </Label>
            <div className="flex gap-2">
              <Select value={selectedStudentId?.toString() || ''} onValueChange={(value) => setSelectedStudentId(Number(value))}>
                <SelectTrigger className="flex-1">
                  <SelectValue placeholder="Selecione um aluno" />
                </SelectTrigger>
                <SelectContent>
                  {leads.map((lead) => (
                    <SelectItem key={lead.id} value={lead.id.toString()}>
                      {lead.name}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
              <Button 
                variant="outline" 
                onClick={() => setShowNewStudentForm(true)}
                className="px-3"
              >
                <Plus className="h-4 w-4" />
              </Button>
            </div>
          </div>

          {/* New Student Form */}
          {showNewStudentForm && (
            <Card>
              <CardHeader>
                <CardTitle>Adicionar Novo Aluno</CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <div>
                  <Label>Nome *</Label>
                  <Input
                    value={newStudentName}
                    onChange={(e) => setNewStudentName(e.target.value)}
                    placeholder="Nome do aluno"
                  />
                </div>
                <div>
                  <Label>Email</Label>
                  <Input
                    type="email"
                    value={newStudentEmail}
                    onChange={(e) => setNewStudentEmail(e.target.value)}
                    placeholder="email@exemplo.com"
                  />
                </div>
                <div>
                  <Label>Telefone</Label>
                  <Input
                    value={newStudentPhone}
                    onChange={(e) => setNewStudentPhone(e.target.value)}
                    placeholder="(11) 99999-9999"
                  />
                </div>
                <div className="flex gap-2">
                  <Button 
                    onClick={() => createStudentMutation.mutate({
                      name: newStudentName,
                      email: newStudentEmail || undefined,
                      phone: newStudentPhone || undefined
                    })}
                    disabled={!newStudentName || createStudentMutation.isPending}
                  >
                    Criar Aluno
                  </Button>
                  <Button 
                    variant="outline" 
                    onClick={() => setShowNewStudentForm(false)}
                  >
                    Cancelar
                  </Button>
                </div>
              </CardContent>
            </Card>
          )}

          {/* Service Selection */}
          <div className="space-y-2">
            <Label>Serviço</Label>
            <Select value={selectedServiceId?.toString() || ''} onValueChange={(value) => setSelectedServiceId(Number(value))}>
              <SelectTrigger>
                <SelectValue placeholder="Selecione um serviço" />
              </SelectTrigger>
              <SelectContent>
                {services.map((service) => (
                  <SelectItem key={service.id} value={service.id.toString()}>
                    {service.name} - {service.duration}min
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>

          <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
            {/* Start Date */}
            <div className="space-y-2">
              <Label>Data de Início</Label>
              <Input
                type="date"
                value={startDate}
                onChange={(e) => setStartDate(e.target.value)}
              />
            </div>

            {/* Location */}
            <div className="space-y-2">
              <Label className="flex items-center gap-2">
                <MapPin className="h-4 w-4" />
                Local
              </Label>
              <Input
                value={location}
                onChange={(e) => setLocation(e.target.value)}
                placeholder="Local do atendimento"
              />
            </div>

            {/* Value */}
            <div className="space-y-2">
              <Label className="flex items-center gap-2">
                <DollarSign className="h-4 w-4" />
                Valor (R$)
              </Label>
              <Input
                type="number"
                value={value / 100}
                onChange={(e) => setValue(Math.round(Number(e.target.value) * 100))}
                placeholder={selectedService ? (selectedService.price / 100).toFixed(2) : "0.00"}
                step="0.01"
              />
            </div>
          </div>

          {/* Weekly Schedule */}
          <div className="space-y-4">
            <Label className="text-lg font-semibold">Programação Semanal</Label>

            {WEEKDAYS.map((weekday, dayIndex) => {
              const daySchedule = weeklySchedule[dayIndex];
              // Memoizar para evitar re-cálculos a cada render
              const selectedTimeSlots = useMemo(() => 
                daySchedule.timeSlots.filter(slot => slot.selected),
                [daySchedule.timeSlots]
              );

              return (
                <Card key={weekday.value} className={daySchedule.selected ? 'border-pink-500' : ''}>
                  <CardHeader className="pb-3">
                    <div className="flex items-center space-x-2">
                      <Checkbox
                        checked={daySchedule.selected}
                        onCheckedChange={() => handleDayToggle(dayIndex)}
                      />
                      <CardTitle className="text-base">{weekday.label}</CardTitle>
                      {daySchedule.selected && selectedTimeSlots.length > 0 && (
                        <span className="text-sm text-gray-500">
                          ({selectedTimeSlots.length} horário{selectedTimeSlots.length > 1 ? 's' : ''})
                        </span>
                      )}
                    </div>
                  </CardHeader>

                  {daySchedule.selected && (
                    <CardContent className="space-y-4">
                      {/* Time Slots Grid */}
                      <div className="space-y-2">
                        <Label className="flex items-center gap-2">
                          <Clock className="h-4 w-4" />
                          Horários (1 hora cada)
                        </Label>

                        <div className="grid grid-cols-6 gap-2">
                          {daySchedule.timeSlots.map((slot, slotIndex) => (
                            <Button
                              key={slot.hour}
                              variant={slot.selected ? "default" : "outline"}
                              size="sm"
                              onClick={() => handleTimeSlotToggle(dayIndex, slotIndex)}
                              className={`text-xs ${slot.selected ? 'bg-pink-600 hover:bg-pink-700' : ''}`}
                            >
                              {formatHour(slot.hour)}
                            </Button>
                          ))}
                        </div>
                      </div>

                      {/* Professors Selection */}
                      {selectedTimeSlots.length > 0 && (
                        <div className="space-y-2">
                          <Label>Professores</Label>
                          <div className="grid grid-cols-2 gap-2">
                            {professors.map((professor) => (
                              <div key={professor.id} className="flex items-center space-x-2">
                                <Checkbox
                                  checked={daySchedule.selectedProfessors.includes(professor.id)}
                                  onCheckedChange={() => handleProfessorToggle(dayIndex, professor.id)}
                                />
                                <span className="text-sm">{professor.name}</span>
                              </div>
                            ))}
                          </div>
                          {daySchedule.selectedProfessors.length > 0 && (
                            <p className="text-sm text-green-600">
                              {daySchedule.selectedProfessors.length} professor{daySchedule.selectedProfessors.length > 1 ? 'es' : ''} selecionado{daySchedule.selectedProfessors.length > 1 ? 's' : ''}
                            </p>
                          )}
                        </div>
                      )}
                    </CardContent>
                  )}
                </Card>
              );
            })}
          </div>

          {/* Notes */}
          <div className="space-y-2">
            <Label className="flex items-center gap-2">
              <FileText className="h-4 w-4" />
              Observações
            </Label>
            <Textarea
              value={notes}
              onChange={(e) => setNotes(e.target.value)}
              placeholder="Observações adicionais..."
              rows={3}
            />
          </div>

          {/* Actions */}
          <div className="flex justify-end gap-2 pt-4 border-t">
            <Button variant="outline" onClick={handleClose}>
              Cancelar
            </Button>
            <Button 
              onClick={handleSubmit}
              disabled={createRecurringMutation.isPending}
              className="bg-purple-600 hover:bg-purple-700"
            >
              {createRecurringMutation.isPending ? 'Criando...' : 'Criar Agendamentos'}
            </Button>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="client/src/components/scheduling/RecurringSessionCard.tsx">
import { useState } from 'react';
import { format } from 'date-fns';
import { ptBR } from 'date-fns/locale';
import { ChevronDown, ChevronRight, Calendar, Clock, MapPin, User, Repeat, MoreVertical } from 'lucide-react';
import { Card, CardContent } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { Collapsible, CollapsibleContent, CollapsibleTrigger } from '@/components/ui/collapsible';
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from '@/components/ui/dropdown-menu';

interface Session {
  id: number;
  startTime: string;
  endTime: string;
  location: string;
  source: 'Favale' | 'Pink' | 'FavalePink';
  notes?: string;
  status: string;
  leadId: number;
  trainerId: number;
  value?: number;
  service?: string;
  recurrenceType?: string;
  recurrenceGroupId?: string;
  isRecurrenceParent?: boolean;
  parentSessionId?: number;
}

interface RecurringGroup {
  pattern: string;
  sessions: Session[];
  studentName: string;
  trainerName: string;
  source: 'Favale' | 'Pink' | 'FavalePink';
  location: string;
  timeSlot: string;
  nextSession?: Session;
}

interface RecurringSessionCardProps {
  group: RecurringGroup;
  onEditSession?: (session: Session) => void;
  onCancelSession?: (sessionId: number) => void;
  onCompleteSession?: (sessionId: number) => void;
}

export function RecurringSessionCard({ 
  group, 
  onEditSession, 
  onCancelSession, 
  onCompleteSession 
}: RecurringSessionCardProps) {
  const [isExpanded, setIsExpanded] = useState(false);

  const getStatusBadge = (status: string) => {
    const statusMap = {
      'agendado': { label: 'Agendado', variant: 'default' as const, color: 'bg-blue-100 text-blue-800 border-blue-200' },
      'scheduled': { label: 'Agendado', variant: 'default' as const, color: 'bg-blue-100 text-blue-800 border-blue-200' },
      'completed': { label: 'Concluído', variant: 'secondary' as const, color: 'bg-green-100 text-green-800 border-green-200' },
      'concluído': { label: 'Concluído', variant: 'secondary' as const, color: 'bg-green-100 text-green-800 border-green-200' },
      'cancelled': { label: 'Cancelado', variant: 'destructive' as const, color: 'bg-red-100 text-red-800 border-red-200' },
      'cancelado': { label: 'Cancelado', variant: 'destructive' as const, color: 'bg-red-100 text-red-800 border-red-200' },
      'no-show': { label: 'Não compareceu', variant: 'outline' as const, color: 'bg-orange-100 text-orange-800 border-orange-200' }
    };
    
    const statusInfo = statusMap[status as keyof typeof statusMap] || statusMap.agendado;
    return (
      <Badge className={`text-xs ${statusInfo.color}`}>
        {statusInfo.label}
      </Badge>
    );
  };

  const getSourceColor = (source: string) => {
    return source === 'Favale' 
      ? 'bg-blue-50 text-blue-600 border-blue-200' 
      : source === 'Pink'
      ? 'bg-pink-50 text-pink-600 border-pink-200'
      : 'bg-purple-50 text-purple-600 border-purple-200';
  };

  // Estatísticas do grupo
  const totalSessions = group.sessions.length;
  const completedSessions = group.sessions.filter(s => s.status === 'completed' || s.status === 'concluído').length;
  const upcomingSessions = group.sessions.filter(s => 
    new Date(s.startTime) > new Date() && (s.status === 'scheduled' || s.status === 'agendado')
  ).length;

  return (
    <Card className="border-l-4 border-l-blue-500 hover:shadow-md transition-shadow">
      <Collapsible open={isExpanded} onOpenChange={setIsExpanded}>
        <CollapsibleTrigger asChild>
          <div className="cursor-pointer">
            <CardContent className="p-4">
              <div className="flex items-start justify-between">
                <div className="flex-1 space-y-3">
                  {/* Header */}
                  <div className="flex items-center gap-3">
                    <div className="flex items-center gap-1">
                      {isExpanded ? (
                        <ChevronDown className="h-4 w-4 text-gray-500" />
                      ) : (
                        <ChevronRight className="h-4 w-4 text-gray-500" />
                      )}
                      <Repeat className="h-4 w-4 text-blue-500" />
                    </div>
                    
                    <div>
                      <h3 className="font-medium text-gray-900 dark:text-white">
                        {group.studentName}
                      </h3>
                      <p className="text-sm text-gray-600 dark:text-gray-400">
                        {group.pattern} • {group.timeSlot}
                      </p>
                    </div>

                    <Badge variant="outline" className={`ml-auto ${getSourceColor(group.source)}`}>
                      {group.source}
                    </Badge>
                  </div>

                  {/* Info Cards */}
                  <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3">
                    <div className="flex items-center gap-2 text-sm text-gray-600 dark:text-gray-300">
                      <User className="h-4 w-4 flex-shrink-0" />
                      <span className="truncate">Prof. {group.trainerName}</span>
                    </div>
                    
                    <div className="flex items-center gap-2 text-sm text-gray-600 dark:text-gray-300">
                      <MapPin className="h-4 w-4 flex-shrink-0" />
                      <span className="truncate">{group.location}</span>
                    </div>

                    <div className="flex items-center gap-2 text-sm text-gray-600 dark:text-gray-300 sm:col-span-2 lg:col-span-1">
                      <Calendar className="h-4 w-4 flex-shrink-0" />
                      <span>{totalSessions} sessões</span>
                    </div>
                  </div>

                  {/* Statistics */}
                  <div className="flex flex-wrap gap-4 text-xs">
                    <span className="text-green-600 dark:text-green-400">
                      {completedSessions} concluídas
                    </span>
                    <span className="text-blue-600 dark:text-blue-400">
                      {upcomingSessions} próximas
                    </span>
                    {group.nextSession && (
                      <span className="text-orange-600 dark:text-orange-400">
                        Próxima: {format(new Date(group.nextSession.startTime), 'dd/MM', { locale: ptBR })}
                      </span>
                    )}
                  </div>
                </div>
              </div>
            </CardContent>
          </div>
        </CollapsibleTrigger>

        <CollapsibleContent>
          <div className="border-t border-gray-100 dark:border-gray-700">
            <div className="p-4 space-y-3">
              <h4 className="font-medium text-gray-900 dark:text-white flex items-center gap-2">
                <Calendar className="h-4 w-4" />
                Todas as Sessões ({totalSessions})
              </h4>
              
              <div className="space-y-2 max-h-64 overflow-y-auto">
                {group.sessions
                  .sort((a, b) => new Date(a.startTime).getTime() - new Date(b.startTime).getTime())
                  .map((session) => (
                    <div
                      key={session.id}
                      className="flex items-center justify-between p-3 bg-gray-50 dark:bg-gray-800/50 rounded-lg"
                    >
                      <div className="flex items-center gap-3">
                        <div className="text-sm">
                          <div className="font-medium text-gray-900 dark:text-white">
                            {format(new Date(session.startTime), 'EEEE, dd/MM/yyyy', { locale: ptBR })}
                          </div>
                          <div className="text-gray-600 dark:text-gray-400 flex items-center gap-1">
                            <Clock className="h-3 w-3" />
                            {format(new Date(session.startTime), 'HH:mm')} - {format(new Date(session.endTime), 'HH:mm')}
                          </div>
                        </div>
                      </div>

                      <div className="flex items-center gap-2">
                        {getStatusBadge(session.status)}
                        
                        <DropdownMenu>
                          <DropdownMenuTrigger asChild>
                            <Button variant="ghost" size="sm" className="h-8 w-8 p-0">
                              <MoreVertical className="h-4 w-4" />
                            </Button>
                          </DropdownMenuTrigger>
                          <DropdownMenuContent align="end">
                            {onEditSession && (
                              <DropdownMenuItem onClick={() => onEditSession(session)}>
                                Editar
                              </DropdownMenuItem>
                            )}
                            {session.status === 'agendado' || session.status === 'scheduled' ? (
                              <>
                                {onCompleteSession && (
                                  <DropdownMenuItem onClick={() => onCompleteSession(session.id)}>
                                    Marcar como Concluída
                                  </DropdownMenuItem>
                                )}
                                {onCancelSession && (
                                  <DropdownMenuItem 
                                    onClick={() => onCancelSession(session.id)}
                                    className="text-red-600"
                                  >
                                    Cancelar
                                  </DropdownMenuItem>
                                )}
                              </>
                            ) : null}
                          </DropdownMenuContent>
                        </DropdownMenu>
                      </div>
                    </div>
                  ))}
              </div>
            </div>
          </div>
        </CollapsibleContent>
      </Collapsible>
    </Card>
  );
}
</file>

<file path="client/src/components/scheduling/RecurringSessionGroup.tsx">
import React, { useState } from 'react';
import { format, isSameDay, startOfWeek, addDays } from 'date-fns';
import { ptBR } from 'date-fns/locale';
import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
} from '@/components/ui/collapsible';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { 
  ChevronDown, 
  ChevronRight, 
  Repeat, 
  Calendar,
  Clock,
  User,
  MapPin
} from 'lucide-react';
import { cn } from '@/lib/utils';

type SessionStatus = 'scheduled' | 'completed' | 'cancelled' | 'no-show';

interface Session {
  id: number;
  startTime: string;
  endTime: string;
  location: string;
  source: 'Favale' | 'Pink' | 'FavalePink';
  notes?: string;
  status: SessionStatus;
  leadId: number;
  trainerId: number;
  value?: number;
  service?: string;
}

interface RecurringGroup {
  pattern: string;
  sessions: Session[];
  studentName: string;
  trainerName: string;
  source: 'Favale' | 'Pink' | 'FavalePink';
  location: string;
  timeSlot: string;
  nextSession?: Session;
}

interface RecurringSessionGroupProps {
  group: RecurringGroup;
  onSessionClick: (session: Session) => void;
  getStudentName: (leadId: number) => string;
  getTrainerName: (trainerId: number) => string;
}

function getStatusBadgeVariant(status: SessionStatus) {
  switch (status) {
    case 'scheduled':
      return 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-300';
    case 'completed':
      return 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-300';
    case 'cancelled':
      return 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-300';
    case 'no-show':
      return 'bg-amber-100 text-amber-800 dark:bg-amber-900 dark:text-amber-300';
    default:
      return 'bg-gray-100 text-gray-800 dark:bg-gray-800 dark:text-gray-300';
  }
}

function getStatusText(status: SessionStatus): string {
  switch (status) {
    case 'scheduled':
      return 'Agendada';
    case 'completed':
      return 'Concluída';
    case 'cancelled':
      return 'Cancelada';
    case 'no-show':
      return 'Não Compareceu';
    default:
      return status;
  }
}

export function RecurringSessionGroup({ 
  group, 
  onSessionClick, 
  getStudentName, 
  getTrainerName 
}: RecurringSessionGroupProps) {
  const [isOpen, setIsOpen] = useState(false);
  
  const upcomingSessions = group.sessions.filter(s => 
    new Date(s.startTime) > new Date() && s.status === 'scheduled'
  ).length;

  const completedSessions = group.sessions.filter(s => 
    s.status === 'completed'
  ).length;

  const nextSession = group.sessions
    .filter(s => new Date(s.startTime) > new Date() && s.status === 'scheduled')
    .sort((a, b) => new Date(a.startTime).getTime() - new Date(b.startTime).getTime())[0];

  return (
    <Collapsible open={isOpen} onOpenChange={setIsOpen}>
      <div className="border rounded-lg bg-white dark:bg-gray-800 shadow-sm hover:shadow-md transition-shadow">
        <CollapsibleTrigger asChild>
          <div className="p-4 cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-700/50 rounded-t-lg">
            <div className="flex items-center justify-between">
              <div className="flex items-center space-x-3">
                <div className="flex items-center space-x-2">
                  {isOpen ? (
                    <ChevronDown className="h-4 w-4 text-gray-500" />
                  ) : (
                    <ChevronRight className="h-4 w-4 text-gray-500" />
                  )}
                  <Repeat className="h-4 w-4 text-blue-600" />
                  <Badge variant="outline" className="bg-blue-50 text-blue-700 border-blue-200">
                    Recorrente
                  </Badge>
                </div>
              </div>
              
              <div className="flex items-center space-x-2">
                <Badge 
                  variant="outline" 
                  className={group.source === 'Favale' ? 
                    'bg-blue-50 text-blue-700 border-blue-200' : 
                    'bg-pink-50 text-pink-700 border-pink-200'}
                >
                  {group.source}
                </Badge>
                <span className="text-sm text-gray-500">
                  {upcomingSessions} próximas • {completedSessions} concluídas
                </span>
              </div>
            </div>

            <div className="mt-3 space-y-2">
              <div className="flex items-center space-x-4">
                <div className="flex items-center space-x-2">
                  <User className="h-4 w-4 text-gray-500" />
                  <span className="font-medium">{getStudentName(group.sessions[0].leadId)}</span>
                </div>
                <div className="flex items-center space-x-2">
                  <span className="text-gray-400">com</span>
                  <span className="text-gray-700 dark:text-gray-300">{getTrainerName(group.sessions[0].trainerId)}</span>
                </div>
              </div>

              <div className="flex items-center space-x-4 text-sm text-gray-600 dark:text-gray-400">
                <div className="flex items-center space-x-1">
                  <Clock className="h-3 w-3" />
                  <span>{group.timeSlot}</span>
                </div>
                <div className="flex items-center space-x-1">
                  <MapPin className="h-3 w-3" />
                  <span>{group.location}</span>
                </div>
                <div className="flex items-center space-x-1">
                  <Calendar className="h-3 w-3" />
                  <span>{group.pattern}</span>
                </div>
              </div>

              {nextSession && (
                <div className="mt-2 p-2 bg-blue-50 dark:bg-blue-900/20 rounded-md">
                  <div className="flex items-center justify-between">
                    <span className="text-sm font-medium text-blue-800 dark:text-blue-300">
                      Próxima sessão: {format(new Date(nextSession.startTime), "dd 'de' MMMM 'às' HH:mm", { locale: ptBR })}
                    </span>
                    <Button
                      size="sm"
                      variant="ghost"
                      className="text-blue-700 hover:text-blue-800 h-6 px-2"
                      onClick={(e) => {
                        e.stopPropagation();
                        onSessionClick(nextSession);
                      }}
                    >
                      Ver detalhes
                    </Button>
                  </div>
                </div>
              )}
            </div>
          </div>
        </CollapsibleTrigger>

        <CollapsibleContent>
          <div className="border-t bg-gray-50 dark:bg-gray-800/50">
            <div className="p-4">
              <h4 className="font-medium text-gray-900 dark:text-white mb-3">
                Todas as sessões ({group.sessions.length})
              </h4>
              <div className="space-y-2 max-h-64 overflow-y-auto">
                {group.sessions
                  .sort((a, b) => new Date(a.startTime).getTime() - new Date(b.startTime).getTime())
                  .map((session) => (
                    <div
                      key={session.id}
                      className="flex items-center justify-between p-3 bg-white dark:bg-gray-800 rounded-md border cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-700/50"
                      onClick={() => onSessionClick(session)}
                    >
                      <div className="flex items-center space-x-3">
                        <div>
                          <div className="font-medium text-sm">
                            {format(new Date(session.startTime), "dd 'de' MMMM", { locale: ptBR })}
                          </div>
                          <div className="text-xs text-gray-500">
                            {format(new Date(session.startTime), 'HH:mm', { locale: ptBR })} - 
                            {format(new Date(session.endTime), 'HH:mm', { locale: ptBR })}
                          </div>
                        </div>
                      </div>
                      <Badge variant="outline" className={getStatusBadgeVariant(session.status)}>
                        {getStatusText(session.status)}
                      </Badge>
                    </div>
                  ))}
              </div>
            </div>
          </div>
        </CollapsibleContent>
      </div>
    </Collapsible>
  );
}
</file>

<file path="client/src/components/scheduling/SessionCalendar.tsx">
import { useState, useEffect } from 'react';
import { Calendar as CalendarComponent } from '@/components/ui/calendar';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription } from '@/components/ui/dialog';
import { NewSessionForm } from './NewSessionForm';
import { format, addDays, setHours, setMinutes, isSameDay, parseISO } from 'date-fns';
import { ptBR } from 'date-fns/locale';
import { CalendarIcon, Plus, Clock, MapPin, User, ArrowLeft } from 'lucide-react';
import { useToast } from '@/hooks/use-toast';
import { Avatar } from '@/components/ui/avatar';
import { Skeleton } from '@/components/ui/skeleton';
import { Link } from 'wouter';
import { useQuery, useQueryClient } from '@tanstack/react-query';

type SessionStatus = 'scheduled' | 'completed' | 'cancelled' | 'no-show';

interface Session {
  id: number;
  startTime: string;
  endTime: string;
  location: string;
  source: 'Favale' | 'Pink' | 'FavalePink';
  notes?: string;
  status: SessionStatus;
  leadId: number;
  trainerId: number;
  value?: number;
  service?: string;
}

export function SessionCalendar() {
  const [date, setDate] = useState<Date>(new Date());
  const [dialogOpen, setDialogOpen] = useState(false);
  const [detailsDialogOpen, setDetailsDialogOpen] = useState(false);
  const [selectedSession, setSelectedSession] = useState<Session | null>(null);
  const { toast } = useToast();
  const queryClient = useQueryClient();
  
  // Fetch sessions from API
  const { data: sessions = [], isLoading, error } = useQuery({
    queryKey: ['/api/sessions'],
    queryFn: () => fetch('/api/sessions').then(res => res.json())
  });

  // Fetch leads for student names
  const { data: leads = [] } = useQuery({
    queryKey: ['/api/leads'],
    queryFn: () => fetch('/api/leads').then(res => res.json())
  });

  // Fetch trainers for trainer names
  const { data: trainers = [] } = useQuery({
    queryKey: ['/api/trainers'],
    queryFn: () => fetch('/api/trainers').then(res => res.json())
  });

  // Helper function to get student name by leadId
  const getStudentName = (leadId: number) => {
    const lead = leads.find((l: any) => l.id === leadId);
    return lead?.name || 'Estudante';
  };

  // Helper function to get trainer name by trainerId
  const getTrainerName = (trainerId: number) => {
    const trainer = trainers.find((t: any) => t.id === trainerId);
    return trainer?.name || 'Professor';
  };

  // Filtrar sessões para o dia selecionado
  const sessionsForSelectedDay = sessions.filter((session: Session) => 
    isSameDay(new Date(session.startTime), date)
  );

  const handleAddSession = () => {
    setDialogOpen(true);
  };

  const handleSessionClick = (session: Session) => {
    setSelectedSession(session);
    setDetailsDialogOpen(true);
  };

  const getStatusBadge = (status: SessionStatus) => {
    switch(status) {
      case 'scheduled':
        return <Badge variant="outline" className="bg-blue-50 text-blue-600 border-blue-200">Agendado</Badge>;
      case 'completed':
        return <Badge variant="outline" className="bg-green-50 text-green-600 border-green-200">Concluído</Badge>;
      case 'cancelled':
        return <Badge variant="outline" className="bg-red-50 text-red-600 border-red-200">Cancelado</Badge>;
      case 'no-show':
        return <Badge variant="outline" className="bg-amber-50 text-amber-600 border-amber-200">Não Compareceu</Badge>;
      default:
        return null;
    }
  };

  return (
    <div className="space-y-4 animate-in fade-in-50 duration-300">
      <div className="flex items-center justify-between mb-4">
        <Link href="/agendamentos">
          <Button variant="ghost" className="flex items-center gap-2 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 transition-colors">
            <ArrowLeft className="h-4 w-4" />
            Voltar para Agendamentos
          </Button>
        </Link>
        
        <Button onClick={handleAddSession} className="bg-[#ff9810] hover:bg-[#ff9810]/90 text-white shadow-sm">
          <Plus className="h-4 w-4 mr-2" />
          Nova Sessão
        </Button>
      </div>
      
      <div className="grid grid-cols-1 lg:grid-cols-12 gap-6">
        {/* Coluna do calendário */}
        <div className="lg:col-span-4">
          <div className="bg-white dark:bg-gray-800 rounded-xl border border-gray-100 dark:border-gray-700 shadow-sm p-4">
            <h3 className="text-lg font-medium mb-4 text-gray-800 dark:text-white">Calendário</h3>
            
            <CalendarComponent
              mode="single"
              selected={date}
              onSelect={(date) => setDate(date || new Date())}
              className="rounded-md w-full"
              locale={ptBR}
              showOutsideDays={true}
              modifiers={{
                highlighted: (date) => date && sessions.some(session => 
                  isSameDay(new Date(session.startTime), date)
                ),
              }}
              modifiersClassNames={{
                today: 'bg-[#ff9810]/10 text-[#ff9810] font-semibold',
                highlighted: 'font-bold bg-gray-50 dark:bg-gray-700/30',
              }}
              classNames={{
                day_selected: 'bg-[#ff9810] text-white hover:bg-[#ff9810]/90 focus:bg-[#ff9810]',
                day_today: 'bg-[#ff9810]/10 text-[#ff9810] font-semibold',
              }}
            />

            <div className="mt-6 space-y-4">
              <h4 className="text-sm font-medium text-gray-700 dark:text-gray-300">Origem das Sessões</h4>
              <div className="flex flex-col space-y-2">
                <div className="flex items-center gap-2">
                  <div className="w-3 h-3 rounded-full bg-blue-500"></div>
                  <span className="text-sm text-gray-600 dark:text-gray-400">Favale</span>
                </div>
                <div className="flex items-center gap-2">
                  <div className="w-3 h-3 rounded-full bg-pink-500"></div>
                  <span className="text-sm text-gray-600 dark:text-gray-400">Pink</span>
                </div>
              </div>
              
              <div className="mt-4 pt-4 border-t border-gray-100 dark:border-gray-700">
                <Button onClick={handleAddSession} className="w-full bg-[#ff9810]/10 hover:bg-[#ff9810]/20 text-[#ff9810]">
                  <Plus className="h-4 w-4 mr-2" />
                  Agendar para {format(date, "dd 'de' MMMM", { locale: ptBR })}
                </Button>
              </div>
            </div>
          </div>
        </div>
        
        {/* Coluna de detalhes da data selecionada */}
        <div className="lg:col-span-8">
          <div className="bg-white dark:bg-gray-800 border border-gray-100 dark:border-gray-700 rounded-xl shadow-sm flex flex-col h-full overflow-hidden">
            {/* Cabeçalho do painel */}
            <div className="border-b border-gray-100 dark:border-gray-700 p-4 bg-gray-50/80 dark:bg-gray-800/40">
              <div className="flex justify-between items-center">
                <div className="flex items-center">
                  <CalendarIcon className="h-5 w-5 mr-2 text-[#ff9810]" />
                  <h3 className="text-lg font-medium text-gray-800 dark:text-white">
                    {format(date, "EEEE, dd 'de' MMMM 'de' yyyy", { locale: ptBR })}
                  </h3>
                </div>
                <Badge variant="secondary" className="rounded-full font-medium px-3 py-1">
                  {isLoading ? "..." : sessionsForSelectedDay.length} sessões
                </Badge>
              </div>
            </div>
            
            {/* Conteúdo do painel */}
            <div className="flex-1 p-4 overflow-y-auto">
              {isLoading ? (
                <div className="space-y-4">
                  <Skeleton className="h-24 w-full" />
                  <Skeleton className="h-24 w-full" />
                  <Skeleton className="h-24 w-full" />
                </div>
              ) : sessionsForSelectedDay.length === 0 ? (
                <div className="h-full flex flex-col justify-center items-center py-12 text-muted-foreground">
                  <div className="p-4 rounded-full bg-gray-50 dark:bg-gray-700/30 mb-4">
                    <CalendarIcon className="h-8 w-8 text-gray-400 dark:text-gray-500" />
                  </div>
                  <p className="text-gray-500 dark:text-gray-400 mb-2">Não há sessões agendadas para esta data.</p>
                  <Button variant="outline" onClick={handleAddSession} className="mt-4">
                    <Plus className="h-4 w-4 mr-2" />
                    Agendar Sessão
                  </Button>
                </div>
              ) : (
                <div className="space-y-4">
                  {sessionsForSelectedDay.map((session) => (
                    <div key={session.id} 
                      onClick={() => handleSessionClick(session)}
                      className={`bg-white dark:bg-gray-800 border border-gray-100 dark:border-gray-700 ${session.source === 'Favale' ? 'border-l-blue-500' : 'border-l-pink-500'} border-l-4 rounded-lg p-4 shadow-sm hover:shadow-md transition-all duration-200 cursor-pointer`}
                    >
                      <div className="flex justify-between">
                        <div className="flex-1">
                          <div className="flex items-center gap-3 mb-2">
                            <Clock className="h-4 w-4 text-gray-400" />
                            <p className="font-medium text-gray-800 dark:text-white">
                              {format(new Date(session.startTime), 'HH:mm', { locale: ptBR })} - 
                              {format(new Date(session.endTime), 'HH:mm', { locale: ptBR })}
                            </p>
                            {getStatusBadge(session.status)}
                          </div>
                          
                          <div className="flex items-center gap-2 mb-2">
                            <Avatar className="h-6 w-6 bg-gray-200">
                              <div className="text-xs">{getStudentName(session.leadId).charAt(0)}</div>
                            </Avatar>
                            <p className="text-gray-700 dark:text-gray-300">
                              {getStudentName(session.leadId)} com <span className="font-medium">{getTrainerName(session.trainerId)}</span>
                            </p>
                          </div>
                          
                          <div className="flex items-center gap-3 text-sm text-gray-500 dark:text-gray-400 mt-2">
                            <MapPin className="h-3.5 w-3.5" />
                            <span>{session.location}</span>
                          </div>
                        </div>
                        
                        <Badge 
                          variant="outline" 
                          className={session.source === 'Favale' ? 
                            'bg-blue-50 text-blue-700 border-blue-200 dark:bg-blue-900/20 dark:text-blue-300 dark:border-blue-700/40 h-fit' : 
                            'bg-pink-50 text-pink-700 border-pink-200 dark:bg-pink-900/20 dark:text-pink-300 dark:border-pink-700/40 h-fit'}
                        >
                          {session.source}
                        </Badge>
                      </div>
                    </div>
                  ))}
                </div>
              )}
            </div>
          </div>
        </div>
      </div>

      {/* Dialog para adicionar nova sessão */}
      <Dialog open={dialogOpen} onOpenChange={setDialogOpen}>
        <DialogContent className="sm:max-w-[650px] bg-white dark:bg-gray-800 border-gray-100 dark:border-gray-700 rounded-xl">
          <DialogHeader>
            <DialogTitle className="text-xl font-semibold text-gray-800 dark:text-white">
              Agendar Nova Sessão
            </DialogTitle>
            <DialogDescription className="text-gray-500 dark:text-gray-400">
              Preencha os dados para agendar uma nova sessão.
            </DialogDescription>
          </DialogHeader>
          <NewSessionForm 
            defaultValues={{ date: date, startTime: '09:00', endTime: '10:00' }}
            onSuccess={() => {
              setDialogOpen(false);
              toast({
                title: 'Sessão agendada',
                description: 'A sessão foi agendada com sucesso!',
              });
            }} 
          />
        </DialogContent>
      </Dialog>

      {/* Dialog para exibir detalhes da sessão */}
      {selectedSession && (
        <Dialog open={detailsDialogOpen} onOpenChange={setDetailsDialogOpen}>
          <DialogContent className="sm:max-w-[500px] bg-white dark:bg-gray-800 border-gray-100 dark:border-gray-700 rounded-xl">
            <DialogHeader>
              <DialogTitle className="text-xl font-semibold text-gray-800 dark:text-white flex items-center gap-2">
                <span className={`inline-block w-3 h-3 rounded-full ${selectedSession.source === 'Favale' ? 'bg-blue-500' : 'bg-pink-500'}`}></span>
                Detalhes da Sessão
              </DialogTitle>
            </DialogHeader>

            <div className="space-y-5 py-2">
              <div className="flex justify-between items-start">
                <div>
                  <p className="text-gray-500 dark:text-gray-400 text-sm">Data e Horário</p>
                  <p className="font-medium text-gray-800 dark:text-white">
                    {format(new Date(selectedSession.startTime), "dd 'de' MMMM, yyyy", { locale: ptBR })}
                  </p>
                  <p className="text-gray-800 dark:text-white">
                    {format(new Date(selectedSession.startTime), 'HH:mm', { locale: ptBR })} - 
                    {format(new Date(selectedSession.endTime), 'HH:mm', { locale: ptBR })}
                  </p>
                </div>
                {getStatusBadge(selectedSession.status)}
              </div>

              <div className="p-4 bg-gray-50 dark:bg-gray-700/30 rounded-lg space-y-4">
                <div>
                  <p className="text-gray-500 dark:text-gray-400 text-sm">Aluno</p>
                  <div className="flex items-center gap-2 mt-1">
                    <Avatar className="h-8 w-8 bg-gray-200">
                      <div className="text-xs">{getStudentName(selectedSession.leadId).charAt(0)}</div>
                    </Avatar>
                    <p className="font-medium text-gray-800 dark:text-white">{getStudentName(selectedSession.leadId)}</p>
                  </div>
                </div>

                <div>
                  <p className="text-gray-500 dark:text-gray-400 text-sm">Professor</p>
                  <div className="flex items-center gap-2 mt-1">
                    <Avatar className="h-8 w-8 bg-gray-200">
                      <div className="text-xs">{getTrainerName(selectedSession.trainerId).charAt(0)}</div>
                    </Avatar>
                    <p className="font-medium text-gray-800 dark:text-white">{getTrainerName(selectedSession.trainerId)}</p>
                  </div>
                </div>
              </div>

              <div>
                <p className="text-gray-500 dark:text-gray-400 text-sm">Local</p>
                <p className="font-medium text-gray-800 dark:text-white">{selectedSession.location}</p>
              </div>

              {selectedSession.notes && (
                <div>
                  <p className="text-gray-500 dark:text-gray-400 text-sm">Observações</p>
                  <p className="text-gray-800 dark:text-white">{selectedSession.notes}</p>
                </div>
              )}

              <div className="flex justify-between pt-4 border-t border-gray-100 dark:border-gray-700">
                <Button variant="outline" onClick={() => setDetailsDialogOpen(false)}>
                  Fechar
                </Button>
                <div className="flex gap-2">
                  <Button variant="outline" className="border-amber-300 bg-amber-50 hover:bg-amber-100 text-amber-700">
                    Editar
                  </Button>
                  <Button variant="outline" className="border-red-300 bg-red-50 hover:bg-red-100 text-red-700">
                    Cancelar Sessão
                  </Button>
                </div>
              </div>
            </div>
          </DialogContent>
        </Dialog>
      )}
    </div>
  );
}
</file>

<file path="client/src/components/scheduling/SessionDetails.tsx">
import { format } from 'date-fns';
import { ptBR } from 'date-fns/locale';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle } from '@/components/ui/alert-dialog';
import { CalendarIcon, Clock, FileEdit, MapPin, User, X } from 'lucide-react';
import { useState } from 'react';
import { useQuery } from '@tanstack/react-query';

type SessionStatus = 'scheduled' | 'completed' | 'cancelled' | 'no-show';

interface Session {
  id: number;
  startTime: string;
  endTime: string;
  location: string;
  source: 'Favale' | 'Pink' | 'FavalePink';
  notes?: string;
  status: SessionStatus;
  leadId: number;
  trainerId: number;
  value?: number;
  service?: string;
}

interface SessionDetailsProps {
  session: Session;
  onCancelSession: (id: number) => void;
  onCompleteSession: (id: number) => void;
  onEditSession: (id: number) => void;
}

export function SessionDetails({ session, onCancelSession, onCompleteSession, onEditSession }: SessionDetailsProps) {
  const [cancelAlertOpen, setCancelAlertOpen] = useState(false);
  
  // Fetch leads for student names
  const { data: leads = [] } = useQuery({
    queryKey: ['/api/leads'],
    queryFn: () => fetch('/api/leads').then(res => res.json())
  });

  // Fetch trainers for trainer names
  const { data: trainers = [] } = useQuery({
    queryKey: ['/api/trainers'],
    queryFn: () => fetch('/api/trainers').then(res => res.json())
  });

  // Helper functions to get names from IDs
  const getStudentName = (leadId: number) => {
    const lead = leads.find((l: any) => l.id === leadId);
    return lead?.name || 'Estudante';
  };

  const getTrainerName = (trainerId: number) => {
    const trainer = trainers.find((t: any) => t.id === trainerId);
    return trainer?.name || 'Professor';
  };
  
  function getStatusClass(status: SessionStatus): string {
    switch (status) {
      case 'scheduled':
        return 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-300';
      case 'completed':
        return 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-300';
      case 'cancelled':
        return 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-300';
      case 'no-show':
        return 'bg-amber-100 text-amber-800 dark:bg-amber-900 dark:text-amber-300';
      default:
        return 'bg-gray-100 text-gray-800 dark:bg-gray-800 dark:text-gray-300';
    }
  }

  function getStatusText(status: SessionStatus): string {
    switch (status) {
      case 'scheduled':
        return 'Agendada';
      case 'completed':
        return 'Concluída';
      case 'cancelled':
        return 'Cancelada';
      case 'no-show':
        return 'Não Compareceu';
      default:
        return status;
    }
  }

  return (
    <div className="space-y-6">
      {/* Cabeçalho com data e origem */}
      <div className="flex justify-between items-start">
        <div className="flex items-center gap-2">
          <CalendarIcon className="h-5 w-5 text-muted-foreground" />
          <h3 className="text-lg font-semibold">
            {format(new Date(session.startTime), "PPP", { locale: ptBR })}
          </h3>
        </div>
        
        <Badge 
          variant="outline" 
          className={session.source === 'Favale' ? 
            'bg-blue-50 text-blue-700 border-blue-300 dark:bg-blue-950 dark:text-blue-300 dark:border-blue-800' : 
            'bg-pink-50 text-pink-700 border-pink-300 dark:bg-pink-950 dark:text-pink-300 dark:border-pink-800'}
        >
          {session.source}
        </Badge>
      </div>
      
      {/* Status */}
      <div className="flex justify-between items-center">
        <span className="text-sm text-muted-foreground">Status:</span>
        <Badge variant="outline" className={getStatusClass(session.status)}>
          {getStatusText(session.status)}
        </Badge>
      </div>
      
      {/* Detalhes da sessão */}
      <div className="space-y-3 text-sm">
        <div className="flex items-center gap-2">
          <Clock className="h-4 w-4 text-muted-foreground" />
          <span>
            {format(new Date(session.startTime), 'HH:mm', { locale: ptBR })} - 
            {format(new Date(session.endTime), 'HH:mm', { locale: ptBR })}
          </span>
        </div>
        
        <div className="flex items-center gap-2">
          <User className="h-4 w-4 text-muted-foreground" />
          <span>
            <span className="font-medium">Aluno:</span> {getStudentName(session.leadId)}
          </span>
        </div>
        
        <div className="flex items-center gap-2">
          <User className="h-4 w-4 text-muted-foreground" />
          <span>
            <span className="font-medium">Professor:</span> {getTrainerName(session.trainerId)}
          </span>
        </div>
        
        <div className="flex items-start gap-2">
          <MapPin className="h-4 w-4 text-muted-foreground mt-0.5" />
          <span>
            <span className="font-medium">Local:</span> {session.location}
          </span>
        </div>
        
        {session.notes && (
          <div className="border rounded-md p-3 mt-2">
            <p className="font-medium mb-1">Observações:</p>
            <p className="text-muted-foreground">{session.notes}</p>
          </div>
        )}
      </div>
      
      {/* Botões de ação */}
      <div className="flex flex-col gap-2 pt-2">
        {session.status === 'scheduled' && (
          <>
            <Button variant="outline" onClick={() => onEditSession(session.id)}>
              <FileEdit className="h-4 w-4 mr-2" />
              Editar Sessão
            </Button>
            
            <Button variant="outline" onClick={() => onCompleteSession(session.id)}>
              Marcar como Concluída
            </Button>
            
            <Button variant="outline" className="text-red-500 hover:text-red-600" onClick={() => setCancelAlertOpen(true)}>
              <X className="h-4 w-4 mr-2" />
              Cancelar Sessão
            </Button>
          </>
        )}
      </div>
      
      {/* Alerta de confirmação para cancelamento */}
      <AlertDialog open={cancelAlertOpen} onOpenChange={setCancelAlertOpen}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Cancelar Sessão</AlertDialogTitle>
            <AlertDialogDescription>
              Você tem certeza que deseja cancelar esta sessão? Esta ação não pode ser desfeita.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Voltar</AlertDialogCancel>
            <AlertDialogAction onClick={() => onCancelSession(session.id)} className="bg-red-500 hover:bg-red-600">
              Sim, cancelar
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}
</file>

<file path="client/src/components/scheduling/SessionForm.tsx">
import { useState, useEffect } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { addMinutes, format } from 'date-fns';
import { ptBR } from 'date-fns/locale';
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from '@/components/ui/form';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';
import { Calendar } from '@/components/ui/calendar';
import { CalendarIcon, Loader2 } from 'lucide-react';
import { cn } from '@/lib/utils';
import { apiRequest } from '@/lib/queryClient';
import { useToast } from '@/hooks/use-toast';
import { useQuery } from '@tanstack/react-query';

// Schema para validação do formulário de sessão
const sessionFormSchema = z.object({
  date: z.date({
    required_error: "Uma data de sessão é obrigatória.",
  }),
  startTime: z.string({
    required_error: "O horário de início é obrigatório.",
  }),
  endTime: z.string({
    required_error: "O horário de término é obrigatório.",
  }),
  location: z.string().min(1, "O local é obrigatório."),
  source: z.enum(["Favale", "Pink"], {
    required_error: "A origem é obrigatória.",
  }),
  leadId: z.number().min(1, "Um aluno deve ser selecionado."),
  trainerId: z.number().min(1, "Um professor deve ser selecionado."),
  notes: z.string().optional(),
}).refine(data => {
  // Validar se o horário de fim é depois do horário de início
  const startDateTime = new Date(`${format(data.date, 'yyyy-MM-dd')}T${data.startTime}`);
  const endDateTime = new Date(`${format(data.date, 'yyyy-MM-dd')}T${data.endTime}`);
  return endDateTime > startDateTime;
}, {
  message: "O horário de término deve ser posterior ao horário de início.",
  path: ["endTime"],
});

type SessionFormValues = z.infer<typeof sessionFormSchema>;

type SessionFormProps = {
  defaultValues?: Partial<SessionFormValues>;
  sessionId?: number;
  onSuccess: () => void;
};

export function SessionForm({ defaultValues, sessionId, onSuccess }: SessionFormProps) {
  const [isLoading, setIsLoading] = useState(false);
  const { toast } = useToast();

  // Fetch leads for student selection
  const { data: leads = [] } = useQuery({
    queryKey: ['/api/leads'],
    queryFn: () => fetch('/api/leads').then(res => res.json())
  });

  // Fetch trainers for trainer selection
  const { data: trainers = [] } = useQuery({
    queryKey: ['/api/trainers'],
    queryFn: () => fetch('/api/trainers').then(res => res.json())
  });

  const form = useForm<SessionFormValues>({
    resolver: zodResolver(sessionFormSchema),
    defaultValues: {
      date: defaultValues?.date || new Date(),
      startTime: defaultValues?.startTime || '09:00',
      endTime: defaultValues?.endTime || '10:00',
      location: defaultValues?.location || '',
      source: defaultValues?.source || 'Favale',
      leadId: defaultValues?.leadId || 0,
      trainerId: defaultValues?.trainerId || 0,
      notes: defaultValues?.notes || '',
    },
  });

  const watchedSource = form.watch('source');

  // Filter students based on selected source
  const getFilteredStudents = () => {
    if (!watchedSource) return leads;
    
    // For this implementation, we'll show all leads regardless of source
    // In a real implementation, you might filter based on a source field in the leads
    return leads;
  };

  const onSubmit = async (values: SessionFormValues) => {
    setIsLoading(true);
    try {
      const sessionData = {
        startTime: new Date(`${format(values.date, 'yyyy-MM-dd')}T${values.startTime}`).toISOString(),
        endTime: new Date(`${format(values.date, 'yyyy-MM-dd')}T${values.endTime}`).toISOString(),
        location: values.location,
        source: values.source,
        leadId: values.leadId,
        trainerId: values.trainerId,
        notes: values.notes,
        status: 'scheduled'
      };

      if (sessionId) {
        // Update existing session
        const response = await fetch(`/api/sessions/${sessionId}`, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(sessionData),
        });
        
        if (!response.ok) {
          throw new Error('Erro ao atualizar sessão');
        }
        
        toast({
          title: 'Sessão atualizada',
          description: 'A sessão foi atualizada com sucesso.',
        });
      } else {
        // Create new session
        const response = await fetch('/api/sessions', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(sessionData),
        });
        
        if (!response.ok) {
          throw new Error('Erro ao criar sessão');
        }
        
        toast({
          title: 'Sessão criada',
          description: 'A sessão foi agendada com sucesso.',
        });
      }

      onSuccess();
    } catch (error) {
      console.error('Erro ao salvar sessão:', error);
      toast({
        title: 'Erro',
        description: 'Não foi possível salvar a sessão. Tente novamente.',
        variant: 'destructive',
      });
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          {/* Data */}
          <FormField
            control={form.control}
            name="date"
            render={({ field }) => (
              <FormItem className="flex flex-col">
                <FormLabel>Data da Sessão</FormLabel>
                <Popover>
                  <PopoverTrigger asChild>
                    <FormControl>
                      <Button
                        variant={"outline"}
                        className={cn(
                          "w-full pl-3 text-left font-normal",
                          !field.value && "text-muted-foreground"
                        )}
                      >
                        {field.value ? (
                          format(field.value, "PPP", { locale: ptBR })
                        ) : (
                          <span>Selecione uma data</span>
                        )}
                        <CalendarIcon className="ml-auto h-4 w-4 opacity-50" />
                      </Button>
                    </FormControl>
                  </PopoverTrigger>
                  <PopoverContent className="w-auto p-0" align="start">
                    <Calendar
                      mode="single"
                      selected={field.value}
                      onSelect={field.onChange}
                      disabled={(date) =>
                        date < new Date(new Date().setHours(0, 0, 0, 0))
                      }
                      initialFocus
                    />
                  </PopoverContent>
                </Popover>
                <FormMessage />
              </FormItem>
            )}
          />

          {/* Origem */}
          <FormField
            control={form.control}
            name="source"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Origem</FormLabel>
                <Select onValueChange={field.onChange} defaultValue={field.value}>
                  <FormControl>
                    <SelectTrigger>
                      <SelectValue placeholder="Selecione a origem" />
                    </SelectTrigger>
                  </FormControl>
                  <SelectContent>
                    <SelectItem value="Favale">Favale</SelectItem>
                    <SelectItem value="Pink">Pink</SelectItem>
                  </SelectContent>
                </Select>
                <FormMessage />
              </FormItem>
            )}
          />
        </div>

        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          {/* Horário de Início */}
          <FormField
            control={form.control}
            name="startTime"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Horário de Início</FormLabel>
                <FormControl>
                  <Input type="time" {...field} />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />

          {/* Horário de Término */}
          <FormField
            control={form.control}
            name="endTime"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Horário de Término</FormLabel>
                <FormControl>
                  <Input type="time" {...field} />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />
        </div>

        {/* Aluno */}
        <FormField
          control={form.control}
          name="leadId"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Aluno</FormLabel>
              <Select onValueChange={(value) => field.onChange(parseInt(value))} value={field.value?.toString()}>
                <FormControl>
                  <SelectTrigger>
                    <SelectValue placeholder="Selecione um aluno" />
                  </SelectTrigger>
                </FormControl>
                <SelectContent>
                  {getFilteredStudents().map((student: any) => (
                    <SelectItem key={student.id} value={student.id.toString()}>
                      {student.name}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
              <FormMessage />
            </FormItem>
          )}
        />

        {/* Professor */}
        <FormField
          control={form.control}
          name="trainerId"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Professor</FormLabel>
              <Select onValueChange={(value) => field.onChange(parseInt(value))} value={field.value?.toString()}>
                <FormControl>
                  <SelectTrigger>
                    <SelectValue placeholder="Selecione um professor" />
                  </SelectTrigger>
                </FormControl>
                <SelectContent>
                  {trainers.map((trainer: any) => (
                    <SelectItem key={trainer.id} value={trainer.id.toString()}>
                      {trainer.name}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
              <FormMessage />
            </FormItem>
          )}
        />

        {/* Local */}
        <FormField
          control={form.control}
          name="location"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Local</FormLabel>
              <FormControl>
                <Input placeholder="Ex: Academia Favale" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        {/* Observações */}
        <FormField
          control={form.control}
          name="notes"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Observações (Opcional)</FormLabel>
              <FormControl>
                <Textarea placeholder="Adicione observações sobre a sessão..." {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <div className="flex gap-3 pt-4">
          <Button type="submit" disabled={isLoading} className="flex-1">
            {isLoading && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
            {sessionId ? 'Atualizar Sessão' : 'Agendar Sessão'}
          </Button>
        </div>
      </form>
    </Form>
  );
}
</file>

<file path="client/src/components/scheduling/SessionManagement.tsx">
import { useState } from 'react';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { SessionTable } from './SessionTable';
import { NewSessionForm } from './NewSessionForm';
import { SessionReport } from './SessionReport';
import { Plus, Calendar, RefreshCw } from 'lucide-react';
import { useToast } from '@/hooks/use-toast';
import { Link } from 'wouter';
import { Skeleton } from '@/components/ui/skeleton';
import { useQuery, useQueryClient } from '@tanstack/react-query';

type SessionStatus = 'scheduled' | 'completed' | 'cancelled' | 'no-show';

interface Session {
  id: number;
  startTime: string;
  endTime: string;
  location: string;
  source: 'Favale' | 'Pink' | 'FavalePink';
  notes?: string;
  status: SessionStatus;
  leadId: number;
  trainerId: number;
  value?: number;
  service?: string;
}

export function SessionManagement() {
  const [formDialogOpen, setFormDialogOpen] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const { toast } = useToast();
  const queryClient = useQueryClient();
  
  // Fetch sessions from API
  const { data: sessions = [], isLoading, error, refetch } = useQuery({
    queryKey: ['/api/sessions'],
    queryFn: () => fetch('/api/sessions').then(res => res.json())
  });

  // Fetch leads for the form
  const { data: leads = [] } = useQuery({
    queryKey: ['/api/leads'],
    queryFn: () => fetch('/api/leads').then(res => res.json())
  });

  // Fetch trainers for the form
  const { data: trainers = [] } = useQuery({
    queryKey: ['/api/trainers'],
    queryFn: () => fetch('/api/trainers').then(res => res.json())
  });

  // Refresh sessions function
  const refreshSessions = async () => {
    try {
      await refetch();
      toast({
        title: 'Dados atualizados',
        description: 'As sessões foram atualizadas com sucesso.',
      });
    } catch (error) {
      toast({
        title: 'Erro ao atualizar',
        description: 'Não foi possível atualizar as sessões.',
        variant: 'destructive'
      });
    }
  };

  const handleFormSubmit = async (formData: any) => {
    setIsSubmitting(true);
    try {
      // Combine date and time into proper DateTime objects
      const startDateTime = new Date(`${formData.date.toISOString().split('T')[0]}T${formData.startTime}:00`);
      const endDateTime = new Date(`${formData.date.toISOString().split('T')[0]}T${formData.endTime}:00`);

      const sessionData = {
        startTime: startDateTime.toISOString(),
        endTime: endDateTime.toISOString(),
        leadId: formData.leadId,
        trainerId: formData.trainerId,
        location: formData.location,
        source: formData.source,
        value: formData.value,
        service: formData.service,
        notes: formData.notes || '',
        status: 'agendado',
        recurrenceType: formData.recurrenceType,
        recurrenceInterval: formData.recurrenceInterval,
        recurrenceWeekDays: formData.recurrenceWeekDays,
        recurrenceEndType: formData.recurrenceEndType,
        recurrenceEndDate: formData.recurrenceEndDate?.toISOString(),
        recurrenceEndCount: formData.recurrenceEndCount,
      };

      const response = await fetch('/api/sessions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(sessionData),
      });

      if (!response.ok) {
        throw new Error('Erro ao criar sessão');
      }

      const result = await response.json();
      
      setFormDialogOpen(false);
      queryClient.invalidateQueries({ queryKey: ['/api/sessions'] });
      
      toast({
        title: 'Sessão criada com sucesso',
        description: result.recurring 
          ? `${result.count} sessões foram agendadas com base na recorrência configurada.`
          : 'A sessão foi agendada com sucesso.',
      });
    } catch (error) {
      toast({
        title: 'Erro ao agendar',
        description: 'Não foi possível agendar a sessão. Tente novamente.',
        variant: 'destructive'
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleFormCancel = () => {
    setFormDialogOpen(false);
  };

  return (
    <div className="space-y-4 animate-in fade-in-50 duration-300">
      <Tabs defaultValue="sessions" className="space-y-4">
        <div className="flex flex-col lg:flex-row lg:justify-between lg:items-center gap-4">
          <TabsList className="bg-background border dark:bg-gray-800/60 shadow-sm w-full sm:w-auto">
            <TabsTrigger value="sessions" className="text-sm data-[state=active]:bg-white dark:data-[state=active]:bg-gray-700 rounded-md flex-1 sm:flex-none">
              Agendamentos
            </TabsTrigger>
            <TabsTrigger value="reports" className="text-sm data-[state=active]:bg-white dark:data-[state=active]:bg-gray-700 rounded-md flex-1 sm:flex-none">
              Relatórios
            </TabsTrigger>
          </TabsList>
          
          <div className="flex flex-col sm:flex-row gap-2 w-full sm:w-auto">
            <Button 
              variant="outline" 
              size="sm"
              onClick={refreshSessions}
              disabled={isLoading}
              className="text-gray-600 dark:text-gray-300 w-full sm:w-auto"
            >
              <RefreshCw className={`h-4 w-4 mr-1 ${isLoading ? 'animate-spin' : ''}`} />
              <span className="hidden sm:inline">Atualizar</span>
              <span className="sm:hidden">Atualizar</span>
            </Button>
            
            <Button 
              onClick={() => setFormDialogOpen(true)} 
              className="bg-[#ff9810] hover:bg-[#ff9810]/90 text-white shadow-sm w-full sm:w-auto"
              size="sm"
            >
              <Plus className="h-4 w-4 mr-1" />
              Nova Sessão
            </Button>
          </div>
        </div>
        
        <TabsContent value="sessions" className="space-y-4">
          <div className="flex flex-col sm:flex-row sm:justify-end gap-2">
            <Link href="/calendario">
              <Button variant="ghost" className="flex items-center justify-center gap-2 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 transition-colors w-full sm:w-auto">
                <Calendar className="h-4 w-4" />
                <span className="hidden sm:inline">Ver Calendário Completo</span>
                <span className="sm:hidden">Calendário</span>
              </Button>
            </Link>
          </div>
          
          <Card className="border-gray-100 dark:border-gray-800 shadow-sm rounded-xl overflow-hidden">
            <CardHeader className="bg-gray-50/80 dark:bg-gray-800/20 pb-3">
              <div className="flex justify-between items-center">
                <div>
                  <CardTitle className="text-lg font-medium text-gray-800 dark:text-white">
                    Sessões Agendadas
                  </CardTitle>
                  <CardDescription className="text-gray-500 dark:text-gray-400 mt-1">
                    Visualize e gerencie todos os agendamentos.
                  </CardDescription>
                </div>
              </div>
            </CardHeader>
            <CardContent className="pt-4">
              {isLoading ? (
                <div className="space-y-3">
                  <Skeleton className="h-10 w-full" />
                  <Skeleton className="h-16 w-full" />
                  <Skeleton className="h-16 w-full" />
                  <Skeleton className="h-16 w-full" />
                </div>
              ) : (
                <SessionTable 
                  sessions={sessions} 
                  onRefresh={refreshSessions} 
                />
              )}
            </CardContent>
          </Card>
        </TabsContent>
        
        <TabsContent value="reports" className="space-y-4">
          <Card className="border-gray-100 dark:border-gray-800 shadow-sm rounded-xl overflow-hidden">
            <CardHeader className="bg-gray-50/80 dark:bg-gray-800/20 pb-3">
              <div className="flex justify-between items-center">
                <div>
                  <CardTitle className="text-lg font-medium text-gray-800 dark:text-white">
                    Relatório de Sessões
                  </CardTitle>
                  <CardDescription className="text-gray-500 dark:text-gray-400 mt-1">
                    Gere relatórios detalhados por aluno, período ou categoria.
                  </CardDescription>
                </div>
              </div>
            </CardHeader>
            <CardContent className="pt-4">
              <SessionReport />
            </CardContent>
          </Card>
        </TabsContent>
      </Tabs>

      {/* Dialog para adicionar nova sessão */}
      <Dialog open={formDialogOpen} onOpenChange={setFormDialogOpen}>
        <DialogContent className="sm:max-w-[900px] max-h-[90vh] overflow-y-auto bg-white dark:bg-gray-800 border-gray-100 dark:border-gray-700 rounded-xl">
          <NewSessionForm 
            leads={leads}
            trainers={trainers}
            onSubmit={handleFormSubmit}
            onCancel={handleFormCancel}
            isLoading={isSubmitting}
          />
        </DialogContent>
      </Dialog>
    </div>
  );
}
</file>

<file path="client/src/components/scheduling/SessionReport.tsx">
import { useState } from 'react';
import { format, startOfMonth, endOfMonth, sub, parseISO } from 'date-fns';
import { ptBR } from 'date-fns/locale';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Card, CardContent } from '@/components/ui/card';
import { Label } from '@/components/ui/label';
import { Input } from '@/components/ui/input';
import { Button } from '@/components/ui/button';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table';
import { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';
import { Calendar } from '@/components/ui/calendar';
import { Badge } from '@/components/ui/badge';
import { CalendarIcon, Download, Printer } from 'lucide-react';
import { cn } from '@/lib/utils';
import { useToast } from '@/hooks/use-toast';
import { useQuery } from '@tanstack/react-query';

type StudentOption = {
  id: string;
  name: string;
  source: 'Favale' | 'Pink';
};

type ReportSession = {
  id: number;
  date: string;
  startTime: string;
  endTime: string;
  duration: string;
  trainerName: string;
  source: 'Favale' | 'Pink';
  status: string;
  location: string;
  value: number;
};

export function SessionReport() {
  const [selectedStudent, setSelectedStudent] = useState<string>("");
  const [fromDate, setFromDate] = useState<Date>(startOfMonth(new Date()));
  const [toDate, setToDate] = useState<Date>(endOfMonth(new Date()));
  const [selectedSource, setSelectedSource] = useState<string>("");
  const [reportData, setReportData] = useState<ReportSession[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const { toast } = useToast();
  
  // Fetch real data from APIs
  const { data: sessions = [] } = useQuery({
    queryKey: ['/api/sessions'],
    queryFn: () => fetch('/api/sessions').then(res => res.json())
  });

  const { data: leads = [] } = useQuery({
    queryKey: ['/api/leads'],
    queryFn: () => fetch('/api/leads').then(res => res.json())
  });

  const { data: trainers = [] } = useQuery({
    queryKey: ['/api/trainers'],
    queryFn: () => fetch('/api/trainers').then(res => res.json())
  });

  // Filter leads to get only students (alunos)
  const students = leads
    .filter((lead: any) => lead.tags?.includes('aluno'))
    .map((lead: any) => ({
      id: lead.id.toString(),
      name: lead.name,
      source: lead.source || 'Favale'
    }));
  
  // Filter students based on selected source
  const filteredStudents = selectedSource 
    ? students.filter(student => student.source === selectedSource) 
    : students;
  
  // Função para gerar relatório
  // Helper functions to get names from IDs
  const getStudentName = (leadId: number) => {
    const lead = leads.find((l: any) => l.id === leadId);
    return lead?.name || 'Estudante';
  };

  const getTrainerName = (trainerId: number) => {
    const trainer = trainers.find((t: any) => t.id === trainerId);
    return trainer?.name || 'Professor';
  };

  const generateReport = () => {
    setIsLoading(true);
    
    try {
      // Filter sessions based on criteria
      let filteredSessions = sessions.filter((session: any) => {
        const sessionDate = new Date(session.startTime);
        const isInDateRange = sessionDate >= fromDate && sessionDate <= toDate;
        const matchesSource = !selectedSource || session.source === selectedSource;
        const matchesStudent = !selectedStudent || session.leadId.toString() === selectedStudent;
        
        return isInDateRange && matchesSource && matchesStudent;
      });

      // Convert sessions to report format
      const reportSessions = filteredSessions.map((session: any) => {
        const startTime = new Date(session.startTime);
        const endTime = new Date(session.endTime);
        const duration = Math.round((endTime.getTime() - startTime.getTime()) / (1000 * 60)); // minutes
        
        return {
          id: session.id,
          date: format(startTime, 'yyyy-MM-dd'),
          startTime: format(startTime, 'HH:mm'),
          endTime: format(endTime, 'HH:mm'),
          duration: duration > 60 ? `${Math.floor(duration/60)}h${duration%60 > 0 ? ` ${duration%60}min` : ''}` : `${duration}min`,
          trainerName: getTrainerName(session.trainerId),
          source: session.source,
          status: session.status === 'agendado' ? 'Agendado' : 
                 session.status === 'completed' ? 'Concluída' : 
                 session.status === 'cancelled' ? 'Cancelada' : session.status,
          location: session.location,
          value: session.value || 0,
        };
      });

      setReportData(reportSessions);
      setIsLoading(false);
      
      toast({
        title: 'Relatório gerado',
        description: `${reportSessions.length} sessões encontradas.`,
      });
    } catch (error) {
      setIsLoading(false);
      toast({
        title: 'Erro ao gerar relatório',
        description: 'Ocorreu um erro ao processar os dados.',
        variant: 'destructive'
      });
    }
  };
  
  // Função para exportar relatório como CSV
  const exportAsCSV = () => {
    if (reportData.length === 0) {
      toast({
        title: 'Nenhum dado disponível',
        description: 'Gere um relatório antes de exportar.',
        variant: 'destructive',
      });
      return;
    }
    
    // Criar cabeçalho CSV
    const headers = ['ID', 'Data', 'Horário', 'Duração', 'Professor', 'Categoria', 'Status', 'Local', 'Valor'];
    
    // Formatar dados para CSV
    const dataRows = reportData.map(session => [
      session.id,
      format(parseISO(session.date), 'dd/MM/yyyy'),
      `${session.startTime} - ${session.endTime}`,
      session.duration,
      session.trainerName,
      session.source,
      session.status,
      session.location,
      `R$ ${session.value.toFixed(2)}`,
    ]);
    
    // Combinar cabeçalho e linhas
    const csvContent = [
      headers.join(','),
      ...dataRows.map(row => row.join(','))
    ].join('\n');
    
    // Criar blob e link para download
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    
    link.setAttribute('href', url);
    link.setAttribute('download', `relatorio_sessoes_${format(new Date(), 'yyyy-MM-dd')}.csv`);
    link.style.display = 'none';
    
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    toast({
      title: 'Relatório exportado',
      description: 'O relatório foi exportado com sucesso no formato CSV.',
    });
  };
  
  // Função para imprimir relatório
  const printReport = () => {
    if (reportData.length === 0) {
      toast({
        title: 'Nenhum dado disponível',
        description: 'Gere um relatório antes de imprimir.',
        variant: 'destructive',
      });
      return;
    }
    
    // Abrir janela de impressão
    window.print();
    
    toast({
      title: 'Imprimindo relatório',
      description: 'O relatório foi enviado para impressão.',
    });
  };
  
  // Calcular valor total do relatório
  const totalValue = reportData.reduce((sum, session) => sum + session.value, 0);
  
  // Atalhos rápidos para períodos
  const setPeriodPreset = (preset: string) => {
    const today = new Date();
    
    switch (preset) {
      case 'current-month':
        setFromDate(startOfMonth(today));
        setToDate(endOfMonth(today));
        break;
      case 'last-month':
        const lastMonth = sub(today, { months: 1 });
        setFromDate(startOfMonth(lastMonth));
        setToDate(endOfMonth(lastMonth));
        break;
      case 'last-3-months':
        setFromDate(startOfMonth(sub(today, { months: 2 })));
        setToDate(endOfMonth(today));
        break;
      case 'current-year':
        setFromDate(new Date(today.getFullYear(), 0, 1));
        setToDate(new Date(today.getFullYear(), 11, 31));
        break;
      default:
        break;
    }
  };

  return (
    <div className="space-y-6 print:m-6">
      {/* Opções de relatório - não imprime */}
      <div className="print:hidden">
        <Tabs defaultValue="by-student">
          <TabsList>
            <TabsTrigger value="by-student">Por Aluno</TabsTrigger>
            <TabsTrigger value="by-period">Por Período</TabsTrigger>
            <TabsTrigger value="by-category">Por Categoria</TabsTrigger>
          </TabsList>
          
          <TabsContent value="by-student" className="space-y-6">
            <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
              <div className="md:col-span-2">
                <Label htmlFor="student">Aluno</Label>
                <Select value={selectedStudent} onValueChange={setSelectedStudent}>
                  <SelectTrigger id="student">
                    <SelectValue placeholder="Selecione um aluno" />
                  </SelectTrigger>
                  <SelectContent>
                    {filteredStudents.map((student) => (
                      <SelectItem key={student.id} value={student.id}>
                        {student.name}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>
              
              <div>
                <Label htmlFor="source">Categoria</Label>
                <Select value={selectedSource} onValueChange={setSelectedSource}>
                  <SelectTrigger id="source">
                    <SelectValue placeholder="Todas" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="all">Todas</SelectItem>
                    <SelectItem value="Favale">Favale</SelectItem>
                    <SelectItem value="Pink">Pink</SelectItem>
                  </SelectContent>
                </Select>
              </div>
              
              <div className="flex items-end">
                <Button 
                  onClick={generateReport} 
                  disabled={!selectedStudent || isLoading}
                  className="w-full"
                >
                  {isLoading ? 'Gerando...' : 'Gerar Relatório'}
                </Button>
              </div>
            </div>
          </TabsContent>
          
          <TabsContent value="by-period" className="space-y-6">
            <div className="grid grid-cols-1 md:grid-cols-6 gap-4">
              <div className="md:col-span-2">
                <Label>Data Inicial</Label>
                <Popover>
                  <PopoverTrigger asChild>
                    <Button
                      variant={"outline"}
                      className={cn(
                        "w-full justify-start text-left font-normal",
                        !fromDate && "text-muted-foreground"
                      )}
                    >
                      <CalendarIcon className="mr-2 h-4 w-4" />
                      {fromDate ? format(fromDate, "PPP", { locale: ptBR }) : <span>Selecione uma data</span>}
                    </Button>
                  </PopoverTrigger>
                  <PopoverContent className="w-auto p-0" align="start">
                    <Calendar
                      mode="single"
                      selected={fromDate}
                      onSelect={(date) => setFromDate(date || startOfMonth(new Date()))}
                      initialFocus
                      locale={ptBR}
                    />
                  </PopoverContent>
                </Popover>
              </div>
              
              <div className="md:col-span-2">
                <Label>Data Final</Label>
                <Popover>
                  <PopoverTrigger asChild>
                    <Button
                      variant={"outline"}
                      className={cn(
                        "w-full justify-start text-left font-normal",
                        !toDate && "text-muted-foreground"
                      )}
                    >
                      <CalendarIcon className="mr-2 h-4 w-4" />
                      {toDate ? format(toDate, "PPP", { locale: ptBR }) : <span>Selecione uma data</span>}
                    </Button>
                  </PopoverTrigger>
                  <PopoverContent className="w-auto p-0" align="start">
                    <Calendar
                      mode="single"
                      selected={toDate}
                      onSelect={(date) => setToDate(date || endOfMonth(new Date()))}
                      initialFocus
                      locale={ptBR}
                    />
                  </PopoverContent>
                </Popover>
              </div>
              
              <div>
                <Label>Período</Label>
                <Select defaultValue="select" onValueChange={setPeriodPreset}>
                  <SelectTrigger>
                    <SelectValue placeholder="Selecionar" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="select">Selecionar período</SelectItem>
                    <SelectItem value="current-month">Mês Atual</SelectItem>
                    <SelectItem value="last-month">Mês Anterior</SelectItem>
                    <SelectItem value="last-3-months">Últimos 3 Meses</SelectItem>
                    <SelectItem value="current-year">Ano Atual</SelectItem>
                  </SelectContent>
                </Select>
              </div>
              
              <div className="flex items-end">
                <Button 
                  onClick={generateReport} 
                  disabled={!fromDate || !toDate || isLoading}
                  className="w-full"
                >
                  {isLoading ? 'Gerando...' : 'Gerar Relatório'}
                </Button>
              </div>
            </div>
          </TabsContent>
          
          <TabsContent value="by-category" className="space-y-6">
            <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
              <div className="md:col-span-2">
                <Label htmlFor="category-source">Categoria</Label>
                <Select value={selectedSource} onValueChange={setSelectedSource}>
                  <SelectTrigger id="category-source">
                    <SelectValue placeholder="Selecione uma categoria" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="Favale">Favale</SelectItem>
                    <SelectItem value="Pink">Pink</SelectItem>
                  </SelectContent>
                </Select>
              </div>
              
              <div className="md:col-span-2 flex items-end">
                <Button 
                  onClick={generateReport} 
                  disabled={!selectedSource || isLoading}
                  className="w-full"
                >
                  {isLoading ? 'Gerando...' : 'Gerar Relatório'}
                </Button>
              </div>
            </div>
          </TabsContent>
        </Tabs>
      </div>
      
      {/* Data do relatório */}
      {reportData.length > 0 && (
        <div className="space-y-6">
          {/* Cabeçalho do relatório - inclui em ambos modos */}
          <div className="print:mt-0">
            <div className="flex justify-between items-start">
              <div>
                <h3 className="text-xl font-semibold">Relatório de Sessões</h3>
                <p className="text-muted-foreground">
                  Período: {format(fromDate, "dd/MM/yyyy")} - {format(toDate, "dd/MM/yyyy")}
                </p>
                {selectedStudent && (
                  <p className="text-muted-foreground">
                    Aluno: {students.find(s => s.id === selectedStudent)?.name || selectedStudent}
                  </p>
                )}
                {selectedSource && (
                  <p className="text-muted-foreground">
                    Categoria: {selectedSource}
                  </p>
                )}
              </div>
              
              {/* Botões de ação - não imprime */}
              <div className="flex gap-2 print:hidden">
                <Button variant="outline" size="sm" onClick={exportAsCSV}>
                  <Download className="h-4 w-4 mr-2" /> 
                  Exportar
                </Button>
                <Button variant="outline" size="sm" onClick={printReport}>
                  <Printer className="h-4 w-4 mr-2" /> 
                  Imprimir
                </Button>
              </div>
            </div>
          </div>
          
          {/* Tabela de resultados */}
          <div className="border rounded-md">
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>Data</TableHead>
                  <TableHead>Horário</TableHead>
                  <TableHead>Professor</TableHead>
                  <TableHead>Categoria</TableHead>
                  <TableHead>Local</TableHead>
                  <TableHead className="text-right">Valor</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {reportData.map((session) => (
                  <TableRow key={session.id}>
                    <TableCell>{format(parseISO(session.date), 'dd/MM/yyyy')}</TableCell>
                    <TableCell>
                      {session.startTime} - {session.endTime} ({session.duration})
                    </TableCell>
                    <TableCell>{session.trainerName}</TableCell>
                    <TableCell>
                      <Badge 
                        variant="outline"
                        className={session.source === 'Favale' ? 
                          'bg-blue-50 text-blue-700 border-blue-300 dark:bg-blue-950 dark:text-blue-300 dark:border-blue-800' : 
                          'bg-pink-50 text-pink-700 border-pink-300 dark:bg-pink-950 dark:text-pink-300 dark:border-pink-800'}
                      >
                        {session.source}
                      </Badge>
                    </TableCell>
                    <TableCell>{session.location}</TableCell>
                    <TableCell className="text-right font-medium">
                      R$ {session.value.toFixed(2)}
                    </TableCell>
                  </TableRow>
                ))}
                <TableRow className="font-bold">
                  <TableCell colSpan={5} className="text-right">
                    Total:
                  </TableCell>
                  <TableCell className="text-right">
                    R$ {totalValue.toFixed(2)}
                  </TableCell>
                </TableRow>
              </TableBody>
            </Table>
          </div>

          {/* Resumo para fatura */}
          <Card className="mt-4">
            <CardContent className="pt-6">
              <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                <div>
                  <h4 className="text-sm font-medium text-muted-foreground">Total de Sessões</h4>
                  <p className="text-2xl font-bold">{reportData.length}</p>
                </div>
                <div>
                  <h4 className="text-sm font-medium text-muted-foreground">Total de Horas</h4>
                  <p className="text-2xl font-bold">{reportData.length}h</p>
                </div>
                <div>
                  <h4 className="text-sm font-medium text-muted-foreground">Valor Total</h4>
                  <p className="text-2xl font-bold">R$ {totalValue.toFixed(2)}</p>
                </div>
              </div>
            </CardContent>
          </Card>
        </div>
      )}
    </div>
  );
}
</file>

<file path="client/src/components/scheduling/SessionTable.tsx">
import React, { useState, useMemo } from 'react';
import { format } from 'date-fns';
import { ptBR } from 'date-fns/locale';
import { useQuery } from '@tanstack/react-query';
import { RecurringSessionCard } from './RecurringSessionCard';
import { groupSessions } from '@/utils/sessionGrouping';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { Button } from '@/components/ui/button';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import { Badge } from '@/components/ui/badge';
import { Check, FileEdit, MoreVertical, X } from 'lucide-react';
import { SessionDetails } from './SessionDetails';
import { SessionForm } from './SessionForm';
import { useToast } from '@/hooks/use-toast';

type SessionStatus = 'scheduled' | 'completed' | 'cancelled' | 'no-show' | 'agendado' | 'concluído' | 'cancelado';

interface Session {
  id: number;
  startTime: string;
  endTime: string;
  location: string;
  source: 'Favale' | 'Pink' | 'FavalePink';
  notes?: string;
  status: SessionStatus;
  leadId: number;
  trainerId: number;
  value?: number;
  service?: string;
  recurrenceType?: string;
  recurrenceGroupId?: string;
  isRecurrenceParent?: boolean;
  parentSessionId?: number;
}

interface SessionTableProps {
  sessions: Session[];
  onRefresh: () => void;
}

function getStatusBadgeVariant(status: SessionStatus) {
  switch (status) {
    case 'scheduled':
      return 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-300';
    case 'completed':
      return 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-300';
    case 'cancelled':
      return 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-300';
    case 'no-show':
      return 'bg-amber-100 text-amber-800 dark:bg-amber-900 dark:text-amber-300';
    default:
      return 'bg-gray-100 text-gray-800 dark:bg-gray-800 dark:text-gray-300';
  }
}

function getStatusText(status: SessionStatus): string {
  switch (status) {
    case 'scheduled':
    case 'agendado':
      return 'Agendada';
    case 'completed':
    case 'concluído':
      return 'Concluída';
    case 'cancelled':
    case 'cancelado':
      return 'Cancelada';
    case 'no-show':
      return 'Não Compareceu';
    default:
      return status;
  }
}

function getStatusBadge(status: SessionStatus) {
  const variant = getStatusBadgeVariant(status);
  const text = getStatusText(status);
  
  return (
    <Badge className={`${variant} border-0`}>
      {text}
    </Badge>
  );
}

export function SessionTable({ sessions, onRefresh }: SessionTableProps) {
  const [selectedSession, setSelectedSession] = useState<Session | null>(null);
  const [viewDetailsOpen, setViewDetailsOpen] = useState(false);
  const [editSessionOpen, setEditSessionOpen] = useState(false);
  const { toast } = useToast();
  
  // Fetch leads for student names
  const { data: leads = [] } = useQuery({
    queryKey: ['/api/leads'],
    queryFn: () => fetch('/api/leads').then(res => res.json())
  });

  // Fetch trainers for trainer names
  const { data: trainers = [] } = useQuery({
    queryKey: ['/api/trainers'],
    queryFn: () => fetch('/api/trainers').then(res => res.json())
  });

  // Helper functions to get names from IDs
  const getStudentName = (leadId: number) => {
    const lead = leads.find((l: any) => l.id === leadId);
    return lead?.name || 'Estudante';
  };

  const getTrainerName = (trainerId: number) => {
    const trainer = trainers.find((t: any) => t.id === trainerId);
    return trainer?.name || 'Professor';
  };

  // Group sessions into recurring and individual
  const groupedSessions = useMemo(() => {
    return groupSessions(sessions, getStudentName, getTrainerName);
  }, [sessions, leads, trainers]);
  
  const handleCancelSession = async (id: number) => {
    try {
      const response = await fetch(`/api/sessions/${id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ status: 'cancelled' })
      });
      
      if (response.ok) {
        toast({
          title: 'Sessão cancelada',
          description: 'A sessão foi cancelada com sucesso.',
        });
        setViewDetailsOpen(false);
        onRefresh();
      } else {
        throw new Error('Erro ao cancelar sessão');
      }
    } catch (error) {
      toast({
        title: 'Erro',
        description: 'Não foi possível cancelar a sessão.',
        variant: 'destructive'
      });
    }
  };
  
  const handleCompleteSession = async (id: number) => {
    try {
      const response = await fetch(`/api/sessions/${id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ status: 'completed' })
      });
      
      if (response.ok) {
        toast({
          title: 'Sessão concluída',
          description: 'A sessão foi marcada como concluída.',
        });
        setViewDetailsOpen(false);
        onRefresh();
      } else {
        throw new Error('Erro ao marcar sessão como concluída');
      }
    } catch (error) {
      toast({
        title: 'Erro',
        description: 'Não foi possível marcar a sessão como concluída.',
        variant: 'destructive'
      });
    }
  };

  const openSessionDetails = (session: Session) => {
    setSelectedSession(session);
    setViewDetailsOpen(true);
  };

  const openEditSession = (session: Session) => {
    setSelectedSession(session);
    setViewDetailsOpen(false);
    setEditSessionOpen(true);
  };

  return (
    <>
      <div className="space-y-4">
        {/* Sessões Recorrentes */}
        {groupedSessions.recurring.length > 0 && (
          <div className="space-y-3">
            <h3 className="text-sm font-medium text-gray-700 dark:text-gray-300 flex items-center gap-2">
              <div className="h-4 w-4 rounded-full bg-blue-100 flex items-center justify-center">
                <div className="h-2 w-2 rounded-full bg-blue-600"></div>
              </div>
              Sessões Recorrentes ({groupedSessions.recurring.length})
            </h3>
            {groupedSessions.recurring.map((group, index) => (
              <RecurringSessionCard
                key={`recurring-${index}`}
                group={group}
                onEditSession={(session) => openSessionDetails(session)}
                onCancelSession={handleCancelSession}
                onCompleteSession={handleCompleteSession}
              />
            ))}
          </div>
        )}

        {/* Sessões Individuais */}
        {groupedSessions.individual.length > 0 && (
          <div className="space-y-3">
            {groupedSessions.recurring.length > 0 && (
              <h3 className="text-sm font-medium text-gray-700 dark:text-gray-300 flex items-center gap-2">
                <div className="h-4 w-4 rounded-full bg-gray-100 flex items-center justify-center">
                  <div className="h-2 w-2 rounded-full bg-gray-600"></div>
                </div>
                Sessões Individuais ({groupedSessions.individual.length})
              </h3>
            )}
            <div className="rounded-md border overflow-hidden">
              <div className="hidden md:block">
                <Table>
                  <TableHeader>
                    <TableRow>
                      <TableHead>Data/Horário</TableHead>
                      <TableHead>Aluno</TableHead>
                      <TableHead>Professor</TableHead>
                      <TableHead className="hidden lg:table-cell">Local</TableHead>
                      <TableHead>Status</TableHead>
                      <TableHead className="text-right">Ações</TableHead>
                    </TableRow>
                  </TableHeader>
                <TableBody>
                  {groupedSessions.individual.map((session) => (
                    <TableRow key={session.id} className="cursor-pointer hover:bg-muted/50" onClick={() => openSessionDetails(session)}>
                      <TableCell>
                        <div>
                          <div className="font-medium">
                            {format(new Date(session.startTime), 'dd/MM/yyyy', { locale: ptBR })}
                          </div>
                          <div className="text-sm text-muted-foreground">
                            {format(new Date(session.startTime), 'HH:mm', { locale: ptBR })} - 
                            {format(new Date(session.endTime), 'HH:mm', { locale: ptBR })}
                          </div>
                        </div>
                      </TableCell>
                      <TableCell>
                        <div className="flex items-center gap-2">
                          <Badge 
                            variant="outline" 
                            className={session.source === 'Favale' ? 
                              'h-2 w-2 rounded-full bg-blue-500 p-0' : 
                              'h-2 w-2 rounded-full bg-pink-500 p-0'}
                          />
                          {getStudentName(session.leadId)}
                        </div>
                      </TableCell>
                      <TableCell>{getTrainerName(session.trainerId)}</TableCell>
                      <TableCell className="hidden md:table-cell truncate max-w-xs">{session.location}</TableCell>
                      <TableCell>
                        <Badge variant="outline" className={getStatusBadgeVariant(session.status)}>
                          {getStatusText(session.status)}
                        </Badge>
                      </TableCell>
                      <TableCell className="text-right">
                        <DropdownMenu>
                          <DropdownMenuTrigger asChild onClick={(e) => e.stopPropagation()}>
                            <Button variant="ghost" className="h-8 w-8 p-0">
                              <span className="sr-only">Abrir menu</span>
                              <MoreVertical className="h-4 w-4" />
                            </Button>
                          </DropdownMenuTrigger>
                          <DropdownMenuContent align="end">
                            <DropdownMenuLabel>Ações</DropdownMenuLabel>
                            <DropdownMenuSeparator />
                            <DropdownMenuItem onClick={(e) => {
                              e.stopPropagation();
                              openSessionDetails(session);
                            }}>
                              Ver detalhes
                            </DropdownMenuItem>
                            <DropdownMenuItem onClick={(e) => {
                              e.stopPropagation();
                              openEditSession(session);
                            }}>
                              <FileEdit className="mr-2 h-4 w-4" />
                              Editar sessão
                            </DropdownMenuItem>
                            {session.status === 'scheduled' && (
                              <>
                                <DropdownMenuSeparator />
                                <DropdownMenuItem 
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    handleCompleteSession(session.id);
                                  }}
                                  className="text-green-600"
                                >
                                  <Check className="mr-2 h-4 w-4" />
                                  Marcar como concluída
                                </DropdownMenuItem>
                                <DropdownMenuItem 
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    handleCancelSession(session.id);
                                  }}
                                  className="text-red-600"
                                >
                                  <X className="mr-2 h-4 w-4" />
                                  Cancelar sessão
                                </DropdownMenuItem>
                              </>
                            )}
                          </DropdownMenuContent>
                        </DropdownMenu>
                      </TableCell>
                    </TableRow>
                  ))}
                </TableBody>
                </Table>
              </div>
              
              {/* Mobile view */}
              <div className="md:hidden space-y-3 p-4">
                {groupedSessions.individual.map((session) => (
                  <div key={session.id} className="bg-white dark:bg-gray-800 border rounded-lg p-4 cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-700/50 transition-colors" onClick={() => openSessionDetails(session)}>
                    <div className="flex justify-between items-start mb-2">
                      <div>
                        <div className="font-medium text-sm">
                          {format(new Date(session.startTime), 'dd/MM/yyyy', { locale: ptBR })}
                        </div>
                        <div className="text-xs text-muted-foreground">
                          {format(new Date(session.startTime), 'HH:mm', { locale: ptBR })} - {format(new Date(session.endTime), 'HH:mm', { locale: ptBR })}
                        </div>
                      </div>
                      {getStatusBadge(session.status)}
                    </div>
                    
                    <div className="space-y-1 mb-3">
                      <div className="flex items-center gap-2">
                        <Badge variant="outline" className={session.source === 'Favale' ? 'bg-blue-50 text-blue-600 border-blue-200' : 'bg-pink-50 text-pink-600 border-pink-200'}>
                          {session.source}
                        </Badge>
                        <span className="text-sm font-medium">{getStudentName(session.leadId)}</span>
                      </div>
                      <div className="text-sm text-muted-foreground">
                        Professor: {getTrainerName(session.trainerId)}
                      </div>
                      <div className="text-sm text-muted-foreground">
                        Local: {session.location}
                      </div>
                    </div>
                    
                    <div className="flex justify-end">
                      <DropdownMenu>
                        <DropdownMenuTrigger asChild>
                          <Button variant="ghost" size="sm" className="h-8 w-8 p-0" onClick={(e) => e.stopPropagation()}>
                            <MoreVertical className="h-4 w-4" />
                          </Button>
                        </DropdownMenuTrigger>
                        <DropdownMenuContent align="end">
                          <DropdownMenuItem onClick={(e) => {
                            e.stopPropagation();
                            openSessionDetails(session);
                          }}>
                            Ver detalhes
                          </DropdownMenuItem>
                          <DropdownMenuItem onClick={(e) => {
                            e.stopPropagation();
                            openEditSession(session);
                          }}>
                            Editar sessão
                          </DropdownMenuItem>
                          {session.status === 'scheduled' && (
                            <>
                              <DropdownMenuSeparator />
                              <DropdownMenuItem 
                                onClick={(e) => {
                                  e.stopPropagation();
                                  handleCompleteSession(session.id);
                                }}
                                className="text-green-600"
                              >
                                Marcar como concluída
                              </DropdownMenuItem>
                              <DropdownMenuItem 
                                onClick={(e) => {
                                  e.stopPropagation();
                                  handleCancelSession(session.id);
                                }}
                                className="text-red-600"
                              >
                                Cancelar sessão
                              </DropdownMenuItem>
                            </>
                          )}
                        </DropdownMenuContent>
                      </DropdownMenu>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          </div>
        )}

        {/* Estado vazio */}
        {groupedSessions.recurring.length === 0 && groupedSessions.individual.length === 0 && (
          <div className="text-center py-12 border rounded-lg bg-gray-50 dark:bg-gray-800/50">
            <div className="text-gray-500 dark:text-gray-400">
              <div className="text-lg font-medium mb-2">Nenhuma sessão encontrada</div>
              <div className="text-sm">Crie sua primeira sessão para começar</div>
            </div>
          </div>
        )}
      </div>

      {/* Dialog para visualizar detalhes da sessão */}
      <Dialog open={viewDetailsOpen} onOpenChange={setViewDetailsOpen}>
        <DialogContent className="sm:max-w-[625px]">
          <DialogHeader>
            <DialogTitle>Detalhes da Sessão</DialogTitle>
          </DialogHeader>
          {selectedSession && (
            <SessionDetails 
              session={selectedSession} 
              onCancelSession={handleCancelSession}
              onCompleteSession={handleCompleteSession}
              onEditSession={(id) => {
                setViewDetailsOpen(false);
                setEditSessionOpen(true);
              }}
            />
          )}
        </DialogContent>
      </Dialog>

      {/* Dialog para editar sessão */}
      <Dialog open={editSessionOpen} onOpenChange={setEditSessionOpen}>
        <DialogContent className="sm:max-w-[650px]">
          <DialogHeader>
            <DialogTitle>Editar Sessão</DialogTitle>
          </DialogHeader>
          {selectedSession && (
            <SessionForm 
              sessionId={selectedSession.id}
              defaultValues={{
                date: new Date(selectedSession.startTime),
                startTime: format(new Date(selectedSession.startTime), 'HH:mm'),
                endTime: format(new Date(selectedSession.endTime), 'HH:mm'),
                location: selectedSession.location,
                source: selectedSession.source as 'Favale' | 'Pink',
                leadId: selectedSession.leadId,
                trainerId: selectedSession.trainerId,
                notes: selectedSession.notes || '',
              }}
              onSuccess={() => {
                setEditSessionOpen(false);
                onRefresh();
              }}
            />
          )}
        </DialogContent>
      </Dialog>
    </>
  );
}
</file>

<file path="client/src/components/Sidebar.tsx">
import { useLocation, Link } from "wouter";
import { useState, useEffect } from "react";
import { useTheme } from "@/components/theme-provider";
import { useAuth } from "@/hooks/use-auth";
import { Avatar, AvatarFallback } from "@/components/ui/avatar";
import { LogOut, User, Shield } from "lucide-react";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";

interface SidebarProps {
  open: boolean;
  setOpen: (open: boolean) => void;
  expanded?: boolean;
}

export default function Sidebar({ open, setOpen, expanded = true }: SidebarProps) {
  const [location] = useLocation();
  const { theme } = useTheme();
  const { user, logoutMutation } = useAuth();
  const [isMobile, setIsMobile] = useState(false);
  
  useEffect(() => {
    // Verificar se é mobile ao inicializar
    const checkMobile = () => {
      setIsMobile(window.innerWidth < 1024);
    };
    
    checkMobile();
    window.addEventListener('resize', checkMobile);
    
    return () => {
      window.removeEventListener('resize', checkMobile);
    };
  }, []);
  
  // Itens de navegação padrão
  let navItems = [
    { path: "/", label: "Dashboard", icon: "dashboard" },
    { path: "/leads", label: "Leads", icon: "people" },
    { path: "/agendamentos", label: "Agendamentos", icon: "calendar_today" },
    { path: "/calendario", label: "Calendário", icon: "event" },
    { path: "/professores", label: "Professores", icon: "school" },
    { path: "/tarefas", label: "Tarefas", icon: "assignment" },
    { path: "/whatsapp", label: "WhatsApp", icon: "chat" },
    { path: "/favale-ia", label: "FavaleIA", icon: "psychology" },
    { path: "/config", label: "Configurações", icon: "settings" },
  ];
  
  
  const getNavClasses = (path: string) => {
    const isActive = location === path;
    const baseClasses = "flex items-center text-white transition-all duration-300 rounded-md my-2";
    
    return isActive 
      ? `${baseClasses} bg-gray-700 ${expanded ? 'px-4 mx-3' : 'justify-center mx-2 w-10 h-10'} py-2`
      : `${baseClasses} hover:bg-gray-700/50 ${expanded ? 'px-4 mx-3' : 'justify-center mx-2 w-10 h-10'} py-2`;
  };
  
  return (
    <>
      {/* Mobile/Desktop sidebar */}
      <aside 
        className={`${expanded ? 'w-64' : 'w-16'} bg-gray-900 text-white lg:block flex-shrink-0 fixed lg:relative inset-y-0 left-0 transform ${
          open ? "translate-x-0" : "-translate-x-full"
        } lg:translate-x-0 transition-all duration-300 ease-in-out z-30 h-full flex flex-col overflow-hidden rounded-tr-xl rounded-br-xl shadow-lg`}
      >
        <div className="p-4 flex items-center justify-between border-b border-gray-800 relative">
          {expanded ? (
            <div className="font-heading text-xl font-bold text-white/90">
              FavaleTrainer
            </div>
          ) : (
            <div className="font-heading text-xl font-bold text-center w-full text-white/90">
              FT
            </div>
          )}
        </div>
        
        <div className="px-3 py-4 text-xs font-medium text-gray-400 uppercase tracking-wider">
          {expanded && "MAIN MENU"}
        </div>
        
        <nav className="py-2 overflow-y-auto flex-grow px-1">
          <ul className={`space-y-1 ${!expanded ? 'flex flex-col items-center' : ''}`}>
            {navItems.map((item) => (
              <li key={item.path} className={!expanded ? 'w-full flex justify-center' : ''}>
                <Link 
                  href={item.path}
                  onClick={() => setOpen(false)}
                  className={getNavClasses(item.path)}
                  title={!expanded ? item.label : undefined}
                >
                  <span className={`material-icons text-base ${expanded ? 'mr-3' : ''} transition-all duration-300 ${location === item.path ? 'text-white' : 'text-gray-400'}`}>{item.icon}</span>
                  {expanded && <span className={`text-sm font-medium ${location === item.path ? 'text-white' : 'text-gray-400'}`}>{item.label}</span>}
                </Link>
              </li>
            ))}
          </ul>
        </nav>
        
        {/* User Profile Section */}
        {user && (
          <div className="mt-auto border-t border-gray-800 p-4 sticky bottom-0 bg-gray-900/95 backdrop-blur-sm">
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <button 
                  className={`flex items-center w-full ${expanded ? 'justify-between' : 'justify-center'} text-white hover:bg-gray-800 rounded-md p-2 transition-all duration-200 group`}
                  title={!expanded ? "Perfil de usuário" : undefined}
                >
                  <div className="flex items-center">
                    <Avatar className={`${expanded ? 'h-8 w-8' : 'h-9 w-9'} bg-gray-700 transition-all duration-200`}>
                      <AvatarFallback className="text-sm font-medium text-white">
                        {user.username.substring(0, 2).toUpperCase()}
                      </AvatarFallback>
                    </Avatar>
                    {expanded && (
                      <div className="ml-3 flex flex-col">
                        <span className="text-sm font-medium">{user.username}</span>
                        <span className="text-xs text-gray-400">{user.role === 'admin' ? 'Admin' : 'Usuário'}</span>
                      </div>
                    )}
                  </div>
                  {expanded && (
                    <span className="material-icons text-sm text-gray-400 group-hover:text-white/90 transition-all">expand_more</span>
                  )}
                </button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="start" className="w-56 animate-in slide-in-from-bottom-5 duration-200">
                <DropdownMenuLabel>Minha Conta</DropdownMenuLabel>
                <DropdownMenuSeparator />
                <Link href="/config" onClick={() => setOpen(false)}>
                  <DropdownMenuItem className="cursor-pointer">
                    <User className="mr-2 h-4 w-4 opacity-70" />
                    <span className="text-sm">Perfil e Configurações</span>
                  </DropdownMenuItem>
                </Link>
                {user.role === 'admin' && (
                  <Link href="/config" onClick={() => {
                    setOpen(false);
                  }}>
                    <DropdownMenuItem className="cursor-pointer">
                      <Shield className="mr-2 h-4 w-4 opacity-70" />
                      <span className="text-sm">Segurança</span>
                    </DropdownMenuItem>
                  </Link>
                )}
                <DropdownMenuSeparator />
                <DropdownMenuItem onClick={() => logoutMutation.mutate()} className="cursor-pointer text-red-500 focus:text-red-500">
                  <LogOut className="mr-2 h-4 w-4 opacity-70" />
                  <span className="text-sm">Sair</span>
                </DropdownMenuItem>
              </DropdownMenuContent>
            </DropdownMenu>
          </div>
        )}
      </aside>
      
      {/* Background overlay for mobile sidebar */}
      {open && isMobile && (
        <div 
          className="fixed inset-0 bg-black/50 backdrop-blur-sm z-20 lg:hidden transition-all duration-300" 
          onClick={() => setOpen(false)}
          aria-hidden="true"
        />
      )}
    </>
  );
}
</file>

<file path="client/src/components/tasks/KanbanBoard.tsx">
import React, { useState, useEffect } from "react";
import { DragDropContext, Droppable, Draggable } from "react-beautiful-dnd";
import TaskCard from "./TaskCard";
import { useTaskContext } from "@/context/TaskContext";
import { Button } from "@/components/ui/button";
import { PlusCircle, ListTodo, ClipboardList, Loader2, CheckCircle } from "lucide-react";
import { useToast } from "@/components/ui/use-toast";


const columns = [
  { id: "backlog", name: "Backlog Tasks", color: "bg-orange-100 text-orange-700 dark:bg-orange-800 dark:text-orange-200", icon: <ClipboardList className="h-4 w-4" /> },
  { id: "pending", name: "To Do Tasks", color: "bg-pink-100 text-pink-700 dark:bg-pink-800 dark:text-pink-200", icon: <ListTodo className="h-4 w-4" /> },
  { id: "in_process", name: "In Process", color: "bg-purple-100 text-purple-700 dark:bg-purple-800 dark:text-purple-200", icon: <Loader2 className="h-4 w-4 animate-spin-slow" /> },
  { id: "done", name: "Done", color: "bg-green-100 text-green-700 dark:bg-green-800 dark:text-green-200", icon: <CheckCircle className="h-4 w-4" /> },
];

export default function KanbanBoard({ onCreateTask, onOpenDetails }: { onCreateTask: (initialStatus?: string) => void, onOpenDetails?: (taskId: number) => void }) {
  const { tasks, updateTask } = useTaskContext();
  const [localTasks, setLocalTasks] = useState<any[]>([]);
  const { toast } = useToast();

  // Sincroniza localTasks com tasks do contexto
  useEffect(() => {
    setLocalTasks(tasks);
  }, [tasks]);

  // Agrupa tarefas por status
  const tasksByStatus = columns.reduce((acc, col) => {
    acc[col.id] = localTasks.filter(task => (
      task.status === col.id || 
      (col.id === "in_process" && task.status === "in_progress") || 
      (col.id === "done" && task.status === "completed")
    ));
    return acc;
  }, {} as Record<string, any[]>);

  const onDragEnd = async (result: any) => {
    if (!result.destination) return;
    const { draggableId, destination, source } = result;

    // Prevent re-rendering if dropped in the same place
    if (destination.droppableId === source.droppableId && destination.index === source.index) return;

    // Mapeamento correto para o backend
    let backendStatus = destination.droppableId;
    if (backendStatus === "in_process") backendStatus = "in_progress";
    else if (backendStatus === "done") backendStatus = "completed";
    // Não modificar o status backlog e pending - manter como estão

    // Validar o status para garantir que seja um dos tipos permitidos
    if (!["backlog", "pending", "in_progress", "completed", "cancelled"].includes(backendStatus)) {
      console.error(`Status inválido: ${backendStatus}`);
      toast({
        variant: "destructive",
        title: "Erro ao atualizar tarefa",
        description: "Status inválido detectado."
      });
      return;
    }

    // Optimistic update: atualiza localTasks imediatamente
    setLocalTasks(prev => prev.map(task =>
      String(task.id) === draggableId
        ? { ...task, status: backendStatus }
        : task
    ));

    // Atualiza no backend/contexto
    try {
      await updateTask(Number(draggableId), { 
        status: backendStatus as "backlog" | "pending" | "in_progress" | "completed" | "cancelled"
      });
    } catch (error) {
      console.error("Erro ao atualizar status da tarefa:", error);
      
      // Revert the optimistic update if the server update failed
      setLocalTasks(prev => prev.map(task =>
        String(task.id) === draggableId
          ? { ...task, status: source.droppableId === "in_process" ? "in_progress" : source.droppableId === "done" ? "completed" : source.droppableId }
          : task
      ));
      
      toast({
        variant: "destructive",
        title: "Erro ao atualizar tarefa",
        description: "Não foi possível mover a tarefa para a nova coluna."
      });
    }
  };

  return (
    <DragDropContext onDragEnd={onDragEnd}>
      <div className="grid grid-cols-1 md:grid-cols-4 gap-3 min-h-[500px]">
        {columns.map(col => (
          <Droppable droppableId={col.id} key={col.id}>
            {(provided: any) => (
              <div
                ref={provided.innerRef}
                {...provided.droppableProps}
                className={`flex flex-col ${col.color} rounded-2xl min-h-[500px] max-h-[calc(100vh-200px)] overflow-hidden`}
              >
                {/* Header da coluna */}
                <div className="flex items-center justify-between px-4 py-3 border-b border-slate-200 dark:border-slate-700 sticky top-0 z-10 bg-slate-50 dark:bg-slate-900">
                  <div className="flex items-center gap-2">
                    <span className="font-semibold text-sm text-slate-700 dark:text-slate-200">{col.name}</span>
                    <span className={`ml-1 text-xs py-0.5 px-1.5 rounded-md font-bold ${col.color} ${col.id === 'backlog' ? 'text-yellow-600 bg-yellow-200 dark:text-yellow-300 dark:bg-yellow-700' : col.id === 'pending' ? 'text-pink-600 bg-pink-200 dark:text-pink-300 dark:bg-pink-700' : col.id === 'in_process' ? 'text-purple-600 bg-purple-200 dark:text-purple-300 dark:bg-purple-700' : 'text-green-600 bg-green-200 dark:text-green-300 dark:bg-green-700'}`}>{tasksByStatus[col.id].length}</span>
                  </div>
                  <Button
                    variant="ghost"
                    size="icon"
                    className="h-7 w-7 text-slate-400 hover:text-slate-600 dark:text-slate-500 dark:hover:text-slate-300"
                    onClick={() => onCreateTask(col.id)}
                  >
                    <PlusCircle className="h-3.5 w-3.5" />
                  </Button>
                </div>
                {/* Cards da coluna */}
                <div className="flex-1 p-3 space-y-3 overflow-y-auto">
                  {tasksByStatus[col.id].length > 0 ? (
                    tasksByStatus[col.id].map((task, idx) => (
                      <Draggable draggableId={String(task.id)} index={idx} key={task.id}>
                        {(provided: any) => (
                          <div
                            ref={provided.innerRef}
                            {...provided.draggableProps}
                            {...provided.dragHandleProps}
                            style={{ ...provided.draggableProps.style }}
                            className="rounded-2xl bg-white dark:bg-slate-800 shadow-sm border border-slate-200 dark:border-slate-700 hover:shadow-md transition-shadow duration-200 p-0"
                          >
                            <TaskCard {...task} onOpenDetails={onOpenDetails} />
                          </div>
                        )}
                      </Draggable>
                    ))
                  ) : (
                    <div className="flex flex-col items-center justify-center h-full text-sm text-slate-500 dark:text-slate-400 p-4">
                      <p className="mb-2">Nenhuma tarefa nesta coluna.</p>
                      <Button
                        variant="outline"
                        size="sm"
                        className="mt-2 border-dashed hover:border-solid border-slate-300 dark:border-slate-700 text-slate-500 dark:text-slate-400 hover:text-slate-700 dark:hover:text-slate-300"
                        onClick={() => onCreateTask(col.id)}
                      >
                        <PlusCircle className="h-4 w-4 mr-1.5" />
                        Adicionar Tarefa
                      </Button>
                    </div>
                  )}
                  {/* Add the placeholder for react-beautiful-dnd */}
                  {provided.placeholder}
                </div>
                <div className="p-2 border-t border-slate-200 dark:border-slate-700">
                  <Button
                    variant="ghost"
                    size="sm"
                    className="w-full flex items-center justify-center py-2 text-slate-500 dark:text-slate-400 hover:text-slate-700 dark:hover:text-slate-300 hover:bg-slate-100 dark:hover:bg-slate-800"
                    onClick={() => onCreateTask(col.id)}
                  >
                    <PlusCircle className="h-4 w-4 mr-2" />
                    Adicionar Nova Tarefa
                  </Button>
                </div>
              </div>
            )}
          </Droppable>
        ))}
      </div>
    </DragDropContext>
  );
}
</file>

<file path="client/src/components/tasks/TaskCard.tsx">
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { format } from "date-fns";
import { ptBR } from "date-fns/locale";
import { Clock, Calendar, User, MessageSquare, CheckCircle, AlertCircle, XCircle, Paperclip, Bell } from "lucide-react";
import { useState } from "react";
import TaskDetailDialog from "./TaskDetailDialog";
import { Avatar, AvatarFallback } from "@/components/ui/avatar";

interface TaskCardProps {
  id: number;
  title: string;
  description?: string;
  assignedToName: string;
  assignedByName: string;
  dueDate?: Date;
  priority: "low" | "medium" | "high";
  status: "pending" | "in_progress" | "completed" | "cancelled";
  relatedLeadName?: string;
  commentCount: number;
  hasAttachments?: boolean;
  onStatusChange?: (taskId: number, newStatus: string) => void;
  onOpenDetails?: (taskId: number) => void;
}

export default function TaskCard({
  id,
  title,
  description,
  assignedToName,
  assignedByName,
  dueDate,
  priority,
  status,
  relatedLeadName,
  commentCount,
  hasAttachments = false,
  onStatusChange,
  onOpenDetails
}: TaskCardProps) {
  const getPriorityBadge = (priority: string) => {
    switch (priority) {
      case "high":
        return <Badge variant="outline" className="bg-red-50 text-red-600 border-red-200">Alta</Badge>;
      case "medium":
        return <Badge variant="outline" className="bg-amber-50 text-amber-600 border-amber-200">Média</Badge>;
      case "low":
        return <Badge variant="outline" className="bg-green-50 text-green-600 border-green-200">Baixa</Badge>;
      default:
        return <Badge variant="outline">{priority}</Badge>;
    }
  };

  const getStatusBadge = (status: string) => {
    switch (status) {
      case "pending":
        return <Badge variant="outline" className="bg-blue-50 text-blue-600 border-blue-200">Pendente</Badge>;
      case "in_progress":
        return <Badge variant="outline" className="bg-purple-50 text-purple-600 border-purple-200">Em andamento</Badge>;
      case "completed":
        return <Badge variant="outline" className="bg-green-50 text-green-600 border-green-200">Concluída</Badge>;
      case "cancelled":
        return <Badge variant="outline" className="bg-red-50 text-red-600 border-red-200">Cancelada</Badge>;
      default:
        return <Badge variant="outline">{status}</Badge>;
    }
  };

  const getStatusActions = () => {
    const statusActions = [];
    
    // Ações de status (apenas se onStatusChange for fornecido)
    if (onStatusChange) {
      switch (status) {
        case "pending":
          statusActions.push(
            <Button 
              key="start"
              variant="outline" 
              size="sm" 
              className="text-purple-600 border-purple-200 hover:bg-purple-50"
              onClick={(e) => {
                e.stopPropagation();
                onStatusChange(id, "in_progress");
              }}
            >
              Iniciar
            </Button>,
            <Button 
              key="cancel"
              variant="outline" 
              size="sm" 
              className="text-red-600 border-red-200 hover:bg-red-50"
              onClick={(e) => {
                e.stopPropagation();
                onStatusChange(id, "cancelled");
              }}
            >
              Cancelar
            </Button>
          );
          break;
        case "in_progress":
          statusActions.push(
            <Button 
              key="complete"
              variant="outline" 
              size="sm" 
              className="text-green-600 border-green-200 hover:bg-green-50"
              onClick={(e) => {
                e.stopPropagation();
                onStatusChange(id, "completed");
              }}
            >
              Concluir
            </Button>,
            <Button 
              key="pause"
              variant="outline" 
              size="sm" 
              className="text-blue-600 border-blue-200 hover:bg-blue-50"
              onClick={(e) => {
                e.stopPropagation();
                onStatusChange(id, "pending");
              }}
            >
              Pausar
            </Button>
          );
          break;
      }
    }



    return statusActions.length > 0 ? statusActions : null;
  };

  const getStatusIcon = () => {
    switch (status) {
      case "pending":
        return <AlertCircle className="h-5 w-5 text-blue-500" />;
      case "in_progress":
        return <Clock className="h-5 w-5 text-purple-500" />;
      case "completed":
        return <CheckCircle className="h-5 w-5 text-green-500" />;
      case "cancelled":
        return <XCircle className="h-5 w-5 text-red-500" />;
      default:
        return <AlertCircle className="h-5 w-5" />;
    }
  };

  const getPriorityColor = (priority: string) => {
    switch (priority) {
      case "high":
        return "border-l-4 border-red-500";
      case "medium":
        return "border-l-4 border-amber-400";
      case "low":
        return "border-l-4 border-green-500";
      default:
        return "border-l-4 border-gray-300";
    }
  };

  // Gerador de cor para avatar baseado no nome do usuário
  const getAvatarColor = (name: string): string => {
    if (!name) return "#64748b";
    
    const colors = [
      "#3b82f6", // blue
      "#ef4444", // red
      "#10b981", // green
      "#f59e0b", // amber
      "#8b5cf6", // violet
      "#ec4899", // pink
      "#14b8a6", // teal
      "#f43f5e", // rose
      "#6366f1", // indigo
      "#84cc16", // lime
    ];
    
    let hash = 0;
    for (let i = 0; i < name.length; i++) {
      hash = name.charCodeAt(i) + ((hash << 5) - hash);
      hash = hash & hash;
    }
    
    return colors[Math.abs(hash) % colors.length];
  };

  return (
    <Card
      className={`relative p-2.5 transition-all duration-200 rounded-md shadow-sm border border-white/30 dark:border-slate-700/40 bg-white/70 dark:bg-slate-800/70 backdrop-blur-md min-h-[75px] ${getPriorityColor(priority)} ${status === "completed" ? "opacity-75" : ""} hover:shadow-md hover:bg-white/80 dark:hover:bg-slate-800/80 cursor-pointer`}
      onClick={() => onOpenDetails && onOpenDetails(id)}
    >
      {/* Notification indicator */}
      {(commentCount > 0 || hasAttachments) && (
        <div className="absolute -top-1 -right-1 bg-blue-500 text-white rounded-full w-5 h-5 flex items-center justify-center text-xs shadow-sm z-10" title={
          commentCount > 0 && hasAttachments 
            ? "Possui comentários e anexos"
            : commentCount > 0 
            ? `${commentCount} comentário${commentCount > 1 ? 's' : ''}`
            : "Possui anexos"
        }>
          {commentCount > 0 && hasAttachments ? (
            "+"
          ) : commentCount > 0 ? (
            <MessageSquare className="h-3 w-3" />
          ) : (
            <Paperclip className="h-3 w-3" />
          )}
        </div>
      )}
      
      {/* Badge/tag no topo */}
      <div className="flex items-center justify-between mb-1">
        <div className="flex gap-1">
          {getPriorityBadge(priority)}
          {getStatusBadge(status)}
        </div>
      </div>
      {/* Título */}
      <h3 className="font-medium text-gray-900 dark:text-white text-sm mb-0.5">{title}</h3>
      {/* Descrição */}
      {description && (
        <p className="text-xs text-gray-500 dark:text-gray-400 mb-0.5 line-clamp-1">{description}</p>
      )}
      {/* Avatar e metadados */}
      <div className="flex items-center justify-between mt-1.5">
        <div className="flex gap-2 text-xs text-gray-400 dark:text-gray-500 items-center">
          {dueDate && (
            <span className="flex items-center gap-0.5">
              <Calendar className="h-3 w-3" />
              {format(new Date(dueDate), "dd/MM", { locale: ptBR })}
            </span>
          )}
          <span className="flex items-center gap-0.5" title={commentCount > 0 ? `${commentCount} comentário${commentCount !== 1 ? 's' : ''}` : "Sem comentários"}>
            <MessageSquare className="h-3 w-3" />
            {commentCount > 0 && (
              <span className="text-xs">{commentCount}</span>
            )}
          </span>
          <span className="flex items-center gap-0.5" title={hasAttachments ? "Possui anexos" : "Sem anexos"}>
            <Paperclip className="h-3 w-3" />
            {hasAttachments && (
              <span className="block h-1.5 w-1.5 rounded-full bg-blue-500"></span>
            )}
          </span>
        </div>
        <Avatar className="h-6 w-6" title={`Responsável: ${assignedToName}`}>
          <AvatarFallback 
            style={{ 
              background: getAvatarColor(assignedToName), 
              color: 'white', 
              fontSize: 11,
              fontWeight: 'bold' 
            }}
          >
            {assignedToName ? assignedToName.substring(0, 2).toUpperCase() : "?"}
          </AvatarFallback>
        </Avatar>
      </div>
      
      {/* Ações só aparecem em hover */}
      {getStatusActions() && (
        <div className="absolute top-0 left-0 right-0 bottom-0 bg-white/80 dark:bg-slate-800/80 backdrop-blur-sm opacity-0 hover:opacity-100 flex items-center justify-center gap-1 transition-opacity duration-200 rounded-md">
          {getStatusActions()}
        </div>
      )}
    </Card>
  );
}
</file>

<file path="client/src/components/tasks/TaskDetailDialog.tsx">
import { useState, useEffect } from "react";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogClose, DialogDescription } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Avatar, AvatarFallback } from "@/components/ui/avatar";
import { Badge } from "@/components/ui/badge";
import { format } from "date-fns";
import { ptBR } from "date-fns/locale";
import { X, Paperclip, Calendar, MessageSquare, Plus, Edit, Check, Trash2 } from "lucide-react";
import { Label } from "@/components/ui/label";
import { Input } from "@/components/ui/input";
import { Separator } from "@/components/ui/separator";
import { useTaskContext } from "@/context/TaskContext";
import TaskDialog from "./TaskDialog";
import { useAuth } from "@/hooks/use-auth";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { useToast } from "@/components/ui/use-toast";

interface TaskDetailDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  taskId?: number;
}

export default function TaskDetailDialog({ open, onOpenChange, taskId }: TaskDetailDialogProps) {
  const { fetchTaskById, updateTask, addTaskComment, deleteTaskComment, deleteTask } = useTaskContext();
  const { toast } = useToast();
  const { user } = useAuth();

  const [task, setTask] = useState<any>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [comment, setComment] = useState("");
  const [attachments, setAttachments] = useState<File[]>([]);
  const [commentsList, setCommentsList] = useState<any[]>([]);
  const [showEditDialog, setShowEditDialog] = useState(false);
  const [users, setUsers] = useState<Array<{id: number, username: string, role: string}>>([]);
  const [assigningUser, setAssigningUser] = useState(false);
  const [deletingComment, setDeletingComment] = useState<number | null>(null);

  // Gerar cor consistente com base em uma string (para avatares)
  function stringToColor(str: string) {
    let hash = 0;
    if (!str) return '#70a0ea';
    for (let i = 0; i < str.length; i++) {
      hash = str.charCodeAt(i) + ((hash << 5) - hash);
      hash = hash & hash;
    }

    const colors = [
      '#3b82f6', // blue
      '#ef4444', // red
      '#10b981', // green
      '#f59e0b', // amber
      '#8b5cf6', // violet
      '#ec4899', // pink
      '#14b8a6', // teal
      '#f43f5e', // rose
      '#6366f1', // indigo
      '#84cc16', // lime
      '#06b6d4', // cyan
      '#22c55e', // emerald
    ];

    return colors[Math.abs(hash) % colors.length];
  }

  // Carregar detalhes da tarefa
  useEffect(() => {
    if (taskId) {
      setIsLoading(true);
      fetchTaskById(taskId).then((data) => {
        if (data) {
          setTask(data);
          // Se a tarefa tiver comentários, populamos a lista
          if (data.comments && Array.isArray(data.comments)) {
            setCommentsList(data.comments);
          }
        }
        setIsLoading(false);
      });
    }
  }, [taskId, fetchTaskById]);

  // Carregar lista de usuários do sistema
  useEffect(() => {
    const fetchUsers = async () => {
      try {
        const response = await fetch('/api/users');
        if (response.ok) {
          const data = await response.json();
          setUsers(data);
        } else {
          console.error('Erro ao buscar usuários:', response.statusText);
        }
      } catch (error) {
        console.error('Erro ao buscar usuários:', error);
      }
    };

    fetchUsers();
  }, []);

  const handleAddComment = async () => {
    if (!comment.trim() || !taskId || !user) return;

    try {
      // Prepare comment data (without ID - server will assign one)
      const commentData = {
        taskId,
        userId: user.id, // Use actual user ID
        content: comment,
      };

      // Send to server and get response with actual ID
      const newComment = await addTaskComment(taskId, commentData);

      // Only update local state after successful server response
      setCommentsList(prev => [...prev, newComment]);
      setComment("");

    } catch (error) {
      console.error("Erro ao adicionar comentário:", error);
      toast({
        variant: "destructive",
        title: "Erro",
        description: "Não foi possível adicionar o comentário.",
      });
    }
  };

  const handleAddAttachment = () => {
    const input = document.createElement('input');
    input.type = 'file';
    input.onchange = (e) => {
      const files = (e.target as HTMLInputElement).files;
      if (files && files.length > 0) {
        setAttachments(prev => [...prev, files[0]]);
      }
    };
    input.click();
  };

  // Atribuir tarefa a outro usuário
  const handleAssignUser = async (userId: number) => {
    if (!taskId) return;

    setAssigningUser(true);
    try {
      await updateTask(taskId, { assignedToId: userId });

      // Atualizar o estado local da tarefa
      const updatedTask = { 
        ...task, 
        assignedToId: userId,
        assignedToName: users.find(u => u.id === userId)?.username || task.assignedToName
      };
      setTask(updatedTask);

      toast({
        title: "Tarefa atribuída",
        description: "O responsável pela tarefa foi alterado com sucesso.",
      });
    } catch (error) {
      console.error("Erro ao atribuir tarefa:", error);
      toast({
        variant: "destructive",
        title: "Erro",
        description: "Não foi possível atribuir a tarefa ao usuário selecionado.",
      });
    } finally {
      setAssigningUser(false);
    }
  };

  const handleDeleteComment = async (commentId: number) => {
    if (!taskId || !commentId) return;

    setDeletingComment(commentId);
    try {
      const success = await deleteTaskComment(commentId);

      if (success) {
        // Update local comments list
        setCommentsList(prev => prev.filter(comment => comment.id !== commentId));

        toast({
          title: "Comentário excluído",
          description: "O comentário foi excluído com sucesso.",
        });
      } else {
        throw new Error("Falha ao excluir comentário");
      }
    } catch (error) {
      console.error("Erro ao excluir comentário:", error);
      toast({
        variant: "destructive",
        title: "Erro",
        description: "Não foi possível excluir o comentário.",
      });
    } finally {
      setDeletingComment(null);
    }
  };

  const handleDeleteTask = async () => {
    if (!task) return;
    
    if (window.confirm(`Tem certeza que deseja excluir a tarefa "${task.title}"? Esta ação não pode ser desfeita.`)) {
      const success = await deleteTask(task.id);
      if (success) {
        onOpenChange(false); // Fechar o modal após exclusão
      }
    }
  };

  if (isLoading || !task) {
    return (
      <Dialog open={open} onOpenChange={onOpenChange}>
        <DialogContent 
          className="sm:max-w-[550px]" 
          aria-describedby="task-details-loading"
        >
          <DialogHeader>
            <DialogTitle>Detalhes da Tarefa</DialogTitle>
            <p id="task-details-loading" className="sr-only">Carregando informações da tarefa selecionada.</p>
          </DialogHeader>
          <div className="flex items-center justify-center h-48">
            <p className="text-gray-500">Carregando detalhes...</p>
          </div>
        </DialogContent>
      </Dialog>
    );
  }

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent 
        className="sm:max-w-[550px] p-0 overflow-hidden max-h-[90vh] overflow-y-auto" 
        aria-describedby="task-details-description"
      >
        <DialogHeader className="p-4 border-b sticky top-0 bg-white dark:bg-gray-900 z-10">
          <div className="flex items-center justify-between">
            <DialogTitle>{task.title}</DialogTitle>
            <div className="flex items-center gap-2">
              <Button 
                variant="outline" 
                size="sm" 
                className="h-8 flex items-center gap-1"
                onClick={() => setShowEditDialog(true)}
              >
                <Edit className="h-3.5 w-3.5" />
                Editar
              </Button>
              {user?.role === "admin" && (
                <Button 
                  variant="outline" 
                  size="sm" 
                  className="h-8 flex items-center gap-1 text-red-600 border-red-200 hover:bg-red-50"
                  onClick={handleDeleteTask}
                  title="Excluir tarefa"
                >
                  <Trash2 className="h-3.5 w-3.5" />
                  Excluir
                </Button>
              )}
              <DialogClose asChild>
                <Button variant="ghost" size="icon" className="rounded-full h-8 w-8">
                  <X className="h-4 w-4" />
                </Button>
              </DialogClose>
            </div>
          </div>
          <p id="task-details-description" className="sr-only">Este diálogo mostra informações detalhadas sobre a tarefa selecionada.</p>
        </DialogHeader>

        <div className="p-6 space-y-6">
          {/* Seção de atribuição e meta-info */}
          <div className="flex flex-wrap gap-4 items-center">
            <div className="flex items-center gap-2">
              <Label className="text-sm text-gray-500">Atribuído:</Label>
              <div className="flex items-center">
                <Avatar className="h-7 w-7 border-2 border-white dark:border-gray-900">
                  <AvatarFallback
                    style={{
                      background: stringToColor(task.assignedToName || 'User'),
                      color: 'white'
                    }}
                  >
                    {task.assignedToName?.substring(0, 2).toUpperCase() || 'UN'}
                  </AvatarFallback>
                </Avatar>
                <span className="ml-2 text-sm font-medium">{task.assignedToName || "Não atribuído"}</span>
                <DropdownMenu>
                  <DropdownMenuTrigger asChild>
                    <Button variant="ghost" size="sm" className="ml-1 h-7 w-7 p-0">
                      <Plus className="h-3.5 w-3.5" />
                    </Button>
                  </DropdownMenuTrigger>
                  <DropdownMenuContent align="end" className="w-56">
                    {users.map(user => (
                      <DropdownMenuItem 
                        key={user.id}
                        onClick={() => handleAssignUser(user.id)}
                        disabled={assigningUser}
                        className="cursor-pointer"
                      >
                        <div className="flex items-center gap-2 w-full">
                          <Avatar className="h-6 w-6">
                            <AvatarFallback 
                              style={{
                                background: stringToColor(user.username),
                                color: 'white',
                                fontSize: '12px'
                              }}
                            >
                              {user.username.substring(0, 2).toUpperCase()}
                            </AvatarFallback>
                          </Avatar>
                          <span className="flex-1 truncate">{user.username}</span>
                          {task.assignedToId === user.id && (
                            <Check className="h-4 w-4 text-green-500" />
                          )}
                        </div>
                      </DropdownMenuItem>
                    ))}
                  </DropdownMenuContent>
                </DropdownMenu>
              </div>
            </div>

            <div className="flex items-center gap-2">
              <Label className="text-sm text-gray-500">Nível:</Label>
              <Badge 
                className={`capitalize ${
                  task.priority === 'high' 
                    ? 'bg-red-100 text-red-800 hover:bg-red-100' 
                    : task.priority === 'medium'
                    ? 'bg-amber-100 text-amber-800 hover:bg-amber-100'
                    : 'bg-green-100 text-green-800 hover:bg-green-100'
                }`}
              >
                {task.priority === 'high' 
                  ? 'Alto' 
                  : task.priority === 'medium' 
                  ? 'Médio' 
                  : 'Baixo'}
              </Badge>
            </div>

            <div className="flex items-center gap-2">
              <Label className="text-sm text-gray-500">Data:</Label>
              <div className="flex items-center gap-1">
                <Calendar className="h-4 w-4 text-gray-400" />
                <span className="text-sm">
                  {task.dueDate && format(new Date(task.dueDate), "dd 'de' MMM, yyyy", { locale: ptBR })}
                </span>
              </div>
            </div>
          </div>

          {/* Descrição */}
          <div>
            <Label className="text-sm font-medium">Descrição:</Label>
            <p className="mt-2 text-sm text-gray-700 dark:text-gray-300 whitespace-pre-line">
              {task.description || "Sem descrição."}
            </p>
          </div>

          {/* Anexos */}
          <div>
            <div className="flex items-center justify-between mb-2">
              <Label className="text-sm font-medium flex items-center">
                <Paperclip className="h-4 w-4 mr-2" />
                Anexos:
              </Label>
              <Button
                variant="ghost"
                size="sm"
                className="h-8 text-blue-600 hover:text-blue-800 hover:bg-blue-50"
                onClick={handleAddAttachment}
              >
                + Adicionar um Anexo
              </Button>
            </div>

            {attachments.length > 0 ? (
              <div className="space-y-2">
                {attachments.map((file, index) => (
                  <div key={index} className="flex items-center p-2 border rounded-md bg-gray-50 dark:bg-gray-800">
                    <div className="bg-gray-200 dark:bg-gray-700 rounded p-1 mr-3">
                      <Paperclip className="h-4 w-4" />
                    </div>
                    <div className="flex-1">
                      <p className="text-sm font-medium">{file.name}</p>
                      <p className="text-xs text-gray-500">{Math.round(file.size / 1024)} KB</p>
                    </div>
                  </div>
                ))}
              </div>
            ) : (
              <div className="text-sm text-gray-500 italic">
                Nenhum anexo adicionado.
              </div>
            )}
          </div>

          <Separator />

          {/* Comentários */}
          <div>
            <Label className="text-sm font-medium flex items-center">
              <MessageSquare className="h-4 w-4 mr-2" />
              Comentários:
            </Label>

            <div className="mt-4 space-y-4">
              {commentsList.length > 0 ? (
                commentsList.map((comment, index) => (
                  <div key={index} className="flex gap-3">
                    <Avatar className="h-8 w-8">
                      <AvatarFallback
                        style={{
                          background: stringToColor(comment.userName || 'User'),
                          color: 'white'
                        }}
                      >
                        {comment.userName?.substring(0, 2).toUpperCase() || 'UN'}
                      </AvatarFallback>
                    </Avatar>
                    <div className="flex-1">
                      <div className="flex items-center justify-between">
                        <div className="flex items-center gap-2">
                          <p className="text-sm font-medium">{comment.userName}</p>
                          <span className="text-xs text-gray-500">
                            {format(new Date(comment.createdAt), "dd/MM/yyyy 'às' HH:mm", { locale: ptBR })}
                          </span>
                        </div>
                        {user && (user.id === comment.userId || user.role === 'admin') && (
                          <Button
                            variant="ghost"
                            size="icon"
                            className="h-6 w-6 text-gray-400 hover:text-red-500"
                            onClick={() => handleDeleteComment(comment.id)}
                            disabled={deletingComment === comment.id}
                          >
                            <Trash2 className="h-4 w-4" />
                          </Button>
                        )}
                      </div>
                      <p className="text-sm mt-1">{comment.content}</p>
                    </div>
                  </div>
                ))
              ) : (
                <p className="text-sm text-gray-500">Nenhum comentário ainda.</p>
              )}
            </div>

            {/* Formulário de novo comentário */}
            <div className="mt-4 flex items-center gap-3">
              <Avatar className="h-8 w-8">
                <AvatarFallback
                  style={{
                    background: stringToColor(user?.username || 'User'),
                    color: 'white'
                  }}
                >
                  {user?.username ? user.username.substring(0, 2).toUpperCase() : 'U'}
                </AvatarFallback>
              </Avatar>
              <div className="flex-1 flex gap-2">
                <Input
                  className="flex-1"
                  placeholder="O que você quer dizer..."
                  value={comment}
                  onChange={(e) => setComment(e.target.value)}
                  onKeyDown={(e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                      e.preventDefault();
                      handleAddComment();
                    }
                  }}
                />
                <Button 
                  variant="ghost" 
                  size="icon"
                  className="text-blue-600 hover:text-blue-800 hover:bg-blue-50"
                  onClick={handleAddComment}
                >
                  <MessageSquare className="h-4 w-4" />
                </Button>
              </div>
            </div>
          </div>
        </div>
      </DialogContent>

      {/* Dialog para editar a tarefa */}
      {showEditDialog && taskId && (
        <TaskDialog 
          open={showEditDialog} 
          onOpenChange={setShowEditDialog} 
          taskId={taskId} 
        />
      )}
    </Dialog>
  );
}
</file>

<file path="client/src/components/tasks/TaskDetailsPage.tsx">
import { useState, useEffect } from "react";
import { useRoute } from "wouter";
import { useTaskContext } from "@/context/TaskContext";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Textarea } from "@/components/ui/textarea";
import { Separator } from "@/components/ui/separator";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { format, formatDistanceToNow } from "date-fns";
import { ptBR } from "date-fns/locale";
import { ArrowLeft, Calendar, Clock, User, MessageSquare, CheckCircle, AlertCircle, XCircle, Send } from "lucide-react";
import { Link } from "wouter";
import TaskDialog from "./TaskDialog";

export default function TaskDetailsPage() {
  const [, params] = useRoute("/tarefas/:id");
  const taskId = params ? parseInt(params.id) : null;
  
  const { fetchTaskById, updateTask, addComment } = useTaskContext();
  const [task, setTask] = useState<any | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [showEditDialog, setShowEditDialog] = useState(false);
  const [comment, setComment] = useState("");
  const [submittingComment, setSubmittingComment] = useState(false);

  useEffect(() => {
    if (taskId) {
      setLoading(true);
      fetchTaskById(taskId)
        .then((fetchedTask) => {
          if (fetchedTask) {
            setTask(fetchedTask);
          } else {
            setError("Tarefa não encontrada");
          }
        })
        .catch((err) => {
          setError("Erro ao carregar detalhes da tarefa");
          console.error(err);
        })
        .finally(() => {
          setLoading(false);
        });
    }
  }, [taskId, fetchTaskById]);

  const handleStatusChange = async (newStatus: string) => {
    if (!task) return;
    
    try {
      const updatedTask = await updateTask(task.id, { 
        status: newStatus as "pending" | "in_progress" | "completed" | "cancelled" 
      });
      setTask(updatedTask);
    } catch (err) {
      console.error("Erro ao atualizar status:", err);
    }
  };

  const handleCommentSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!comment.trim() || !task) return;
    
    setSubmittingComment(true);
    try {
      const newComment = await addComment(task.id, comment);
      setComment("");
      
      // Atualizar a tarefa com o novo comentário
      setTask({
        ...task,
        comments: [...(task.comments || []), newComment]
      });
    } catch (err) {
      console.error("Erro ao adicionar comentário:", err);
    } finally {
      setSubmittingComment(false);
    }
  };

  const getPriorityBadge = (priority: string) => {
    switch (priority) {
      case "high":
        return <Badge variant="outline" className="bg-red-50 text-red-600 border-red-200">Alta</Badge>;
      case "medium":
        return <Badge variant="outline" className="bg-amber-50 text-amber-600 border-amber-200">Média</Badge>;
      case "low":
        return <Badge variant="outline" className="bg-green-50 text-green-600 border-green-200">Baixa</Badge>;
      default:
        return <Badge variant="outline">{priority}</Badge>;
    }
  };

  const getStatusBadge = (status: string) => {
    switch (status) {
      case "pending":
        return <Badge variant="outline" className="bg-blue-50 text-blue-600 border-blue-200">Pendente</Badge>;
      case "in_progress":
        return <Badge variant="outline" className="bg-purple-50 text-purple-600 border-purple-200">Em andamento</Badge>;
      case "completed":
        return <Badge variant="outline" className="bg-green-50 text-green-600 border-green-200">Concluída</Badge>;
      case "cancelled":
        return <Badge variant="outline" className="bg-red-50 text-red-600 border-red-200">Cancelada</Badge>;
      default:
        return <Badge variant="outline">{status}</Badge>;
    }
  };

  const getStatusIcon = (status: string) => {
    switch (status) {
      case "pending":
        return <AlertCircle className="h-5 w-5 text-blue-500" />;
      case "in_progress":
        return <Clock className="h-5 w-5 text-purple-500" />;
      case "completed":
        return <CheckCircle className="h-5 w-5 text-green-500" />;
      case "cancelled":
        return <XCircle className="h-5 w-5 text-red-500" />;
      default:
        return <AlertCircle className="h-5 w-5" />;
    }
  };

  const getStatusActions = () => {
    if (!task) return null;

    switch (task.status) {
      case "pending":
        return (
          <div className="flex gap-2">
            <Button 
              variant="outline" 
              size="sm" 
              className="text-purple-600 border-purple-200 hover:bg-purple-50"
              onClick={() => handleStatusChange("in_progress")}
            >
              Iniciar
            </Button>
            <Button 
              variant="outline" 
              size="sm" 
              className="text-red-600 border-red-200 hover:bg-red-50"
              onClick={() => handleStatusChange("cancelled")}
            >
              Cancelar
            </Button>
          </div>
        );
      case "in_progress":
        return (
          <div className="flex gap-2">
            <Button 
              variant="outline" 
              size="sm" 
              className="text-green-600 border-green-200 hover:bg-green-50"
              onClick={() => handleStatusChange("completed")}
            >
              Concluir
            </Button>
            <Button 
              variant="outline" 
              size="sm" 
              className="text-blue-600 border-blue-200 hover:bg-blue-50"
              onClick={() => handleStatusChange("pending")}
            >
              Pausar
            </Button>
          </div>
        );
      case "completed":
      case "cancelled":
        return (
          <Button 
            variant="outline" 
            size="sm" 
            className="text-blue-600 border-blue-200 hover:bg-blue-50"
            onClick={() => handleStatusChange("pending")}
          >
            Reabrir
          </Button>
        );
      default:
        return null;
    }
  };

  if (loading) {
    return (
      <div className="container mx-auto p-4 md:p-6">
        <div className="flex justify-center items-center h-64">
          <p>Carregando detalhes da tarefa...</p>
        </div>
      </div>
    );
  }

  if (error || !task) {
    return (
      <div className="container mx-auto p-4 md:p-6">
        <div className="flex flex-col justify-center items-center h-64">
          <p className="text-red-500 mb-4">{error || "Tarefa não encontrada"}</p>
          <Link href="/tarefas">
            <Button variant="outline">Voltar para tarefas</Button>
          </Link>
        </div>
      </div>
    );
  }

  return (
    <div className="container mx-auto p-4 md:p-6">
      <div className="mb-6">
        <Link href="/tarefas">
          <Button variant="ghost" className="flex items-center gap-2 mb-4">
            <ArrowLeft className="h-4 w-4" />
            Voltar para tarefas
          </Button>
        </Link>
        
        <div className="flex flex-col md:flex-row justify-between items-start md:items-center gap-4">
          <div className="flex items-center gap-3">
            {getStatusIcon(task.status)}
            <h1 className="text-2xl font-bold text-gray-900 dark:text-white">{task.title}</h1>
          </div>
          
          <div className="flex gap-2">
            <Button variant="outline" onClick={() => setShowEditDialog(true)}>
              Editar
            </Button>
            {getStatusActions()}
          </div>
        </div>
      </div>
      
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
        <div className="md:col-span-2">
          <Card className="p-6">
            <div className="flex justify-between mb-4">
              <div className="flex gap-2">
                {getPriorityBadge(task.priority)}
                {getStatusBadge(task.status)}
              </div>
              
              {task.dueDate && (
                <div className="flex items-center gap-2 text-sm text-gray-600 dark:text-gray-300">
                  <Calendar className="h-4 w-4" />
                  <span>Prazo: {format(new Date(task.dueDate), "dd/MM/yyyy", { locale: ptBR })}</span>
                </div>
              )}
            </div>
            
            {task.description ? (
              <p className="text-gray-700 dark:text-gray-200 mb-6">{task.description}</p>
            ) : (
              <p className="text-gray-500 dark:text-gray-400 italic mb-6">Sem descrição</p>
            )}
            
            <Separator className="my-4" />
            
            <h2 className="text-lg font-semibold mb-4 flex items-center gap-2">
              <MessageSquare className="h-5 w-5 text-gray-500" />
              Comentários
            </h2>
            
            <div className="space-y-4 mb-6">
              {task.comments && task.comments.length > 0 ? (
                task.comments.map((comment: any) => (
                  <div key={comment.id} className="flex gap-3">
                    <Avatar className="h-8 w-8">
                      <AvatarFallback>
                        {comment.userName?.charAt(0) || "U"}
                      </AvatarFallback>
                    </Avatar>
                    <div className="flex-1">
                      <div className="flex justify-between items-center mb-1">
                        <span className="font-medium text-sm">{comment.userName}</span>
                        <span className="text-xs text-gray-500">
                          {formatDistanceToNow(new Date(comment.createdAt), { 
                            addSuffix: true, 
                            locale: ptBR 
                          })}
                        </span>
                      </div>
                      <p className="text-sm text-gray-700 dark:text-gray-300">{comment.content}</p>
                    </div>
                  </div>
                ))
              ) : (
                <p className="text-gray-500 dark:text-gray-400 text-sm italic">
                  Nenhum comentário ainda
                </p>
              )}
            </div>
            
            <form onSubmit={handleCommentSubmit} className="flex flex-col gap-3">
              <Textarea 
                placeholder="Adicione um comentário..."
                value={comment}
                onChange={(e) => setComment(e.target.value)}
                disabled={submittingComment}
                className="min-h-[80px]"
              />
              <div className="flex justify-end">
                <Button 
                  type="submit" 
                  disabled={!comment.trim() || submittingComment}
                  className="flex items-center gap-2"
                >
                  <Send className="h-4 w-4" />
                  {submittingComment ? "Enviando..." : "Enviar"}
                </Button>
              </div>
            </form>
          </Card>
        </div>
        
        <div>
          <Card className="p-6">
            <h2 className="font-semibold mb-4">Detalhes</h2>
            
            <div className="space-y-4">
              <div>
                <p className="text-sm text-gray-500 dark:text-gray-400">Atribuído a</p>
                <div className="flex items-center gap-2 mt-1">
                  <Avatar className="h-6 w-6">
                    <AvatarFallback>{task.assignedToName?.charAt(0) || "U"}</AvatarFallback>
                  </Avatar>
                  <span>{task.assignedToName}</span>
                </div>
              </div>
              
              <div>
                <p className="text-sm text-gray-500 dark:text-gray-400">Criado por</p>
                <div className="flex items-center gap-2 mt-1">
                  <Avatar className="h-6 w-6">
                    <AvatarFallback>{task.assignedByName?.charAt(0) || "U"}</AvatarFallback>
                  </Avatar>
                  <span>{task.assignedByName}</span>
                </div>
              </div>
              
              {task.relatedLeadName && (
                <div>
                  <p className="text-sm text-gray-500 dark:text-gray-400">Lead relacionado</p>
                  <div className="flex items-center gap-2 mt-1">
                    <User className="h-4 w-4 text-gray-400" />
                    <span>{task.relatedLeadName}</span>
                  </div>
                </div>
              )}
              
              <div>
                <p className="text-sm text-gray-500 dark:text-gray-400">Data de criação</p>
                <p className="mt-1">{format(new Date(task.createdAt), "dd/MM/yyyy", { locale: ptBR })}</p>
              </div>
              
              <div>
                <p className="text-sm text-gray-500 dark:text-gray-400">Última atualização</p>
                <p className="mt-1">{format(new Date(task.updatedAt), "dd/MM/yyyy", { locale: ptBR })}</p>
              </div>
            </div>
          </Card>
        </div>
      </div>
      
      {showEditDialog && (
        <TaskDialog 
          open={showEditDialog} 
          onOpenChange={setShowEditDialog} 
          taskId={task.id} 
        />
      )}
    </div>
  );
}
</file>

<file path="client/src/components/tasks/TaskDialog.tsx">
import { useState, useEffect } from "react";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter, DialogClose, DialogDescription } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Calendar } from "@/components/ui/calendar";
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import { format, addDays } from "date-fns";
import { ptBR } from "date-fns/locale";
import { CalendarIcon, ChevronLeft, Clock, User, BarChart3, Users } from "lucide-react";
import { cn } from "@/lib/utils";
import { useTaskContext } from "@/context/TaskContext";
import { useAuth } from "@/hooks/use-auth";
import { Badge } from "@/components/ui/badge";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group";
import { Separator } from "@/components/ui/separator";

interface TaskDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  taskId?: number;
  initialStatus?: string;
}

export default function TaskDialog({ open, onOpenChange, taskId, initialStatus = "pending" }: TaskDialogProps) {
  const { createTask, fetchTaskById, updateTask } = useTaskContext();
  const { user } = useAuth();
  const isEditing = !!taskId;

  const [title, setTitle] = useState("");
  const [description, setDescription] = useState("");
  const [assignedToId, setAssignedToId] = useState<number | null>(null);
  const [priority, setPriority] = useState<"low" | "medium" | "high">("medium");
  const [status, setStatus] = useState<"backlog" | "pending" | "in_progress" | "completed" | "cancelled">((initialStatus as "backlog" | "pending" | "in_progress" | "completed" | "cancelled") || "pending");
  const [dueDate, setDueDate] = useState<Date | undefined>(addDays(new Date(), 3));
  const [isLoading, setIsLoading] = useState(false);
  const [calendarOpen, setCalendarOpen] = useState(false);
  const [showBackButton, setShowBackButton] = useState(false);
  const [currentStep, setCurrentStep] = useState<"details" | "assignment">("details");
  const [users, setUsers] = useState<Array<{id: number, username: string, role: string}>>([]);
  const [loadingUsers, setLoadingUsers] = useState(false);

  // Carregar usuários do sistema
  useEffect(() => {
    const fetchUsers = async () => {
      setLoadingUsers(true);
      try {
        const response = await fetch('/api/users');
        if (response.ok) {
          const data = await response.json();
          setUsers(data);
        } else {
          console.error('Erro ao buscar usuários:', response.statusText);
        }
      } catch (error) {
        console.error('Erro ao buscar usuários:', error);
      } finally {
        setLoadingUsers(false);
      }
    };

    fetchUsers();
  }, []);

  // Carregar detalhes da tarefa se estiver editando
  useEffect(() => {
    if (isEditing && taskId) {
      setIsLoading(true);
      fetchTaskById(taskId).then((task) => {
        if (task) {
          setTitle(task.title);
          setDescription(task.description || "");
          setAssignedToId(task.assignedToId);
          setPriority(task.priority as "low" | "medium" | "high");
          setStatus(task.status as "backlog" | "pending" | "in_progress" | "completed" | "cancelled");
          if (task.dueDate) {
            setDueDate(new Date(task.dueDate));
          }
        }
        setIsLoading(false);
      }).catch(error => {
        console.error("Erro ao carregar tarefa:", error);
        setIsLoading(false);
      });
    }
  }, [isEditing, taskId, fetchTaskById]);

  const handleNextStep = () => {
    if (currentStep === "details") {
      setCurrentStep("assignment");
      setShowBackButton(true);
    }
  };

  const handlePrevStep = () => {
    if (currentStep === "assignment") {
      setCurrentStep("details");
      setShowBackButton(false);
    }
  };

  const handleSubmit = async () => {
    if (!title || !assignedToId) return;

    setIsLoading(true);
    try {
      // Usar o ID do usuário autenticado como criador da tarefa
      const assignedById = user?.id || 1;

      const taskData = {
        title,
        description,
        assignedById,
        assignedToId,
        dueDate,
        priority,
        status
      };

      if (isEditing && taskId) {
        await updateTask(taskId, taskData);
      } else {
        await createTask(taskData);
      }

      // Fechar o diálogo após salvar
      onOpenChange(false);

    } catch (error) {
      console.error("Erro ao salvar tarefa:", error);
    } finally {
      setIsLoading(false);
    }
  };

  const getPriorityColor = (priorityValue: string) => {
    switch (priorityValue) {
      case "high":
        return "text-red-500 border-red-200 bg-red-50 dark:bg-red-900/20";
      case "medium":
        return "text-amber-500 border-amber-200 bg-amber-50 dark:bg-amber-900/20";
      case "low":
        return "text-green-500 border-green-200 bg-green-50 dark:bg-green-900/20";
      default:
        return "text-gray-500 border-gray-200 bg-gray-50 dark:bg-gray-800/30";
    }
  };

  // Renderização de ícones para os campos
  const renderIcon = (type: string) => {
    switch (type) {
      case "user":
        return <User className="h-4 w-4 text-gray-400" />;
      case "calendar":
        return <CalendarIcon className="h-4 w-4 text-gray-400" />;
      case "priority":
        return <BarChart3 className="h-4 w-4 text-gray-400" />;
      case "time":
        return <Clock className="h-4 w-4 text-gray-400" />;
      case "users":
        return <Users className="h-4 w-4 text-gray-400" />;
      default:
        return null;
    }
  };

  // Função para formatar iniciais do nome do usuário para o avatar
  const getUserInitials = (username: string) => {
    return username.substring(0, 2).toUpperCase() || "UN";
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[550px] p-0 overflow-hidden">
        <div className="flex items-center px-6 py-4 border-b">
          {showBackButton && (
            <Button variant="ghost" size="icon" onClick={handlePrevStep} className="mr-2">
              <ChevronLeft className="h-4 w-4" />
            </Button>
          )}
          <DialogHeader>
          <DialogTitle className="text-xl">
            {isEditing ? "Editar Tarefa" : "Criar Tarefa"}
          </DialogTitle>
          <DialogDescription>
            {isEditing ? "Atualize as informações da tarefa" : "Preencha os dados para criar uma nova tarefa"}
          </DialogDescription>
        </DialogHeader>
          <div className="ml-auto">
            {currentStep === "assignment" && assignedToId && (
              <div className="flex items-center gap-2">
                <span className="text-sm text-gray-500">Atribuído para:</span>
                <Avatar className="h-6 w-6">
                  <AvatarFallback className="text-xs bg-blue-100 text-blue-600">
                    {users.find(u => u.id === assignedToId)?.username.substring(0, 2).toUpperCase() || "UN"}
                  </AvatarFallback>
                </Avatar>
              </div>
            )}
          </div>
        </div>

        {currentStep === "details" && (
          <div className="p-6">
            <div className="space-y-4">
              <div>
                <Label htmlFor="title" className="text-sm font-medium text-gray-700 dark:text-gray-300">
                  Título da tarefa
                </Label>
                <Input
                  id="title"
                  value={title}
                  onChange={(e) => setTitle(e.target.value)}
                  placeholder="Digite o título da tarefa"
                  disabled={isLoading}
                  className="mt-1"
                />
              </div>

              <div>
                <Label htmlFor="description" className="text-sm font-medium text-gray-700 dark:text-gray-300">
                  Descrição
                </Label>
                <Textarea
                  id="description"
                  value={description}
                  onChange={(e) => setDescription(e.target.value)}
                  placeholder="Descreva os detalhes da tarefa"
                  disabled={isLoading}
                  className="mt-1 min-h-[120px]"
                />
              </div>

              <div className="grid grid-cols-2 gap-4">
                <div>
                  <Label htmlFor="priority" className="text-sm font-medium flex items-center text-gray-700 dark:text-gray-300">
                    {renderIcon("priority")}
                    <span className="ml-2">Prioridade</span>
                  </Label>
                  <RadioGroup 
                    value={priority} 
                    onValueChange={(value) => setPriority(value as "low" | "medium" | "high")}
                    className="flex mt-2 space-x-2"
                  >
                    <div className="flex items-center">
                      <RadioGroupItem value="low" id="low" className="sr-only" />
                      <Label
                        htmlFor="low"
                        className={`px-3 py-1.5 text-xs font-medium rounded-full border cursor-pointer ${
                          priority === "low" 
                            ? getPriorityColor("low") 
                            : "bg-gray-50 text-gray-600 dark:bg-gray-800 dark:text-gray-400"
                        }`}
                      >
                        Baixa
                      </Label>
                    </div>
                    <div className="flex items-center">
                      <RadioGroupItem value="medium" id="medium" className="sr-only" />
                      <Label
                        htmlFor="medium"
                        className={`px-3 py-1.5 text-xs font-medium rounded-full border cursor-pointer ${
                          priority === "medium" 
                            ? getPriorityColor("medium") 
                            : "bg-gray-50 text-gray-600 dark:bg-gray-800 dark:text-gray-400"
                        }`}
                      >
                        Média
                      </Label>
                    </div>
                    <div className="flex items-center">
                      <RadioGroupItem value="high" id="high" className="sr-only" />
                      <Label
                        htmlFor="high"
                        className={`px-3 py-1.5 text-xs font-medium rounded-full border cursor-pointer ${
                          priority === "high" 
                            ? getPriorityColor("high") 
                            : "bg-gray-50 text-gray-600 dark:bg-gray-800 dark:text-gray-400"
                        }`}
                      >
                        Alta
                      </Label>
                    </div>
                  </RadioGroup>
                </div>

                <div>
                  <Label htmlFor="due-date" className="text-sm font-medium flex items-center text-gray-700 dark:text-gray-300">
                    {renderIcon("calendar")}
                    <span className="ml-2">Data de vencimento</span>
                  </Label>
                  <Popover open={calendarOpen} onOpenChange={setCalendarOpen}>
                    <PopoverTrigger asChild>
                      <Button
                        id="due-date"
                        variant="outline"
                        className={cn(
                          "w-full mt-2 justify-start text-left font-normal",
                          !dueDate && "text-muted-foreground"
                        )}
                        disabled={isLoading}
                      >
                        <CalendarIcon className="mr-2 h-4 w-4" />
                        {dueDate ? format(dueDate, "dd 'de' MMMM", { locale: ptBR }) : "Selecione uma data"}
                      </Button>
                    </PopoverTrigger>
                    <PopoverContent className="w-auto p-0" align="start">
                      <Calendar
                        mode="single"
                        selected={dueDate}
                        onSelect={(date) => {
                          setDueDate(date);
                          setCalendarOpen(false);
                        }}
                        initialFocus
                      />
                    </PopoverContent>
                  </Popover>
                </div>
              </div>

              <div>
                <Label htmlFor="assigned-to" className="text-sm font-medium flex items-center text-gray-700 dark:text-gray-300">
                  {renderIcon("users")}
                  <span className="ml-2">Atribuir para</span>
                </Label>
                <Select
                  value={assignedToId?.toString() || ""}
                  onValueChange={(value) => setAssignedToId(parseInt(value))}
                  disabled={isLoading || loadingUsers}
                >
                  <SelectTrigger id="assigned-to" className="mt-1">
                    <SelectValue placeholder="Selecione um usuário" />
                  </SelectTrigger>
                  <SelectContent>
                    {loadingUsers ? (
                      <div className="p-2 text-sm text-center text-muted-foreground">
                        Carregando usuários...
                      </div>
                    ) : users.length > 0 ? (
                      users.map((user) => (
                        <SelectItem key={user.id} value={user.id.toString()}>
                          {user.username} {user.role === "admin" && "(Admin)"}
                        </SelectItem>
                      ))
                    ) : (
                      <div className="p-2 text-sm text-center text-muted-foreground">
                        Nenhum usuário encontrado
                      </div>
                    )}
                  </SelectContent>
                </Select>
              </div>

              {isEditing && (
                <div>
                  <Label htmlFor="status" className="text-sm font-medium text-gray-700 dark:text-gray-300">
                    Status
                  </Label>
                  <Select
                    value={status}
                    onValueChange={(value) => setStatus(value as "backlog" | "pending" | "in_progress" | "completed" | "cancelled")}
                    disabled={isLoading}
                  >
                    <SelectTrigger id="status" className="mt-1">
                      <SelectValue />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="backlog">Backlog</SelectItem>
                      <SelectItem value="pending">Pendente</SelectItem>
                      <SelectItem value="in_progress">Em andamento</SelectItem>
                      <SelectItem value="completed">Concluída</SelectItem>
                      <SelectItem value="cancelled">Cancelada</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
              )}
            </div>
          </div>
        )}

        {currentStep === "assignment" && (
          <div className="p-6">
            <div className="space-y-6">
              <div>
                <Label className="text-sm font-medium flex items-center text-gray-700 dark:text-gray-300">
                  {renderIcon("user")}
                  <span className="ml-2">Atribuir para</span>
                </Label>
                <div className="grid grid-cols-1 gap-3 mt-3">
                  {loadingUsers ? (
                    <div className="flex justify-center items-center p-6 text-gray-500">
                      <div className="animate-spin h-6 w-6 border-2 border-gray-500 border-opacity-50 border-t-transparent rounded-full mr-2"></div>
                      Carregando usuários...
                    </div>
                  ) : users.length > 0 ? (
                    users.map((user) => (
                      <div 
                        key={user.id}
                        className={`flex items-center p-3 rounded-lg border cursor-pointer ${
                          assignedToId === user.id 
                            ? "bg-blue-50 border-blue-200 dark:bg-blue-900/20 dark:border-blue-800" 
                            : "bg-white dark:bg-gray-800 border-gray-200 dark:border-gray-700"
                        }`}
                        onClick={() => setAssignedToId(user.id)}
                      >
                        <Avatar className="h-8 w-8 mr-3">
                          <AvatarFallback className={`${
                            assignedToId === user.id 
                              ? "bg-blue-100 text-blue-600" 
                              : "bg-gray-100 text-gray-600 dark:bg-gray-700 dark:text-gray-200"
                          }`}>
                            {getUserInitials(user.username)}
                          </AvatarFallback>
                        </Avatar>
                        <div className="flex-1">
                          <p className="text-sm font-medium text-gray-900 dark:text-white">{user.username}</p>
                          <p className="text-xs text-gray-500 dark:text-gray-400">
                            {user.role === "admin" ? "Administrador" : "Usuário"}
                          </p>
                        </div>
                        {assignedToId === user.id && (
                          <div className="flex-shrink-0 ml-2">
                            <div className="w-4 h-4 rounded-full bg-blue-500"></div>
                          </div>
                        )}
                      </div>
                    ))
                  ) : (
                    <div className="p-3 text-center text-sm text-gray-500">
                      Nenhum usuário encontrado no sistema
                    </div>
                  )}
                </div>
              </div>
            </div>
          </div>
        )}

        <DialogFooter className="p-4 border-t">
          <div className="flex justify-between w-full">
            <DialogClose asChild>
              <Button variant="outline" disabled={isLoading}>
                Cancelar
              </Button>
            </DialogClose>
            <Button onClick={handleSubmit} disabled={isLoading || !title || !assignedToId}>
              {isLoading ? 
                <div className="flex items-center">
                  <span className="mr-2">Salvando</span>
                  <div className="animate-spin h-4 w-4 border-2 border-white border-opacity-50 border-t-transparent rounded-full"></div>
                </div>
                : 
                isEditing ? "Atualizar" : "Criar Tarefa"
              }
            </Button>
          </div>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="client/src/components/tasks/TasksPage.tsx">
import { useState, useEffect } from "react";
import { useTaskContext } from "@/context/TaskContext";
import TaskCard from "./TaskCard";
import TaskDialog from "./TaskDialog";
import TaskDetailDialog from "./TaskDetailDialog";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Button } from "@/components/ui/button";
import {
  AlertCircle,
  Clock,
  CheckCircle,
  PlusCircle,
  ListFilter,
  LayoutGrid,
  LayoutList,
  ArrowUpDown,
  Filter,
  Calendar,
  MessageSquare,
  Paperclip,
  Bell
} from "lucide-react";
import { Input } from "@/components/ui/input";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import KanbanBoard from "./KanbanBoard";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger
} from "@/components/ui/dropdown-menu";
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { format } from "date-fns";
import { ptBR } from "date-fns/locale";
import { Checkbox } from "@/components/ui/checkbox";
import { Link } from "wouter";

// Função para gerar cor consistente com base em uma string
function stringToColor(str: string) {
  let hash = 0;
  if (!str) return '#70a0ea';
  for (let i = 0; i < str.length; i++) {
    hash = str.charCodeAt(i) + ((hash << 5) - hash);
    hash = hash & hash;
  }
  
  const colors = [
    '#3b82f6', // blue
    '#ef4444', // red
    '#10b981', // green
    '#f59e0b', // amber
    '#8b5cf6', // violet
    '#ec4899', // pink
    '#14b8a6', // teal
    '#f43f5e', // rose
    '#6366f1', // indigo
    '#84cc16', // lime
    '#06b6d4', // cyan
    '#22c55e', // emerald
  ];
  
  return colors[Math.abs(hash) % colors.length];
}

export default function TasksPage() {
  const { 
    tasks, 
    loading, 
    error, 
    fetchTasks, 
    updateTask,
    myTasks, 
    assignedTasks, 
    completedTasks 
  } = useTaskContext();
  
  const [searchQuery, setSearchQuery] = useState("");
  const [showCreateTaskDialog, setShowCreateTaskDialog] = useState(false);
  const [selectedTaskStatus, setSelectedTaskStatus] = useState<string | undefined>(undefined);
  const [showTaskDetailDialog, setShowTaskDetailDialog] = useState(false);
  const [selectedTaskId, setSelectedTaskId] = useState<number | null>(null);
  const [activeTab, setActiveTab] = useState("my-tasks");
  const [viewMode, setViewMode] = useState<"board" | "list">("board");
  const [sortBy, setSortBy] = useState<"due" | "priority" | "recent">("recent");
  
  // Tarefas organizadas por status
  const pendingTasks = tasks.filter(task => task.status === "pending");
  const inProgressTasks = tasks.filter(task => task.status === "in_progress");
  const completedTasksList = tasks.filter(task => task.status === "completed");
  
  useEffect(() => {
    fetchTasks();
  }, [fetchTasks]);
  
  const handleStatusChange = async (taskId: number, newStatus: string) => {
    await updateTask(taskId, { status: newStatus as "backlog" | "pending" | "in_progress" | "completed" | "cancelled" });
  };
  
  const handleOpenTaskDetails = (taskId: number) => {
    setSelectedTaskId(taskId);
    setShowTaskDetailDialog(true);
  };
  
  const filterTasks = (taskList: any[]) => {
    if (!searchQuery) return taskList;
    
    const query = searchQuery.toLowerCase();
    return taskList.filter(task => 
      task.title.toLowerCase().includes(query) || 
      (task.description && task.description.toLowerCase().includes(query)) ||
      (task.assignedToName && task.assignedToName.toLowerCase().includes(query))
      // No longer filtering by relatedLeadName as tasks are now assigned to system users only
    );
  };
  
  const sortTasks = (tasks: any[]) => {
    if (sortBy === "due") {
      return [...tasks].sort((a, b) => {
        if (!a.dueDate) return 1;
        if (!b.dueDate) return -1;
        return new Date(a.dueDate).getTime() - new Date(b.dueDate).getTime();
      });
    } else if (sortBy === "priority") {
      const priorityValue = { high: 3, medium: 2, low: 1 };
      return [...tasks].sort((a, b) => 
        priorityValue[b.priority as keyof typeof priorityValue] - 
        priorityValue[a.priority as keyof typeof priorityValue]
      );
    } else {
      // recent (default)
      return [...tasks].sort((a, b) => 
        new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime()
      );
    }
  };
  
  const filteredMyTasks = sortTasks(filterTasks(myTasks));
  const filteredAssignedTasks = sortTasks(filterTasks(assignedTasks));
  const filteredCompletedTasks = sortTasks(filterTasks(completedTasks));
  
  const filteredPendingTasks = sortTasks(filterTasks(pendingTasks));
  const filteredInProgressTasks = sortTasks(filterTasks(inProgressTasks));
  const filteredCompletedTasksList = sortTasks(filterTasks(completedTasksList));
  
  // Helper functions for UI components
  const getStatusColor = (status: string) => {
    switch (status) {
      case "pending":
        return "text-amber-500 border-amber-200 bg-amber-50 dark:bg-amber-900/20";
      case "in_progress":
        return "text-blue-500 border-blue-200 bg-blue-50 dark:bg-blue-900/20";
      case "completed":
        return "text-green-500 border-green-200 bg-green-50 dark:bg-green-900/20";
      case "cancelled":
        return "text-red-500 border-red-200 bg-red-50 dark:bg-red-900/20";
      default:
        return "text-gray-500 border-gray-200 bg-gray-50 dark:bg-gray-800/30";
    }
  };

  const getPriorityColor = (priority: string) => {
    switch (priority) {
      case "high":
        return "bg-red-500";
      case "medium":
        return "bg-amber-500";
      case "low":
        return "bg-green-500";
      default:
        return "bg-gray-500";
    }
  };
  
  const getStatusLabel = (status: string) => {
    switch (status) {
      case "pending":
        return "A fazer";
      case "in_progress":
        return "Em andamento";
      case "completed":
        return "Concluído";
      case "cancelled":
        return "Cancelado";
      default:
        return status;
    }
  };
  
  const getTaskCardBorderColor = (status: string) => {
    switch (status) {
      case "pending":
        return "border-l-amber-500 dark:border-l-amber-400";
      case "in_progress":
        return "border-l-blue-500 dark:border-l-blue-400";
      case "completed":
        return "border-l-green-500 dark:border-l-green-400";
      case "cancelled":
        return "border-l-red-500 dark:border-l-red-400";
      default:
        return "border-l-gray-300 dark:border-l-gray-700";
    }
  };
  
  // Compact task card component for board view
  const TaskBoardCard = ({ task }: { task: any }) => {
    // Gerar um código e cor para o cartão baseado no seu status
    const getCardCode = () => {
      switch(task.status) {
        case 'pending':
          return { code: 'TD', color: 'text-yellow-700 bg-yellow-50' };
        case 'in_progress':
          return { code: 'IP', color: 'text-blue-700 bg-blue-50' };
        case 'completed':
          return { code: 'RV', color: 'text-green-700 bg-green-50' };
        default:
          return { code: 'TK', color: 'text-gray-700 bg-gray-50' };
      }
    };
    
    const { code, color } = getCardCode();
    const cardId = `${code}-${String(task.id).padStart(3, '0')}`;
    
    // Determinar a cor da barra de prioridade
    const priorityColor = task.priority === 'high' ? 'bg-orange-500' : 
                         task.priority === 'medium' ? 'bg-yellow-400' : 'bg-green-500';
                          
    const hasComments = task.comments?.length > 0 || false;
    const hasAttachments = task.attachments?.length > 0 || false;
    const commentCount = task.comments?.length || 0;
                          
    return (
      <Card 
        className="p-0 mb-3 overflow-hidden bg-white dark:bg-gray-800 hover:shadow-md transition-all cursor-pointer border border-gray-100 dark:border-gray-700 hover:border-gray-300 dark:hover:border-gray-600 relative"
        onClick={() => handleOpenTaskDetails(task.id)}
      >
        {/* Notification indicator */}
        {(hasComments || hasAttachments) && (
          <div className="absolute -top-1 -right-1 bg-blue-500 text-white rounded-full w-5 h-5 flex items-center justify-center text-xs shadow-md z-10" title={
            hasComments && hasAttachments 
              ? "Possui comentários e anexos"
              : hasComments 
              ? `${commentCount} comentário${commentCount > 1 ? 's' : ''}`
              : "Possui anexos"
          }>
            {hasComments && hasAttachments ? (
              "+"
            ) : hasComments ? (
              <MessageSquare className="h-3 w-3" />
            ) : (
              <Paperclip className="h-3 w-3" />
            )}
          </div>
        )}
        
        {/* Cabeçalho do cartão com código e menu */}
        <div className="flex items-center justify-between p-3 pb-1 pl-4">
          <div className={`text-xs ${color} px-1.5 py-0.5 rounded font-medium flex items-center`}>
            {cardId}
          </div>
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="ghost" size="sm" className="h-6 w-6 p-0">
                <svg width="15" height="15" viewBox="0 0 15 15" fill="none" xmlns="http://www.w3.org/2000/svg" className="h-4 w-4">
                  <path d="M3.625 7.5C3.625 8.12132 3.12132 8.625 2.5 8.625C1.87868 8.625 1.375 8.12132 1.375 7.5C1.375 6.87868 1.87868 6.375 2.5 6.375C3.12132 6.375 3.625 6.87868 3.625 7.5ZM8.625 7.5C8.625 8.12132 8.12132 8.625 7.5 8.625C6.87868 8.625 6.375 8.12132 6.375 7.5C6.375 6.87868 6.87868 6.375 7.5 6.375C8.12132 6.375 8.625 6.87868 8.625 7.5ZM13.625 7.5C13.625 8.12132 13.1213 8.625 12.5 8.625C11.8787 8.625 11.375 8.12132 11.375 7.5C11.375 6.87868 11.8787 6.375 12.5 6.375C13.1213 6.375 13.625 6.87868 13.625 7.5Z" fill="currentColor" fillRule="evenodd" clipRule="evenodd"></path>
                </svg>
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              <DropdownMenuItem onClick={() => handleStatusChange(task.id, "pending")}>
                Mover para A fazer
              </DropdownMenuItem>
              <DropdownMenuItem onClick={() => handleStatusChange(task.id, "in_progress")}>
                Mover para Em andamento
              </DropdownMenuItem>
              <DropdownMenuItem onClick={() => handleStatusChange(task.id, "completed")}>
                Marcar como Concluída
              </DropdownMenuItem>
              <DropdownMenuItem onClick={(e) => {
                e.stopPropagation(); // Prevenir que o clique propague para o cartão
                handleOpenTaskDetails(task.id);
              }}>
                Ver detalhes
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
        </div>
        
        {/* Título da tarefa */}
        <div className="px-4 pt-1 pb-2">
          <h4 className="font-medium text-sm">{task.title}</h4>
          {task.description && (
            <p className="text-xs text-gray-600 dark:text-gray-400 line-clamp-2 mt-1">
              {task.description}
            </p>
          )}
        </div>
        
        {/* Indicador de prioridade como uma barra lateral */}
        <div className={`absolute top-0 left-0 w-1 h-full ${priorityColor}`}></div>
        
        {/* Rodapé com metadados */}
        <div className="flex justify-between items-center border-t border-gray-100 dark:border-gray-700 pt-2 px-4 pb-3">
          <div className="flex items-center gap-1">
            {task.relatedLeadName && (
              <Badge variant="outline" className="text-[10px] px-1.5 h-4 bg-blue-50 text-blue-700 dark:bg-blue-900 dark:text-blue-300 border-blue-200 dark:border-blue-800">
                {task.relatedLeadName.split(' ')[0]}
              </Badge>
            )}
            
            {task.dueDate && (
              <Badge variant="outline" className="text-[10px] px-1.5 h-4 bg-amber-50 text-amber-700 dark:bg-amber-900 dark:text-amber-300 border-amber-200 dark:border-amber-800 flex items-center gap-1">
                <svg 
                  xmlns="http://www.w3.org/2000/svg" 
                  width="10" 
                  height="10" 
                  viewBox="0 0 24 24" 
                  fill="none"
                  stroke="currentColor" 
                  strokeWidth="2" 
                  strokeLinecap="round" 
                  strokeLinejoin="round"
                  className="h-2.5 w-2.5"
                >
                  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
                  <line x1="16" y1="2" x2="16" y2="6"></line>
                  <line x1="8" y1="2" x2="8" y2="6"></line>
                  <line x1="3" y1="10" x2="21" y2="10"></line>
                </svg>
                {format(new Date(task.dueDate), "dd/MM", { locale: ptBR })}
              </Badge>
            )}
          </div>
          
          <div className="flex items-center gap-2">
            <div className="flex gap-1.5 items-center">
              <span className="flex items-center gap-0.5" title={task.comments?.length > 0 ? `${task.comments.length} comentário${task.comments.length !== 1 ? 's' : ''}` : "Sem comentários"}>
                <MessageSquare className="h-3 w-3 text-gray-500 dark:text-gray-400" />
                {task.comments?.length > 0 && (
                  <span className="text-xs text-gray-500 dark:text-gray-400">{task.comments.length}</span>
                )}
              </span>
              <span className="flex items-center gap-0.5" title={task.attachments?.length > 0 ? "Possui anexos" : "Sem anexos"}>
                <Paperclip className="h-3 w-3 text-gray-500 dark:text-gray-400" />
                {task.attachments?.length > 0 && (
                  <span className="block h-1.5 w-1.5 rounded-full bg-blue-500"></span>
                )}
              </span>
            </div>
            
            <Avatar className="h-5 w-5 ring-2 ring-white dark:ring-gray-800">
              <AvatarFallback 
                className="text-[10px] font-medium"
                style={{
                  background: stringToColor(task.assignedToName || 'User'),
                  color: 'white'
                }}
              >
                {task.assignedToName?.substring(0, 2).toUpperCase() || 'U'}
              </AvatarFallback>
            </Avatar>
          </div>
        </div>
      </Card>
    );
  };
  
  const renderListView = (tasksList: any[]) => (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
      {tasksList.map((task) => (
        <TaskCard
          key={task.id}
          id={task.id}
          title={task.title}
          description={task.description}
          assignedToName={task.assignedToName || ""}
          assignedByName={task.assignedByName || ""}
          dueDate={task.dueDate}
          priority={task.priority}
          status={task.status}
          relatedLeadName={task.relatedLeadName}
          commentCount={task.comments?.length || 0}
          hasAttachments={task.attachments?.length > 0 || false}
          onStatusChange={handleStatusChange}
          onOpenDetails={handleOpenTaskDetails}
        />
      ))}
    </div>
  );
  
  const handleCreateTask = (initialStatus?: string) => {
    // Garantir que apenas status válidos são usados
    if (initialStatus && ["backlog", "pending", "in_progress", "completed", "cancelled"].includes(initialStatus)) {
      setSelectedTaskStatus(initialStatus);
    } else {
      setSelectedTaskStatus("pending"); // Default fallback
    }
    setShowCreateTaskDialog(true);
  };
  
  return (
    <div className="container mx-auto p-4 md:p-6">
      <div className="flex flex-col md:flex-row justify-between items-start md:items-center gap-4 mb-6">
        <div>
        </div>
        
        <div className="flex flex-wrap gap-3 w-full md:w-auto">
          <Input
            placeholder="Buscar tarefas..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className="md:w-64"
          />
          
          <div className="flex border rounded-md overflow-hidden">
            <Button 
              variant={viewMode === "board" ? "default" : "ghost"}
              size="sm"
              className={`rounded-none px-3 ${viewMode === 'board' ? 'bg-primary text-primary-foreground' : ''}`}
              onClick={() => setViewMode("board")}
            >
              <LayoutGrid className="h-4 w-4" />
            </Button>
            <Button 
              variant={viewMode === "list" ? "default" : "ghost"}
              size="sm"
              className={`rounded-none px-3 ${viewMode === 'list' ? 'bg-primary text-primary-foreground' : ''}`}
              onClick={() => setViewMode("list")}
            >
              <LayoutList className="h-4 w-4" />
            </Button>
          </div>
          
          <Select value={sortBy} onValueChange={(value) => setSortBy(value as "due" | "priority" | "recent")}>
            <SelectTrigger className="w-[180px]">
              <div className="flex items-center">
                <ArrowUpDown className="h-4 w-4 mr-2" />
                <span>Ordenar por</span>
              </div>
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="recent">Mais recentes</SelectItem>
              <SelectItem value="priority">Prioridade</SelectItem>
              <SelectItem value="due">Data de vencimento</SelectItem>
            </SelectContent>
          </Select>
          
          <Button 
            onClick={() => handleCreateTask()}
            className="flex items-center gap-2"
          >
            <PlusCircle className="h-4 w-4" />
            Nova Tarefa
          </Button>
        </div>
      </div>
      
      {viewMode === "list" ? (
        <Tabs defaultValue="my-tasks" value={activeTab} onValueChange={setActiveTab} className="w-full">
          <TabsList className="grid w-full grid-cols-3 mb-6">
            <TabsTrigger value="my-tasks" className="flex items-center gap-2">
              <Clock className="h-4 w-4" />
              Minhas Tarefas
              {myTasks.length > 0 && (
                <span className="text-xs bg-blue-100 text-blue-600 rounded-full px-2 py-0.5 ml-1">
                  {myTasks.length}
                </span>
              )}
            </TabsTrigger>
            <TabsTrigger value="assigned-tasks" className="flex items-center gap-2">
              <AlertCircle className="h-4 w-4" />
              Delegadas
              {assignedTasks.length > 0 && (
                <span className="text-xs bg-purple-100 text-purple-600 rounded-full px-2 py-0.5 ml-1">
                  {assignedTasks.length}
                </span>
              )}
            </TabsTrigger>
            <TabsTrigger value="completed-tasks" className="flex items-center gap-2">
              <CheckCircle className="h-4 w-4" />
              Concluídas
              {completedTasks.length > 0 && (
                <span className="text-xs bg-green-100 text-green-600 rounded-full px-2 py-0.5 ml-1">
                  {completedTasks.length}
                </span>
              )}
            </TabsTrigger>
          </TabsList>
          
          <TabsContent value="my-tasks" className="mt-0">
            {loading ? (
              <div className="flex justify-center items-center h-32">
                <p>Carregando tarefas...</p>
              </div>
            ) : filteredMyTasks.length > 0 ? (
              renderListView(filteredMyTasks)
            ) : (
              <div className="flex flex-col justify-center items-center h-32 bg-gray-50 dark:bg-gray-800/30 border border-gray-200 dark:border-gray-700 rounded-md">
                <p className="text-gray-500 dark:text-gray-400 mb-2">Você não possui tarefas atribuídas</p>
                <Button variant="outline" size="sm" onClick={() => handleCreateTask()}>
                  Criar nova tarefa
                </Button>
              </div>
            )}
          </TabsContent>
          
          <TabsContent value="assigned-tasks" className="mt-0">
            {loading ? (
              <div className="flex justify-center items-center h-32">
                <p>Carregando tarefas...</p>
              </div>
            ) : filteredAssignedTasks.length > 0 ? (
              renderListView(filteredAssignedTasks)
            ) : (
              <div className="flex flex-col justify-center items-center h-32 bg-gray-50 dark:bg-gray-800/30 border border-gray-200 dark:border-gray-700 rounded-md">
                <p className="text-gray-500 dark:text-gray-400 mb-2">Você não delegou nenhuma tarefa</p>
                <Button variant="outline" size="sm" onClick={() => handleCreateTask()}>
                  Delegar nova tarefa
                </Button>
              </div>
            )}
          </TabsContent>
          
          <TabsContent value="completed-tasks" className="mt-0">
            {loading ? (
              <div className="flex justify-center items-center h-32">
                <p>Carregando tarefas...</p>
              </div>
            ) : filteredCompletedTasks.length > 0 ? (
              renderListView(filteredCompletedTasks)
            ) : (
              <div className="flex justify-center items-center h-32 bg-gray-50 dark:bg-gray-800/30 border border-gray-200 dark:border-gray-700 rounded-md">
                <p className="text-gray-500 dark:text-gray-400">Nenhuma tarefa concluída</p>
              </div>
            )}
          </TabsContent>
        </Tabs>
      ) : (
        <KanbanBoard onCreateTask={handleCreateTask} onOpenDetails={handleOpenTaskDetails} />
      )}
      
      <TaskDialog 
        open={showCreateTaskDialog} 
        onOpenChange={setShowCreateTaskDialog}
        initialStatus={selectedTaskStatus}
      />
      
      <TaskDetailDialog
        open={showTaskDetailDialog}
        onOpenChange={setShowTaskDetailDialog}
        taskId={selectedTaskId ?? undefined}
      />
    </div>
  );
}
</file>

<file path="client/src/components/tasks/TasksWidget.tsx">
import { useTaskContext } from "@/context/TaskContext";
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { CheckCircle, Clock, AlertCircle, XCircle, PlusCircle } from "lucide-react";
import { Link } from "wouter";
import { format, isAfter, isBefore, startOfToday } from "date-fns";
import { ptBR } from "date-fns/locale";
import { useState } from "react";

interface TasksWidgetProps {
  className?: string;
}

export default function TasksWidget({ className = "" }: TasksWidgetProps) {
  const { myTasks, loading } = useTaskContext();
  const [showAll, setShowAll] = useState(false);
  
  // Filtrar tarefas para mostrar apenas as pendentes e em andamento
  const activeTasks = myTasks.filter(task => 
    task.status === "pending" || task.status === "in_progress"
  );
  
  // Ordenar por prioridade e data de vencimento
  const sortedTasks = [...activeTasks].sort((a, b) => {
    // Primeiro por prioridade (high > medium > low)
    const priorityOrder = { high: 0, medium: 1, low: 2 };
    const priorityDiff = priorityOrder[a.priority] - priorityOrder[b.priority];
    
    if (priorityDiff !== 0) return priorityDiff;
    
    // Depois por data de vencimento (mais próxima primeiro)
    if (a.dueDate && b.dueDate) {
      return new Date(a.dueDate).getTime() - new Date(b.dueDate).getTime();
    }
    
    // Tarefas com data de vencimento vêm antes das sem data
    if (a.dueDate) return -1;
    if (b.dueDate) return 1;
    
    return 0;
  });
  
  // Limitar a quantidade de tarefas exibidas se não estiver mostrando todas
  const displayedTasks = showAll ? sortedTasks : sortedTasks.slice(0, 3);
  
  const getStatusIcon = (status: string) => {
    switch (status) {
      case "pending":
        return <AlertCircle className="h-4 w-4 text-blue-500 flex-shrink-0" />;
      case "in_progress":
        return <Clock className="h-4 w-4 text-purple-500 flex-shrink-0" />;
      case "completed":
        return <CheckCircle className="h-4 w-4 text-green-500 flex-shrink-0" />;
      case "cancelled":
        return <XCircle className="h-4 w-4 text-red-500 flex-shrink-0" />;
      default:
        return <AlertCircle className="h-4 w-4 flex-shrink-0" />;
    }
  };
  
  const getPriorityBadge = (priority: string) => {
    switch (priority) {
      case "high":
        return <Badge variant="outline" className="bg-red-50 text-red-600 border-red-200 text-xs">Alta</Badge>;
      case "medium":
        return <Badge variant="outline" className="bg-amber-50 text-amber-600 border-amber-200 text-xs">Média</Badge>;
      case "low":
        return <Badge variant="outline" className="bg-green-50 text-green-600 border-green-200 text-xs">Baixa</Badge>;
      default:
        return <Badge variant="outline" className="text-xs">{priority}</Badge>;
    }
  };
  
  const getDueDateStatus = (dueDate?: Date) => {
    if (!dueDate) return null;
    
    const today = startOfToday();
    const dueDateTime = new Date(dueDate);
    
    if (isBefore(dueDateTime, today)) {
      return <span className="text-xs text-red-500">Atrasada</span>;
    }
    
    return (
      <span className="text-xs text-gray-500">
        {format(dueDateTime, "dd/MM", { locale: ptBR })}
      </span>
    );
  };
  
  return (
    <Card variant="glowIntenseLifted" className={`flex flex-col h-full p-3 sm:p-5 ${className}`}>
      <div className="flex justify-between items-center mb-3 sm:mb-4 border-b dark:border-primary/20 pb-3">
        <div className="flex items-center gap-2">
          <Clock className="h-5 w-5 text-[#ff9810]" />
          <h3 className="font-heading text-base sm:text-lg font-medium dark:text-white dark:glow-title">Minhas Tarefas</h3>
        </div>
        <Link href="/tarefas">
          <Button variant="ghost" size="icon" className="h-8 w-8 text-gray-400 hover:text-secondary transition-all duration-200 dark:text-gray-300 dark:hover:text-pink-400 hover:scale-110 dark:hover:glow-text">
            <span className="material-icons text-base sm:text-lg">list_alt</span>
          </Button>
        </Link>
      </div>
      
      <div className="flex-1 overflow-y-auto scrollbar-thin scrollbar-thumb-gray-200 dark:scrollbar-thumb-slate-700 scrollbar-track-transparent">
        {loading ? (
          <div className="flex justify-center items-center h-full">
            <p className="text-gray-500 dark:text-gray-400">Carregando tarefas...</p>
          </div>
        ) : displayedTasks.length > 0 ? (
          <div className="space-y-2">
            {displayedTasks.map((task) => (
              <Link key={task.id} href={`/tarefas/${task.id}`}>
                <div className="bg-white dark:bg-slate-800/50 border border-gray-100 dark:border-gray-700/50 rounded-lg p-3 hover:shadow-md transition-all duration-200 hover-lift-sm cursor-pointer">
                  <div className="flex justify-between items-start mb-2">
                    <div className="flex items-start gap-2">
                      {getStatusIcon(task.status)}
                      <span className="font-medium text-sm text-gray-800 dark:text-white line-clamp-1">
                        {task.title}
                      </span>
                    </div>
                    <div className="flex gap-1.5 items-center">
                      {getPriorityBadge(task.priority)}
                      {task.dueDate && getDueDateStatus(task.dueDate)}
                    </div>
                  </div>
                </div>
              </Link>
            ))}
          </div>
        ) : (
          <div className="h-full flex flex-col justify-center items-center py-6 text-muted-foreground">
            <div className="p-4 rounded-full bg-gray-50 dark:bg-gray-700/30 mb-3">
              <CheckCircle className="h-6 w-6 text-gray-400 dark:text-gray-500" />
            </div>
            <p className="text-center text-sm text-gray-500 dark:text-gray-400 mb-2">
              Você não possui tarefas pendentes
            </p>
            <Link href="/tarefas">
              <Button variant="outline" size="sm" className="mt-2 flex items-center gap-1.5">
                <PlusCircle className="h-3.5 w-3.5" />
                Nova Tarefa
              </Button>
            </Link>
          </div>
        )}
      </div>
      
      {sortedTasks.length > 3 && !showAll && (
        <div className="mt-3 pt-2 border-t dark:border-gray-700/50">
          <Button 
            variant="ghost" 
            size="sm" 
            className="w-full text-xs text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200"
            onClick={() => setShowAll(true)}
          >
            Ver todas as {sortedTasks.length} tarefas
          </Button>
        </div>
      )}
      
      {showAll && sortedTasks.length > 3 && (
        <div className="mt-3 pt-2 border-t dark:border-gray-700/50">
          <Button 
            variant="ghost" 
            size="sm" 
            className="w-full text-xs text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200"
            onClick={() => setShowAll(false)}
          >
            Mostrar menos
          </Button>
        </div>
      )}
    </Card>
  );
}
</file>

<file path="client/src/components/theme-provider.tsx">
"use client"

import * as React from "react"

type Theme = "dark" | "light" | "system"

type ThemeProviderProps = {
  children: React.ReactNode
  defaultTheme?: Theme
  storageKey?: string
}

type ThemeProviderState = {
  theme: Theme
  setTheme: (theme: Theme) => void
}

const initialState: ThemeProviderState = {
  theme: "system",
  setTheme: () => null,
}

const ThemeProviderContext = React.createContext<ThemeProviderState>(initialState)

export function ThemeProvider({
  children,
  defaultTheme = "system",
  storageKey = "vite-ui-theme",
  ...props
}: ThemeProviderProps) {
  const [theme, setTheme] = React.useState<Theme>(
    () => (localStorage.getItem(storageKey) as Theme) || defaultTheme
  )

  React.useEffect(() => {
    const root = window.document.documentElement

    root.classList.remove("light", "dark")

    if (theme === "system") {
      const systemTheme = window.matchMedia("(prefers-color-scheme: dark)")
        .matches
        ? "dark"
        : "light"

      root.classList.add(systemTheme)
      return
    }

    root.classList.add(theme)
  }, [theme])

  const value = {
    theme,
    setTheme: (theme: Theme) => {
      localStorage.setItem(storageKey, theme)
      setTheme(theme)
    },
  }

  return (
    <ThemeProviderContext.Provider {...props} value={value}>
      {children}
    </ThemeProviderContext.Provider>
  )
}

export const useTheme = () => {
  const context = React.useContext(ThemeProviderContext)

  if (context === undefined)
    throw new Error("useTheme must be used within a ThemeProvider")

  return context
}
</file>

<file path="client/src/components/ui/accordion.tsx">
import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const Accordion = AccordionPrimitive.Root

const AccordionItem = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item
    ref={ref}
    className={cn("border-b", className)}
    {...props}
  />
))
AccordionItem.displayName = "AccordionItem"

const AccordionTrigger = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Header className="flex">
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        "flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
        className
      )}
      {...props}
    >
      {children}
      <ChevronDown className="h-4 w-4 shrink-0 transition-transform duration-200" />
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
))
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName

const AccordionContent = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className="overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down"
    {...props}
  >
    <div className={cn("pb-4 pt-0", className)}>{children}</div>
  </AccordionPrimitive.Content>
))

AccordionContent.displayName = AccordionPrimitive.Content.displayName

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }
</file>

<file path="client/src/components/ui/alert-dialog.tsx">
import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

const AlertDialog = AlertDialogPrimitive.Root

const AlertDialogTrigger = AlertDialogPrimitive.Trigger

const AlertDialogPortal = AlertDialogPrimitive.Portal

const AlertDialogOverlay = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName

const AlertDialogContent = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>
>(({ className, ...props }, ref) => (
  <AlertDialogPortal>
    <AlertDialogOverlay />
    <AlertDialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    />
  </AlertDialogPortal>
))
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName

const AlertDialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
AlertDialogHeader.displayName = "AlertDialogHeader"

const AlertDialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
AlertDialogFooter.displayName = "AlertDialogFooter"

const AlertDialogTitle = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold", className)}
    {...props}
  />
))
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName

const AlertDialogDescription = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
AlertDialogDescription.displayName =
  AlertDialogPrimitive.Description.displayName

const AlertDialogAction = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Action>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Action
    ref={ref}
    className={cn(buttonVariants(), className)}
    {...props}
  />
))
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName

const AlertDialogCancel = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Cancel
    ref={ref}
    className={cn(
      buttonVariants({ variant: "outline" }),
      "mt-2 sm:mt-0",
      className
    )}
    {...props}
  />
))
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}
</file>

<file path="client/src/components/ui/alert.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
))
Alert.displayName = "Alert"

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
))
AlertTitle.displayName = "AlertTitle"

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"

export { Alert, AlertTitle, AlertDescription }
</file>

<file path="client/src/components/ui/aspect-ratio.tsx">
import * as AspectRatioPrimitive from "@radix-ui/react-aspect-ratio"

const AspectRatio = AspectRatioPrimitive.Root

export { AspectRatio }
</file>

<file path="client/src/components/ui/avatar.tsx">
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }
</file>

<file path="client/src/components/ui/badge.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }
</file>

<file path="client/src/components/ui/breadcrumb.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { ChevronRight, MoreHorizontal } from "lucide-react"

import { cn } from "@/lib/utils"

const Breadcrumb = React.forwardRef<
  HTMLElement,
  React.ComponentPropsWithoutRef<"nav"> & {
    separator?: React.ReactNode
  }
>(({ ...props }, ref) => <nav ref={ref} aria-label="breadcrumb" {...props} />)
Breadcrumb.displayName = "Breadcrumb"

const BreadcrumbList = React.forwardRef<
  HTMLOListElement,
  React.ComponentPropsWithoutRef<"ol">
>(({ className, ...props }, ref) => (
  <ol
    ref={ref}
    className={cn(
      "flex flex-wrap items-center gap-1.5 break-words text-sm text-muted-foreground sm:gap-2.5",
      className
    )}
    {...props}
  />
))
BreadcrumbList.displayName = "BreadcrumbList"

const BreadcrumbItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentPropsWithoutRef<"li">
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    className={cn("inline-flex items-center gap-1.5", className)}
    {...props}
  />
))
BreadcrumbItem.displayName = "BreadcrumbItem"

const BreadcrumbLink = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentPropsWithoutRef<"a"> & {
    asChild?: boolean
  }
>(({ asChild, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      ref={ref}
      className={cn("transition-colors hover:text-foreground", className)}
      {...props}
    />
  )
})
BreadcrumbLink.displayName = "BreadcrumbLink"

const BreadcrumbPage = React.forwardRef<
  HTMLSpanElement,
  React.ComponentPropsWithoutRef<"span">
>(({ className, ...props }, ref) => (
  <span
    ref={ref}
    role="link"
    aria-disabled="true"
    aria-current="page"
    className={cn("font-normal text-foreground", className)}
    {...props}
  />
))
BreadcrumbPage.displayName = "BreadcrumbPage"

const BreadcrumbSeparator = ({
  children,
  className,
  ...props
}: React.ComponentProps<"li">) => (
  <li
    role="presentation"
    aria-hidden="true"
    className={cn("[&>svg]:w-3.5 [&>svg]:h-3.5", className)}
    {...props}
  >
    {children ?? <ChevronRight />}
  </li>
)
BreadcrumbSeparator.displayName = "BreadcrumbSeparator"

const BreadcrumbEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    role="presentation"
    aria-hidden="true"
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More</span>
  </span>
)
BreadcrumbEllipsis.displayName = "BreadcrumbElipssis"

export {
  Breadcrumb,
  BreadcrumbList,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbPage,
  BreadcrumbSeparator,
  BreadcrumbEllipsis,
}
</file>

<file path="client/src/components/ui/button.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-all duration-200 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent/60 hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent/60 hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
        glow: "bg-primary text-primary-foreground hover:bg-primary/90 dark:glow-button-sm",
        outlineGlow: "border border-input bg-background hover:bg-accent/60 hover:text-accent-foreground dark:border-primary/30 dark:hover:border-primary/50 dark:hover:shadow-primary/30 dark:hover:shadow-sm",
        glowIntense: "bg-primary text-primary-foreground hover:bg-primary/90 hover:-translate-y-0.5 dark:text-white dark:shadow-glow-sm dark:hover:shadow-glow-md",
        glowSubtle: "bg-primary/90 text-primary-foreground hover:bg-primary hover:-translate-y-0.5 dark:glow-button-xs",
        outlineGlowIntense: "border border-primary/50 bg-background hover:bg-primary/10 hover:text-primary dark:text-primary-foreground dark:hover:border-primary/80 dark:hover:shadow-glow-md dark:hover:-translate-y-1",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }
</file>

<file path="client/src/components/ui/calendar.tsx">
import * as React from "react"
import { ChevronLeft, ChevronRight } from "lucide-react"
import { DayPicker } from "react-day-picker"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

export type CalendarProps = React.ComponentProps<typeof DayPicker>

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  ...props
}: CalendarProps) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn("p-3", className)}
      classNames={{
        months: "flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0",
        month: "space-y-4",
        caption: "flex justify-center pt-1 relative items-center",
        caption_label: "text-sm font-medium",
        nav: "space-x-1 flex items-center",
        nav_button: cn(
          buttonVariants({ variant: "outline" }),
          "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100"
        ),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-y-1",
        head_row: "flex",
        head_cell:
          "text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: "h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20",
        day: cn(
          buttonVariants({ variant: "ghost" }),
          "h-9 w-9 p-0 font-normal aria-selected:opacity-100"
        ),
        day_range_end: "day-range-end",
        day_selected:
          "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside:
          "day-outside text-muted-foreground aria-selected:bg-accent/50 aria-selected:text-muted-foreground",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle:
          "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible",
        ...classNames,
      }}
      components={{
        IconLeft: ({ className, ...props }) => (
          <ChevronLeft className={cn("h-4 w-4", className)} {...props} />
        ),
        IconRight: ({ className, ...props }) => (
          <ChevronRight className={cn("h-4 w-4", className)} {...props} />
        ),
      }}
      {...props}
    />
  )
}
Calendar.displayName = "Calendar"

export { Calendar }
</file>

<file path="client/src/components/ui/card.tsx">
import * as React from "react"
import { VariantProps, cva } from "class-variance-authority"

import { cn } from "@/lib/utils"

const cardVariants = cva(
  "rounded-xl border bg-card text-card-foreground transition-all duration-200",
  {
    variants: {
      variant: {
        default: "shadow-sm border-gray-100",
        glow: "shadow-sm hover:shadow-md dark:glow-card",
        lifted: "shadow-sm hover:shadow-md hover:-translate-y-1",
        glowLifted: "shadow-sm hover:shadow-md hover:-translate-y-1 dark:glow-card",
        glowIntense: "shadow-sm hover:shadow-md dark:glow-card-intense",
        glowIntenseLifted: "shadow-sm hover:shadow-md hover:-translate-y-2 dark:glow-card-intense",
        glowPulse: "shadow-sm dark:glow-card-pulse",
        highlight: "shadow-md border-primary/30 dark:border-primary/40 dark:glow-card-intense",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

interface CardProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof cardVariants> {}

const Card = React.forwardRef<HTMLDivElement, CardProps>(
  ({ className, variant, ...props }, ref) => (
    <div
      ref={ref}
      className={cn(cardVariants({ variant, className }))}
      {...props}
    />
  )
)
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "text-lg font-medium leading-none tracking-tight text-gray-800",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-gray-500", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }
</file>

<file path="client/src/components/ui/carousel.tsx">
import * as React from "react"
import useEmblaCarousel, {
  type UseEmblaCarouselType,
} from "embla-carousel-react"
import { ArrowLeft, ArrowRight } from "lucide-react"

import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"

type CarouselApi = UseEmblaCarouselType[1]
type UseCarouselParameters = Parameters<typeof useEmblaCarousel>
type CarouselOptions = UseCarouselParameters[0]
type CarouselPlugin = UseCarouselParameters[1]

type CarouselProps = {
  opts?: CarouselOptions
  plugins?: CarouselPlugin
  orientation?: "horizontal" | "vertical"
  setApi?: (api: CarouselApi) => void
}

type CarouselContextProps = {
  carouselRef: ReturnType<typeof useEmblaCarousel>[0]
  api: ReturnType<typeof useEmblaCarousel>[1]
  scrollPrev: () => void
  scrollNext: () => void
  canScrollPrev: boolean
  canScrollNext: boolean
} & CarouselProps

const CarouselContext = React.createContext<CarouselContextProps | null>(null)

function useCarousel() {
  const context = React.useContext(CarouselContext)

  if (!context) {
    throw new Error("useCarousel must be used within a <Carousel />")
  }

  return context
}

const Carousel = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & CarouselProps
>(
  (
    {
      orientation = "horizontal",
      opts,
      setApi,
      plugins,
      className,
      children,
      ...props
    },
    ref
  ) => {
    const [carouselRef, api] = useEmblaCarousel(
      {
        ...opts,
        axis: orientation === "horizontal" ? "x" : "y",
      },
      plugins
    )
    const [canScrollPrev, setCanScrollPrev] = React.useState(false)
    const [canScrollNext, setCanScrollNext] = React.useState(false)

    const onSelect = React.useCallback((api: CarouselApi) => {
      if (!api) {
        return
      }

      setCanScrollPrev(api.canScrollPrev())
      setCanScrollNext(api.canScrollNext())
    }, [])

    const scrollPrev = React.useCallback(() => {
      api?.scrollPrev()
    }, [api])

    const scrollNext = React.useCallback(() => {
      api?.scrollNext()
    }, [api])

    const handleKeyDown = React.useCallback(
      (event: React.KeyboardEvent<HTMLDivElement>) => {
        if (event.key === "ArrowLeft") {
          event.preventDefault()
          scrollPrev()
        } else if (event.key === "ArrowRight") {
          event.preventDefault()
          scrollNext()
        }
      },
      [scrollPrev, scrollNext]
    )

    React.useEffect(() => {
      if (!api || !setApi) {
        return
      }

      setApi(api)
    }, [api, setApi])

    React.useEffect(() => {
      if (!api) {
        return
      }

      onSelect(api)
      api.on("reInit", onSelect)
      api.on("select", onSelect)

      return () => {
        api?.off("select", onSelect)
      }
    }, [api, onSelect])

    return (
      <CarouselContext.Provider
        value={{
          carouselRef,
          api: api,
          opts,
          orientation:
            orientation || (opts?.axis === "y" ? "vertical" : "horizontal"),
          scrollPrev,
          scrollNext,
          canScrollPrev,
          canScrollNext,
        }}
      >
        <div
          ref={ref}
          onKeyDownCapture={handleKeyDown}
          className={cn("relative", className)}
          role="region"
          aria-roledescription="carousel"
          {...props}
        >
          {children}
        </div>
      </CarouselContext.Provider>
    )
  }
)
Carousel.displayName = "Carousel"

const CarouselContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { carouselRef, orientation } = useCarousel()

  return (
    <div ref={carouselRef} className="overflow-hidden">
      <div
        ref={ref}
        className={cn(
          "flex",
          orientation === "horizontal" ? "-ml-4" : "-mt-4 flex-col",
          className
        )}
        {...props}
      />
    </div>
  )
})
CarouselContent.displayName = "CarouselContent"

const CarouselItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { orientation } = useCarousel()

  return (
    <div
      ref={ref}
      role="group"
      aria-roledescription="slide"
      className={cn(
        "min-w-0 shrink-0 grow-0 basis-full",
        orientation === "horizontal" ? "pl-4" : "pt-4",
        className
      )}
      {...props}
    />
  )
})
CarouselItem.displayName = "CarouselItem"

const CarouselPrevious = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = "outline", size = "icon", ...props }, ref) => {
  const { orientation, scrollPrev, canScrollPrev } = useCarousel()

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute  h-8 w-8 rounded-full",
        orientation === "horizontal"
          ? "-left-12 top-1/2 -translate-y-1/2"
          : "-top-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollPrev}
      onClick={scrollPrev}
      {...props}
    >
      <ArrowLeft className="h-4 w-4" />
      <span className="sr-only">Previous slide</span>
    </Button>
  )
})
CarouselPrevious.displayName = "CarouselPrevious"

const CarouselNext = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = "outline", size = "icon", ...props }, ref) => {
  const { orientation, scrollNext, canScrollNext } = useCarousel()

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute h-8 w-8 rounded-full",
        orientation === "horizontal"
          ? "-right-12 top-1/2 -translate-y-1/2"
          : "-bottom-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollNext}
      onClick={scrollNext}
      {...props}
    >
      <ArrowRight className="h-4 w-4" />
      <span className="sr-only">Next slide</span>
    </Button>
  )
})
CarouselNext.displayName = "CarouselNext"

export {
  type CarouselApi,
  Carousel,
  CarouselContent,
  CarouselItem,
  CarouselPrevious,
  CarouselNext,
}
</file>

<file path="client/src/components/ui/chart.tsx">
"use client"

import * as React from "react"
import * as RechartsPrimitive from "recharts"

import { cn } from "@/lib/utils"

// Format: { THEME_NAME: CSS_SELECTOR }
const THEMES = { light: "", dark: ".dark" } as const

export type ChartConfig = {
  [k in string]: {
    label?: React.ReactNode
    icon?: React.ComponentType
  } & (
    | { color?: string; theme?: never }
    | { color?: never; theme: Record<keyof typeof THEMES, string> }
  )
}

type ChartContextProps = {
  config: ChartConfig
}

const ChartContext = React.createContext<ChartContextProps | null>(null)

function useChart() {
  const context = React.useContext(ChartContext)

  if (!context) {
    throw new Error("useChart must be used within a <ChartContainer />")
  }

  return context
}

const ChartContainer = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    config: ChartConfig
    children: React.ComponentProps<
      typeof RechartsPrimitive.ResponsiveContainer
    >["children"]
  }
>(({ id, className, children, config, ...props }, ref) => {
  const uniqueId = React.useId()
  const chartId = `chart-${id || uniqueId.replace(/:/g, "")}`

  return (
    <ChartContext.Provider value={{ config }}>
      <div
        data-chart={chartId}
        ref={ref}
        className={cn(
          "flex aspect-video justify-center text-xs [&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-none [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-sector]:outline-none [&_.recharts-surface]:outline-none",
          className
        )}
        {...props}
      >
        <ChartStyle id={chartId} config={config} />
        <RechartsPrimitive.ResponsiveContainer>
          {children}
        </RechartsPrimitive.ResponsiveContainer>
      </div>
    </ChartContext.Provider>
  )
})
ChartContainer.displayName = "Chart"

const ChartStyle = ({ id, config }: { id: string; config: ChartConfig }) => {
  const colorConfig = Object.entries(config).filter(
    ([, config]) => config.theme || config.color
  )

  if (!colorConfig.length) {
    return null
  }

  return (
    <style
      dangerouslySetInnerHTML={{
        __html: Object.entries(THEMES)
          .map(
            ([theme, prefix]) => `
${prefix} [data-chart=${id}] {
${colorConfig
  .map(([key, itemConfig]) => {
    const color =
      itemConfig.theme?.[theme as keyof typeof itemConfig.theme] ||
      itemConfig.color
    return color ? `  --color-${key}: ${color};` : null
  })
  .join("\n")}
}
`
          )
          .join("\n"),
      }}
    />
  )
}

const ChartTooltip = RechartsPrimitive.Tooltip

const ChartTooltipContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<typeof RechartsPrimitive.Tooltip> &
    React.ComponentProps<"div"> & {
      hideLabel?: boolean
      hideIndicator?: boolean
      indicator?: "line" | "dot" | "dashed"
      nameKey?: string
      labelKey?: string
    }
>(
  (
    {
      active,
      payload,
      className,
      indicator = "dot",
      hideLabel = false,
      hideIndicator = false,
      label,
      labelFormatter,
      labelClassName,
      formatter,
      color,
      nameKey,
      labelKey,
    },
    ref
  ) => {
    const { config } = useChart()

    const tooltipLabel = React.useMemo(() => {
      if (hideLabel || !payload?.length) {
        return null
      }

      const [item] = payload
      const key = `${labelKey || item?.dataKey || item?.name || "value"}`
      const itemConfig = getPayloadConfigFromPayload(config, item, key)
      const value =
        !labelKey && typeof label === "string"
          ? config[label as keyof typeof config]?.label || label
          : itemConfig?.label

      if (labelFormatter) {
        return (
          <div className={cn("font-medium", labelClassName)}>
            {labelFormatter(value, payload)}
          </div>
        )
      }

      if (!value) {
        return null
      }

      return <div className={cn("font-medium", labelClassName)}>{value}</div>
    }, [
      label,
      labelFormatter,
      payload,
      hideLabel,
      labelClassName,
      config,
      labelKey,
    ])

    if (!active || !payload?.length) {
      return null
    }

    const nestLabel = payload.length === 1 && indicator !== "dot"

    return (
      <div
        ref={ref}
        className={cn(
          "grid min-w-[8rem] items-start gap-1.5 rounded-lg border border-border/50 bg-background px-2.5 py-1.5 text-xs shadow-xl",
          className
        )}
      >
        {!nestLabel ? tooltipLabel : null}
        <div className="grid gap-1.5">
          {payload.map((item, index) => {
            const key = `${nameKey || item.name || item.dataKey || "value"}`
            const itemConfig = getPayloadConfigFromPayload(config, item, key)
            const indicatorColor = color || item.payload.fill || item.color

            return (
              <div
                key={item.dataKey}
                className={cn(
                  "flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5 [&>svg]:text-muted-foreground",
                  indicator === "dot" && "items-center"
                )}
              >
                {formatter && item?.value !== undefined && item.name ? (
                  formatter(item.value, item.name, item, index, item.payload)
                ) : (
                  <>
                    {itemConfig?.icon ? (
                      <itemConfig.icon />
                    ) : (
                      !hideIndicator && (
                        <div
                          className={cn(
                            "shrink-0 rounded-[2px] border-[--color-border] bg-[--color-bg]",
                            {
                              "h-2.5 w-2.5": indicator === "dot",
                              "w-1": indicator === "line",
                              "w-0 border-[1.5px] border-dashed bg-transparent":
                                indicator === "dashed",
                              "my-0.5": nestLabel && indicator === "dashed",
                            }
                          )}
                          style={
                            {
                              "--color-bg": indicatorColor,
                              "--color-border": indicatorColor,
                            } as React.CSSProperties
                          }
                        />
                      )
                    )}
                    <div
                      className={cn(
                        "flex flex-1 justify-between leading-none",
                        nestLabel ? "items-end" : "items-center"
                      )}
                    >
                      <div className="grid gap-1.5">
                        {nestLabel ? tooltipLabel : null}
                        <span className="text-muted-foreground">
                          {itemConfig?.label || item.name}
                        </span>
                      </div>
                      {item.value && (
                        <span className="font-mono font-medium tabular-nums text-foreground">
                          {item.value.toLocaleString()}
                        </span>
                      )}
                    </div>
                  </>
                )}
              </div>
            )
          })}
        </div>
      </div>
    )
  }
)
ChartTooltipContent.displayName = "ChartTooltip"

const ChartLegend = RechartsPrimitive.Legend

const ChartLegendContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> &
    Pick<RechartsPrimitive.LegendProps, "payload" | "verticalAlign"> & {
      hideIcon?: boolean
      nameKey?: string
    }
>(
  (
    { className, hideIcon = false, payload, verticalAlign = "bottom", nameKey },
    ref
  ) => {
    const { config } = useChart()

    if (!payload?.length) {
      return null
    }

    return (
      <div
        ref={ref}
        className={cn(
          "flex items-center justify-center gap-4",
          verticalAlign === "top" ? "pb-3" : "pt-3",
          className
        )}
      >
        {payload.map((item) => {
          const key = `${nameKey || item.dataKey || "value"}`
          const itemConfig = getPayloadConfigFromPayload(config, item, key)

          return (
            <div
              key={item.value}
              className={cn(
                "flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3 [&>svg]:text-muted-foreground"
              )}
            >
              {itemConfig?.icon && !hideIcon ? (
                <itemConfig.icon />
              ) : (
                <div
                  className="h-2 w-2 shrink-0 rounded-[2px]"
                  style={{
                    backgroundColor: item.color,
                  }}
                />
              )}
              {itemConfig?.label}
            </div>
          )
        })}
      </div>
    )
  }
)
ChartLegendContent.displayName = "ChartLegend"

// Helper to extract item config from a payload.
function getPayloadConfigFromPayload(
  config: ChartConfig,
  payload: unknown,
  key: string
) {
  if (typeof payload !== "object" || payload === null) {
    return undefined
  }

  const payloadPayload =
    "payload" in payload &&
    typeof payload.payload === "object" &&
    payload.payload !== null
      ? payload.payload
      : undefined

  let configLabelKey: string = key

  if (
    key in payload &&
    typeof payload[key as keyof typeof payload] === "string"
  ) {
    configLabelKey = payload[key as keyof typeof payload] as string
  } else if (
    payloadPayload &&
    key in payloadPayload &&
    typeof payloadPayload[key as keyof typeof payloadPayload] === "string"
  ) {
    configLabelKey = payloadPayload[
      key as keyof typeof payloadPayload
    ] as string
  }

  return configLabelKey in config
    ? config[configLabelKey]
    : config[key as keyof typeof config]
}

export {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  ChartLegend,
  ChartLegendContent,
  ChartStyle,
}
</file>

<file path="client/src/components/ui/checkbox.tsx">
import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { Check } from "lucide-react"

import { cn } from "@/lib/utils"

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }
</file>

<file path="client/src/components/ui/collapsible.tsx">
"use client"

import * as React from "react"
import * as CollapsiblePrimitive from "@radix-ui/react-collapsible"

const Collapsible = CollapsiblePrimitive.Root

const CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger

const CollapsibleContent = CollapsiblePrimitive.CollapsibleContent

export { Collapsible, CollapsibleTrigger, CollapsibleContent }
</file>

<file path="client/src/components/ui/command.tsx">
import * as React from "react"
import { type DialogProps } from "@radix-ui/react-dialog"
import { Command as CommandPrimitive } from "cmdk"
import { Search } from "lucide-react"

import { cn } from "@/lib/utils"
import { Dialog, DialogContent } from "@/components/ui/dialog"

const Command = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive>
>(({ className, ...props }, ref) => (
  <CommandPrimitive
    ref={ref}
    className={cn(
      "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
      className
    )}
    {...props}
  />
))
Command.displayName = CommandPrimitive.displayName

const CommandDialog = ({ children, ...props }: DialogProps) => {
  return (
    <Dialog {...props}>
      <DialogContent className="overflow-hidden p-0 shadow-lg">
        <Command className="[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  )
}

const CommandInput = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Input>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>
>(({ className, ...props }, ref) => (
  <div className="flex items-center border-b px-3" cmdk-input-wrapper="">
    <Search className="mr-2 h-4 w-4 shrink-0 opacity-50" />
    <CommandPrimitive.Input
      ref={ref}
      className={cn(
        "flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    />
  </div>
))

CommandInput.displayName = CommandPrimitive.Input.displayName

const CommandList = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.List
    ref={ref}
    className={cn("max-h-[300px] overflow-y-auto overflow-x-hidden", className)}
    {...props}
  />
))

CommandList.displayName = CommandPrimitive.List.displayName

const CommandEmpty = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Empty>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>
>((props, ref) => (
  <CommandPrimitive.Empty
    ref={ref}
    className="py-6 text-center text-sm"
    {...props}
  />
))

CommandEmpty.displayName = CommandPrimitive.Empty.displayName

const CommandGroup = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Group>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Group
    ref={ref}
    className={cn(
      "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
      className
    )}
    {...props}
  />
))

CommandGroup.displayName = CommandPrimitive.Group.displayName

const CommandSeparator = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 h-px bg-border", className)}
    {...props}
  />
))
CommandSeparator.displayName = CommandPrimitive.Separator.displayName

const CommandItem = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected='true']:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      className
    )}
    {...props}
  />
))

CommandItem.displayName = CommandPrimitive.Item.displayName

const CommandShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
CommandShortcut.displayName = "CommandShortcut"

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
}
</file>

<file path="client/src/components/ui/context-menu.tsx">
import * as React from "react"
import * as ContextMenuPrimitive from "@radix-ui/react-context-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const ContextMenu = ContextMenuPrimitive.Root

const ContextMenuTrigger = ContextMenuPrimitive.Trigger

const ContextMenuGroup = ContextMenuPrimitive.Group

const ContextMenuPortal = ContextMenuPrimitive.Portal

const ContextMenuSub = ContextMenuPrimitive.Sub

const ContextMenuRadioGroup = ContextMenuPrimitive.RadioGroup

const ContextMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <ContextMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </ContextMenuPrimitive.SubTrigger>
))
ContextMenuSubTrigger.displayName = ContextMenuPrimitive.SubTrigger.displayName

const ContextMenuSubContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-context-menu-content-transform-origin]",
      className
    )}
    {...props}
  />
))
ContextMenuSubContent.displayName = ContextMenuPrimitive.SubContent.displayName

const ContextMenuContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Portal>
    <ContextMenuPrimitive.Content
      ref={ref}
      className={cn(
        "z-50 max-h-[--radix-context-menu-content-available-height] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md animate-in fade-in-80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-context-menu-content-transform-origin]",
        className
      )}
      {...props}
    />
  </ContextMenuPrimitive.Portal>
))
ContextMenuContent.displayName = ContextMenuPrimitive.Content.displayName

const ContextMenuItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
ContextMenuItem.displayName = ContextMenuPrimitive.Item.displayName

const ContextMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <ContextMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.CheckboxItem>
))
ContextMenuCheckboxItem.displayName =
  ContextMenuPrimitive.CheckboxItem.displayName

const ContextMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <ContextMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.RadioItem>
))
ContextMenuRadioItem.displayName = ContextMenuPrimitive.RadioItem.displayName

const ContextMenuLabel = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold text-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
ContextMenuLabel.displayName = ContextMenuPrimitive.Label.displayName

const ContextMenuSeparator = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-border", className)}
    {...props}
  />
))
ContextMenuSeparator.displayName = ContextMenuPrimitive.Separator.displayName

const ContextMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
ContextMenuShortcut.displayName = "ContextMenuShortcut"

export {
  ContextMenu,
  ContextMenuTrigger,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuCheckboxItem,
  ContextMenuRadioItem,
  ContextMenuLabel,
  ContextMenuSeparator,
  ContextMenuShortcut,
  ContextMenuGroup,
  ContextMenuPortal,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuRadioGroup,
}
</file>

<file path="client/src/components/ui/dialog.tsx">
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}
</file>

<file path="client/src/components/ui/drawer.tsx">
"use client"

import * as React from "react"
import { Drawer as DrawerPrimitive } from "vaul"

import { cn } from "@/lib/utils"

const Drawer = ({
  shouldScaleBackground = true,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Root>) => (
  <DrawerPrimitive.Root
    shouldScaleBackground={shouldScaleBackground}
    {...props}
  />
)
Drawer.displayName = "Drawer"

const DrawerTrigger = DrawerPrimitive.Trigger

const DrawerPortal = DrawerPrimitive.Portal

const DrawerClose = DrawerPrimitive.Close

const DrawerOverlay = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Overlay
    ref={ref}
    className={cn("fixed inset-0 z-50 bg-black/80", className)}
    {...props}
  />
))
DrawerOverlay.displayName = DrawerPrimitive.Overlay.displayName

const DrawerContent = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DrawerPortal>
    <DrawerOverlay />
    <DrawerPrimitive.Content
      ref={ref}
      className={cn(
        "fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border bg-background",
        className
      )}
      {...props}
    >
      <div className="mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted" />
      {children}
    </DrawerPrimitive.Content>
  </DrawerPortal>
))
DrawerContent.displayName = "DrawerContent"

const DrawerHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("grid gap-1.5 p-4 text-center sm:text-left", className)}
    {...props}
  />
)
DrawerHeader.displayName = "DrawerHeader"

const DrawerFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("mt-auto flex flex-col gap-2 p-4", className)}
    {...props}
  />
)
DrawerFooter.displayName = "DrawerFooter"

const DrawerTitle = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DrawerTitle.displayName = DrawerPrimitive.Title.displayName

const DrawerDescription = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DrawerDescription.displayName = DrawerPrimitive.Description.displayName

export {
  Drawer,
  DrawerPortal,
  DrawerOverlay,
  DrawerTrigger,
  DrawerClose,
  DrawerContent,
  DrawerHeader,
  DrawerFooter,
  DrawerTitle,
  DrawerDescription,
}
</file>

<file path="client/src/components/ui/dropdown-menu.tsx">
import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent hover:bg-accent/60 hover:text-accent-foreground data-[state=open]:bg-accent [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-dropdown-menu-content-transform-origin]",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 max-h-[var(--radix-dropdown-menu-content-available-height)] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-dropdown-menu-content-transform-origin]",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground hover:bg-accent/60 hover:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground hover:bg-accent/60 hover:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground hover:bg-accent/60 hover:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}
</file>

<file path="client/src/components/ui/form.tsx">
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  FormProvider,
  useFormContext,
  type ControllerProps,
  type FieldPath,
  type FieldValues,
} from "react-hook-form"

import { cn } from "@/lib/utils"
import { Label } from "@/components/ui/label"

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState, formState } = useFormContext()

  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn("space-y-2", className)} {...props} />
    </FormItemContext.Provider>
  )
})
FormItem.displayName = "FormItem"

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField()

  return (
    <Label
      ref={ref}
      className={cn(error && "text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
})
FormLabel.displayName = "FormLabel"

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
})
FormControl.displayName = "FormControl"

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField()

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn("text-sm text-muted-foreground", className)}
      {...props}
    />
  )
})
FormDescription.displayName = "FormDescription"

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message ?? "") : children

  if (!body) {
    return null
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn("text-sm font-medium text-destructive", className)}
      {...props}
    >
      {body}
    </p>
  )
})
FormMessage.displayName = "FormMessage"

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}
</file>

<file path="client/src/components/ui/hover-card.tsx">
"use client"

import * as React from "react"
import * as HoverCardPrimitive from "@radix-ui/react-hover-card"

import { cn } from "@/lib/utils"

const HoverCard = HoverCardPrimitive.Root

const HoverCardTrigger = HoverCardPrimitive.Trigger

const HoverCardContent = React.forwardRef<
  React.ElementRef<typeof HoverCardPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof HoverCardPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <HoverCardPrimitive.Content
    ref={ref}
    align={align}
    sideOffset={sideOffset}
    className={cn(
      "z-50 w-64 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-hover-card-content-transform-origin]",
      className
    )}
    {...props}
  />
))
HoverCardContent.displayName = HoverCardPrimitive.Content.displayName

export { HoverCard, HoverCardTrigger, HoverCardContent }
</file>

<file path="client/src/components/ui/input-otp.tsx">
import * as React from "react"
import { OTPInput, OTPInputContext } from "input-otp"
import { Dot } from "lucide-react"

import { cn } from "@/lib/utils"

const InputOTP = React.forwardRef<
  React.ElementRef<typeof OTPInput>,
  React.ComponentPropsWithoutRef<typeof OTPInput>
>(({ className, containerClassName, ...props }, ref) => (
  <OTPInput
    ref={ref}
    containerClassName={cn(
      "flex items-center gap-2 has-[:disabled]:opacity-50",
      containerClassName
    )}
    className={cn("disabled:cursor-not-allowed", className)}
    {...props}
  />
))
InputOTP.displayName = "InputOTP"

const InputOTPGroup = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div">
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("flex items-center", className)} {...props} />
))
InputOTPGroup.displayName = "InputOTPGroup"

const InputOTPSlot = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div"> & { index: number }
>(({ index, className, ...props }, ref) => {
  const inputOTPContext = React.useContext(OTPInputContext)
  const { char, hasFakeCaret, isActive } = inputOTPContext.slots[index]

  return (
    <div
      ref={ref}
      className={cn(
        "relative flex h-10 w-10 items-center justify-center border-y border-r border-input text-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md",
        isActive && "z-10 ring-2 ring-ring ring-offset-background",
        className
      )}
      {...props}
    >
      {char}
      {hasFakeCaret && (
        <div className="pointer-events-none absolute inset-0 flex items-center justify-center">
          <div className="h-4 w-px animate-caret-blink bg-foreground duration-1000" />
        </div>
      )}
    </div>
  )
})
InputOTPSlot.displayName = "InputOTPSlot"

const InputOTPSeparator = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div">
>(({ ...props }, ref) => (
  <div ref={ref} role="separator" {...props}>
    <Dot />
  </div>
))
InputOTPSeparator.displayName = "InputOTPSeparator"

export { InputOTP, InputOTPGroup, InputOTPSlot, InputOTPSeparator }
</file>

<file path="client/src/components/ui/input.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }
</file>

<file path="client/src/components/ui/label.tsx">
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }
</file>

<file path="client/src/components/ui/MarkdownRenderer.tsx">
import React from 'react';
import ReactMarkdown from 'react-markdown';
import rehypeHighlight from 'rehype-highlight';
import { cn } from '@/lib/utils';
import 'highlight.js/styles/github.css';

interface MarkdownRendererProps {
  content: string;
  className?: string;
}

export function MarkdownRenderer({ content, className }: MarkdownRendererProps) {
  return (
    <div className={cn("favale-ia-markdown prose prose-sm dark:prose-invert max-w-none", className)}>
      <ReactMarkdown
        rehypePlugins={[rehypeHighlight]}
        components={{
          // Customiza os componentes de markdown
          p: ({ children }) => <p className="mb-3 last:mb-0 leading-relaxed">{children}</p>,
          ul: ({ children }) => <ul className="mb-3 last:mb-0 ml-4 list-disc space-y-1">{children}</ul>,
          ol: ({ children }) => <ol className="mb-3 last:mb-0 ml-4 list-decimal space-y-1">{children}</ol>,
          li: ({ children }) => <li className="leading-relaxed">{children}</li>,
          strong: ({ children }) => <strong className="font-semibold text-foreground">{children}</strong>,
          code: ({ children, className }) => {
            const isInline = !className;
            if (isInline) {
              return (
                <code className="bg-muted px-1.5 py-0.5 rounded text-sm font-mono border">
                  {children}
                </code>
              );
            }
            return (
              <code className={className}>
                {children}
              </code>
            );
          },
          pre: ({ children }) => (
            <pre className="bg-muted/80 p-4 rounded-lg overflow-x-auto text-sm mb-3 last:mb-0 border">
              {children}
            </pre>
          ),
          h1: ({ children }) => <h1 className="text-xl font-bold mb-3 text-foreground">{children}</h1>,
          h2: ({ children }) => <h2 className="text-lg font-bold mb-3 text-foreground">{children}</h2>,
          h3: ({ children }) => <h3 className="text-base font-bold mb-2 text-foreground">{children}</h3>,
          blockquote: ({ children }) => (
            <blockquote className="border-l-4 border-primary pl-4 py-3 bg-muted/40 rounded-r mb-3 last:mb-0 italic">
              {children}
            </blockquote>
          ),
          // Adiciona suporte para bullet points personalizados
          text: ({ children }) => {
            if (typeof children === 'string') {
              // Substitui • por bullet points estilizados
              return children.replace(/•/g, '•');
            }
            return children;
          }
        }}
      >
        {content}
      </ReactMarkdown>
    </div>
  );
}
</file>

<file path="client/src/components/ui/menubar.tsx">
"use client"

import * as React from "react"
import * as MenubarPrimitive from "@radix-ui/react-menubar"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

function MenubarMenu({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Menu>) {
  return <MenubarPrimitive.Menu {...props} />
}

function MenubarGroup({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Group>) {
  return <MenubarPrimitive.Group {...props} />
}

function MenubarPortal({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Portal>) {
  return <MenubarPrimitive.Portal {...props} />
}

function MenubarRadioGroup({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.RadioGroup>) {
  return <MenubarPrimitive.RadioGroup {...props} />
}

function MenubarSub({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Sub>) {
  return <MenubarPrimitive.Sub data-slot="menubar-sub" {...props} />
}

const Menubar = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Root
    ref={ref}
    className={cn(
      "flex h-10 items-center space-x-1 rounded-md border bg-background p-1",
      className
    )}
    {...props}
  />
))
Menubar.displayName = MenubarPrimitive.Root.displayName

const MenubarTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-3 py-1.5 text-sm font-medium outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      className
    )}
    {...props}
  />
))
MenubarTrigger.displayName = MenubarPrimitive.Trigger.displayName

const MenubarSubTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <MenubarPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </MenubarPrimitive.SubTrigger>
))
MenubarSubTrigger.displayName = MenubarPrimitive.SubTrigger.displayName

const MenubarSubContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-menubar-content-transform-origin]",
      className
    )}
    {...props}
  />
))
MenubarSubContent.displayName = MenubarPrimitive.SubContent.displayName

const MenubarContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Content>
>(
  (
    { className, align = "start", alignOffset = -4, sideOffset = 8, ...props },
    ref
  ) => (
    <MenubarPrimitive.Portal>
      <MenubarPrimitive.Content
        ref={ref}
        align={align}
        alignOffset={alignOffset}
        sideOffset={sideOffset}
        className={cn(
          "z-50 min-w-[12rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-menubar-content-transform-origin]",
          className
        )}
        {...props}
      />
    </MenubarPrimitive.Portal>
  )
)
MenubarContent.displayName = MenubarPrimitive.Content.displayName

const MenubarItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
MenubarItem.displayName = MenubarPrimitive.Item.displayName

const MenubarCheckboxItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <MenubarPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.CheckboxItem>
))
MenubarCheckboxItem.displayName = MenubarPrimitive.CheckboxItem.displayName

const MenubarRadioItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <MenubarPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.RadioItem>
))
MenubarRadioItem.displayName = MenubarPrimitive.RadioItem.displayName

const MenubarLabel = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
MenubarLabel.displayName = MenubarPrimitive.Label.displayName

const MenubarSeparator = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
MenubarSeparator.displayName = MenubarPrimitive.Separator.displayName

const MenubarShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
MenubarShortcut.displayname = "MenubarShortcut"

export {
  Menubar,
  MenubarMenu,
  MenubarTrigger,
  MenubarContent,
  MenubarItem,
  MenubarSeparator,
  MenubarLabel,
  MenubarCheckboxItem,
  MenubarRadioGroup,
  MenubarRadioItem,
  MenubarPortal,
  MenubarSubContent,
  MenubarSubTrigger,
  MenubarGroup,
  MenubarSub,
  MenubarShortcut,
}
</file>

<file path="client/src/components/ui/navigation-menu.tsx">
import * as React from "react"
import * as NavigationMenuPrimitive from "@radix-ui/react-navigation-menu"
import { cva } from "class-variance-authority"
import { ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const NavigationMenu = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Root
    ref={ref}
    className={cn(
      "relative z-10 flex max-w-max flex-1 items-center justify-center",
      className
    )}
    {...props}
  >
    {children}
    <NavigationMenuViewport />
  </NavigationMenuPrimitive.Root>
))
NavigationMenu.displayName = NavigationMenuPrimitive.Root.displayName

const NavigationMenuList = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.List>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.List
    ref={ref}
    className={cn(
      "group flex flex-1 list-none items-center justify-center space-x-1",
      className
    )}
    {...props}
  />
))
NavigationMenuList.displayName = NavigationMenuPrimitive.List.displayName

const NavigationMenuItem = NavigationMenuPrimitive.Item

const navigationMenuTriggerStyle = cva(
  "group inline-flex h-10 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[state=open]:text-accent-foreground data-[state=open]:bg-accent/50 data-[state=open]:hover:bg-accent data-[state=open]:focus:bg-accent"
)

const NavigationMenuTrigger = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Trigger
    ref={ref}
    className={cn(navigationMenuTriggerStyle(), "group", className)}
    {...props}
  >
    {children}{" "}
    <ChevronDown
      className="relative top-[1px] ml-1 h-3 w-3 transition duration-200 group-data-[state=open]:rotate-180"
      aria-hidden="true"
    />
  </NavigationMenuPrimitive.Trigger>
))
NavigationMenuTrigger.displayName = NavigationMenuPrimitive.Trigger.displayName

const NavigationMenuContent = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Content
    ref={ref}
    className={cn(
      "left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto ",
      className
    )}
    {...props}
  />
))
NavigationMenuContent.displayName = NavigationMenuPrimitive.Content.displayName

const NavigationMenuLink = NavigationMenuPrimitive.Link

const NavigationMenuViewport = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Viewport>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Viewport>
>(({ className, ...props }, ref) => (
  <div className={cn("absolute left-0 top-full flex justify-center")}>
    <NavigationMenuPrimitive.Viewport
      className={cn(
        "origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]",
        className
      )}
      ref={ref}
      {...props}
    />
  </div>
))
NavigationMenuViewport.displayName =
  NavigationMenuPrimitive.Viewport.displayName

const NavigationMenuIndicator = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Indicator>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Indicator>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Indicator
    ref={ref}
    className={cn(
      "top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in",
      className
    )}
    {...props}
  >
    <div className="relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md" />
  </NavigationMenuPrimitive.Indicator>
))
NavigationMenuIndicator.displayName =
  NavigationMenuPrimitive.Indicator.displayName

export {
  navigationMenuTriggerStyle,
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuContent,
  NavigationMenuTrigger,
  NavigationMenuLink,
  NavigationMenuIndicator,
  NavigationMenuViewport,
}
</file>

<file path="client/src/components/ui/pagination.tsx">
import * as React from "react"
import { ChevronLeft, ChevronRight, MoreHorizontal } from "lucide-react"

import { cn } from "@/lib/utils"
import { ButtonProps, buttonVariants } from "@/components/ui/button"

const Pagination = ({ className, ...props }: React.ComponentProps<"nav">) => (
  <nav
    role="navigation"
    aria-label="pagination"
    className={cn("mx-auto flex w-full justify-center", className)}
    {...props}
  />
)
Pagination.displayName = "Pagination"

const PaginationContent = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    className={cn("flex flex-row items-center gap-1", className)}
    {...props}
  />
))
PaginationContent.displayName = "PaginationContent"

const PaginationItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li ref={ref} className={cn("", className)} {...props} />
))
PaginationItem.displayName = "PaginationItem"

type PaginationLinkProps = {
  isActive?: boolean
} & Pick<ButtonProps, "size"> &
  React.ComponentProps<"a">

const PaginationLink = ({
  className,
  isActive,
  size = "icon",
  ...props
}: PaginationLinkProps) => (
  <a
    aria-current={isActive ? "page" : undefined}
    className={cn(
      buttonVariants({
        variant: isActive ? "outline" : "ghost",
        size,
      }),
      className
    )}
    {...props}
  />
)
PaginationLink.displayName = "PaginationLink"

const PaginationPrevious = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to previous page"
    size="default"
    className={cn("gap-1 pl-2.5", className)}
    {...props}
  >
    <ChevronLeft className="h-4 w-4" />
    <span>Previous</span>
  </PaginationLink>
)
PaginationPrevious.displayName = "PaginationPrevious"

const PaginationNext = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to next page"
    size="default"
    className={cn("gap-1 pr-2.5", className)}
    {...props}
  >
    <span>Next</span>
    <ChevronRight className="h-4 w-4" />
  </PaginationLink>
)
PaginationNext.displayName = "PaginationNext"

const PaginationEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    aria-hidden
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More pages</span>
  </span>
)
PaginationEllipsis.displayName = "PaginationEllipsis"

export {
  Pagination,
  PaginationContent,
  PaginationEllipsis,
  PaginationItem,
  PaginationLink,
  PaginationNext,
  PaginationPrevious,
}
</file>

<file path="client/src/components/ui/popover.tsx">
import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

const Popover = PopoverPrimitive.Root

const PopoverTrigger = PopoverPrimitive.Trigger

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-popover-content-transform-origin]",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent }
</file>

<file path="client/src/components/ui/progress.tsx">
"use client"

import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"

import { cn } from "@/lib/utils"

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn(
      "relative h-4 w-full overflow-hidden rounded-full bg-secondary",
      className
    )}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-primary transition-all"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
))
Progress.displayName = ProgressPrimitive.Root.displayName

export { Progress }
</file>

<file path="client/src/components/ui/radio-group.tsx">
import * as React from "react"
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group"
import { Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const RadioGroup = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Root
      className={cn("grid gap-2", className)}
      {...props}
      ref={ref}
    />
  )
})
RadioGroup.displayName = RadioGroupPrimitive.Root.displayName

const RadioGroupItem = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Item
      ref={ref}
      className={cn(
        "aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator className="flex items-center justify-center">
        <Circle className="h-2.5 w-2.5 fill-current text-current" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  )
})
RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName

export { RadioGroup, RadioGroupItem }
</file>

<file path="client/src/components/ui/resizable.tsx">
"use client"

import { GripVertical } from "lucide-react"
import * as ResizablePrimitive from "react-resizable-panels"

import { cn } from "@/lib/utils"

const ResizablePanelGroup = ({
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) => (
  <ResizablePrimitive.PanelGroup
    className={cn(
      "flex h-full w-full data-[panel-group-direction=vertical]:flex-col",
      className
    )}
    {...props}
  />
)

const ResizablePanel = ResizablePrimitive.Panel

const ResizableHandle = ({
  withHandle,
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {
  withHandle?: boolean
}) => (
  <ResizablePrimitive.PanelResizeHandle
    className={cn(
      "relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 [&[data-panel-group-direction=vertical]>div]:rotate-90",
      className
    )}
    {...props}
  >
    {withHandle && (
      <div className="z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border">
        <GripVertical className="h-2.5 w-2.5" />
      </div>
    )}
  </ResizablePrimitive.PanelResizeHandle>
)

export { ResizablePanelGroup, ResizablePanel, ResizableHandle }
</file>

<file path="client/src/components/ui/scroll-area.tsx">
import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }
</file>

<file path="client/src/components/ui/select.tsx">
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background data-[placeholder]:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-[--radix-select-content-available-height] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-select-content-transform-origin]",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}
</file>

<file path="client/src/components/ui/separator.tsx">
import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }
</file>

<file path="client/src/components/ui/sheet.tsx">
"use client"

import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Sheet = SheetPrimitive.Root

const SheetTrigger = SheetPrimitive.Trigger

const SheetClose = SheetPrimitive.Close

const SheetPortal = SheetPrimitive.Portal

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName

const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  }
)

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = "right", className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content
      ref={ref}
      className={cn(sheetVariants({ side }), className)}
      {...props}
    >
      {children}
      <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
    </SheetPrimitive.Content>
  </SheetPortal>
))
SheetContent.displayName = SheetPrimitive.Content.displayName

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
SheetHeader.displayName = "SheetHeader"

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
SheetFooter.displayName = "SheetFooter"

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold text-foreground", className)}
    {...props}
  />
))
SheetTitle.displayName = SheetPrimitive.Title.displayName

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
SheetDescription.displayName = SheetPrimitive.Description.displayName

export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}
</file>

<file path="client/src/components/ui/sidebar.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { VariantProps, cva } from "class-variance-authority"
import { PanelLeft } from "lucide-react"

import { useIsMobile } from "@/hooks/use-mobile"
import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Separator } from "@/components/ui/separator"
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
} from "@/components/ui/sheet"
import { Skeleton } from "@/components/ui/skeleton"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"

const SIDEBAR_COOKIE_NAME = "sidebar_state"
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7
const SIDEBAR_WIDTH = "16rem"
const SIDEBAR_WIDTH_MOBILE = "18rem"
const SIDEBAR_WIDTH_ICON = "3rem"
const SIDEBAR_KEYBOARD_SHORTCUT = "b"

type SidebarContextProps = {
  state: "expanded" | "collapsed"
  open: boolean
  setOpen: (open: boolean) => void
  openMobile: boolean
  setOpenMobile: (open: boolean) => void
  isMobile: boolean
  toggleSidebar: () => void
}

const SidebarContext = React.createContext<SidebarContextProps | null>(null)

function useSidebar() {
  const context = React.useContext(SidebarContext)
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.")
  }

  return context
}

const SidebarProvider = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    defaultOpen?: boolean
    open?: boolean
    onOpenChange?: (open: boolean) => void
  }
>(
  (
    {
      defaultOpen = true,
      open: openProp,
      onOpenChange: setOpenProp,
      className,
      style,
      children,
      ...props
    },
    ref
  ) => {
    const isMobile = useIsMobile()
    const [openMobile, setOpenMobile] = React.useState(false)

    // This is the internal state of the sidebar.
    // We use openProp and setOpenProp for control from outside the component.
    const [_open, _setOpen] = React.useState(defaultOpen)
    const open = openProp ?? _open
    const setOpen = React.useCallback(
      (value: boolean | ((value: boolean) => boolean)) => {
        const openState = typeof value === "function" ? value(open) : value
        if (setOpenProp) {
          setOpenProp(openState)
        } else {
          _setOpen(openState)
        }

        // This sets the cookie to keep the sidebar state.
        document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`
      },
      [setOpenProp, open]
    )

    // Helper to toggle the sidebar.
    const toggleSidebar = React.useCallback(() => {
      return isMobile
        ? setOpenMobile((open) => !open)
        : setOpen((open) => !open)
    }, [isMobile, setOpen, setOpenMobile])

    // Adds a keyboard shortcut to toggle the sidebar.
    React.useEffect(() => {
      const handleKeyDown = (event: KeyboardEvent) => {
        if (
          event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
          (event.metaKey || event.ctrlKey)
        ) {
          event.preventDefault()
          toggleSidebar()
        }
      }

      window.addEventListener("keydown", handleKeyDown)
      return () => window.removeEventListener("keydown", handleKeyDown)
    }, [toggleSidebar])

    // We add a state so that we can do data-state="expanded" or "collapsed".
    // This makes it easier to style the sidebar with Tailwind classes.
    const state = open ? "expanded" : "collapsed"

    const contextValue = React.useMemo<SidebarContextProps>(
      () => ({
        state,
        open,
        setOpen,
        isMobile,
        openMobile,
        setOpenMobile,
        toggleSidebar,
      }),
      [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
    )

    return (
      <SidebarContext.Provider value={contextValue}>
        <TooltipProvider delayDuration={0}>
          <div
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH,
                "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
                ...style,
              } as React.CSSProperties
            }
            className={cn(
              "group/sidebar-wrapper flex min-h-svh w-full has-[[data-variant=inset]]:bg-sidebar",
              className
            )}
            ref={ref}
            {...props}
          >
            {children}
          </div>
        </TooltipProvider>
      </SidebarContext.Provider>
    )
  }
)
SidebarProvider.displayName = "SidebarProvider"

const Sidebar = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    side?: "left" | "right"
    variant?: "sidebar" | "floating" | "inset"
    collapsible?: "offcanvas" | "icon" | "none"
  }
>(
  (
    {
      side = "left",
      variant = "sidebar",
      collapsible = "offcanvas",
      className,
      children,
      ...props
    },
    ref
  ) => {
    const { isMobile, state, openMobile, setOpenMobile } = useSidebar()

    if (collapsible === "none") {
      return (
        <div
          className={cn(
            "flex h-full w-[--sidebar-width] flex-col bg-sidebar text-sidebar-foreground",
            className
          )}
          ref={ref}
          {...props}
        >
          {children}
        </div>
      )
    }

    if (isMobile) {
      return (
        <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
          <SheetContent
            data-sidebar="sidebar"
            data-mobile="true"
            className="w-[--sidebar-width] bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden"
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH_MOBILE,
              } as React.CSSProperties
            }
            side={side}
          >
            <SheetHeader className="sr-only">
              <SheetTitle>Sidebar</SheetTitle>
              <SheetDescription>Displays the mobile sidebar.</SheetDescription>
            </SheetHeader>
            <div className="flex h-full w-full flex-col">{children}</div>
          </SheetContent>
        </Sheet>
      )
    }

    return (
      <div
        ref={ref}
        className="group peer hidden text-sidebar-foreground md:block"
        data-state={state}
        data-collapsible={state === "collapsed" ? collapsible : ""}
        data-variant={variant}
        data-side={side}
      >
        {/* This is what handles the sidebar gap on desktop */}
        <div
          className={cn(
            "relative w-[--sidebar-width] bg-transparent transition-[width] duration-200 ease-linear",
            "group-data-[collapsible=offcanvas]:w-0",
            "group-data-[side=right]:rotate-180",
            variant === "floating" || variant === "inset"
              ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon]"
          )}
        />
        <div
          className={cn(
            "fixed inset-y-0 z-10 hidden h-svh w-[--sidebar-width] transition-[left,right,width] duration-200 ease-linear md:flex",
            side === "left"
              ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
              : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
            // Adjust the padding for floating and inset variants.
            variant === "floating" || variant === "inset"
              ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+2px)]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon] group-data-[side=left]:border-r group-data-[side=right]:border-l",
            className
          )}
          {...props}
        >
          <div
            data-sidebar="sidebar"
            className="flex h-full w-full flex-col bg-sidebar group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border group-data-[variant=floating]:shadow"
          >
            {children}
          </div>
        </div>
      </div>
    )
  }
)
Sidebar.displayName = "Sidebar"

const SidebarTrigger = React.forwardRef<
  React.ElementRef<typeof Button>,
  React.ComponentProps<typeof Button>
>(({ className, onClick, ...props }, ref) => {
  const { toggleSidebar } = useSidebar()

  return (
    <Button
      ref={ref}
      data-sidebar="trigger"
      variant="ghost"
      size="icon"
      className={cn("h-7 w-7", className)}
      onClick={(event) => {
        onClick?.(event)
        toggleSidebar()
      }}
      {...props}
    >
      <PanelLeft />
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  )
})
SidebarTrigger.displayName = "SidebarTrigger"

const SidebarRail = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button">
>(({ className, ...props }, ref) => {
  const { toggleSidebar } = useSidebar()

  return (
    <button
      ref={ref}
      data-sidebar="rail"
      aria-label="Toggle Sidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle Sidebar"
      className={cn(
        "absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] hover:after:bg-sidebar-border group-data-[side=left]:-right-4 group-data-[side=right]:left-0 sm:flex",
        "[[data-side=left]_&]:cursor-w-resize [[data-side=right]_&]:cursor-e-resize",
        "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
        "group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full group-data-[collapsible=offcanvas]:hover:bg-sidebar",
        "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
        "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
        className
      )}
      {...props}
    />
  )
})
SidebarRail.displayName = "SidebarRail"

const SidebarInset = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"main">
>(({ className, ...props }, ref) => {
  return (
    <main
      ref={ref}
      className={cn(
        "relative flex w-full flex-1 flex-col bg-background",
        "md:peer-data-[variant=inset]:m-2 md:peer-data-[state=collapsed]:peer-data-[variant=inset]:ml-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow",
        className
      )}
      {...props}
    />
  )
})
SidebarInset.displayName = "SidebarInset"

const SidebarInput = React.forwardRef<
  React.ElementRef<typeof Input>,
  React.ComponentProps<typeof Input>
>(({ className, ...props }, ref) => {
  return (
    <Input
      ref={ref}
      data-sidebar="input"
      className={cn(
        "h-8 w-full bg-background shadow-none focus-visible:ring-2 focus-visible:ring-sidebar-ring",
        className
      )}
      {...props}
    />
  )
})
SidebarInput.displayName = "SidebarInput"

const SidebarHeader = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="header"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarHeader.displayName = "SidebarHeader"

const SidebarFooter = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="footer"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarFooter.displayName = "SidebarFooter"

const SidebarSeparator = React.forwardRef<
  React.ElementRef<typeof Separator>,
  React.ComponentProps<typeof Separator>
>(({ className, ...props }, ref) => {
  return (
    <Separator
      ref={ref}
      data-sidebar="separator"
      className={cn("mx-2 w-auto bg-sidebar-border", className)}
      {...props}
    />
  )
})
SidebarSeparator.displayName = "SidebarSeparator"

const SidebarContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="content"
      className={cn(
        "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarContent.displayName = "SidebarContent"

const SidebarGroup = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="group"
      className={cn("relative flex w-full min-w-0 flex-col p-2", className)}
      {...props}
    />
  )
})
SidebarGroup.displayName = "SidebarGroup"

const SidebarGroupLabel = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "div"

  return (
    <Comp
      ref={ref}
      data-sidebar="group-label"
      className={cn(
        "flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium text-sidebar-foreground/70 outline-none ring-sidebar-ring transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupLabel.displayName = "SidebarGroupLabel"

const SidebarGroupAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      ref={ref}
      data-sidebar="group-action"
      className={cn(
        "absolute right-3 top-3.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupAction.displayName = "SidebarGroupAction"

const SidebarGroupContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar="group-content"
    className={cn("w-full text-sm", className)}
    {...props}
  />
))
SidebarGroupContent.displayName = "SidebarGroupContent"

const SidebarMenu = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu"
    className={cn("flex w-full min-w-0 flex-col gap-1", className)}
    {...props}
  />
))
SidebarMenu.displayName = "SidebarMenu"

const SidebarMenuItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    data-sidebar="menu-item"
    className={cn("group/menu-item relative", className)}
    {...props}
  />
))
SidebarMenuItem.displayName = "SidebarMenuItem"

const sidebarMenuButtonVariants = cva(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:!size-8 group-data-[collapsible=icon]:!p-2 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline:
          "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:!p-0",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const SidebarMenuButton = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean
    isActive?: boolean
    tooltip?: string | React.ComponentProps<typeof TooltipContent>
  } & VariantProps<typeof sidebarMenuButtonVariants>
>(
  (
    {
      asChild = false,
      isActive = false,
      variant = "default",
      size = "default",
      tooltip,
      className,
      ...props
    },
    ref
  ) => {
    const Comp = asChild ? Slot : "button"
    const { isMobile, state } = useSidebar()

    const button = (
      <Comp
        ref={ref}
        data-sidebar="menu-button"
        data-size={size}
        data-active={isActive}
        className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
        {...props}
      />
    )

    if (!tooltip) {
      return button
    }

    if (typeof tooltip === "string") {
      tooltip = {
        children: tooltip,
      }
    }

    return (
      <Tooltip>
        <TooltipTrigger asChild>{button}</TooltipTrigger>
        <TooltipContent
          side="right"
          align="center"
          hidden={state !== "collapsed" || isMobile}
          {...tooltip}
        />
      </Tooltip>
    )
  }
)
SidebarMenuButton.displayName = "SidebarMenuButton"

const SidebarMenuAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean
    showOnHover?: boolean
  }
>(({ className, asChild = false, showOnHover = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-action"
      className={cn(
        "absolute right-1 top-1.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 peer-hover/menu-button:text-sidebar-accent-foreground [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        showOnHover &&
          "group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground md:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuAction.displayName = "SidebarMenuAction"

const SidebarMenuBadge = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar="menu-badge"
    className={cn(
      "pointer-events-none absolute right-1 flex h-5 min-w-5 select-none items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums text-sidebar-foreground",
      "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
      "peer-data-[size=sm]/menu-button:top-1",
      "peer-data-[size=default]/menu-button:top-1.5",
      "peer-data-[size=lg]/menu-button:top-2.5",
      "group-data-[collapsible=icon]:hidden",
      className
    )}
    {...props}
  />
))
SidebarMenuBadge.displayName = "SidebarMenuBadge"

const SidebarMenuSkeleton = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    showIcon?: boolean
  }
>(({ className, showIcon = false, ...props }, ref) => {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`
  }, [])

  return (
    <div
      ref={ref}
      data-sidebar="menu-skeleton"
      className={cn("flex h-8 items-center gap-2 rounded-md px-2", className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className="size-4 rounded-md"
          data-sidebar="menu-skeleton-icon"
        />
      )}
      <Skeleton
        className="h-4 max-w-[--skeleton-width] flex-1"
        data-sidebar="menu-skeleton-text"
        style={
          {
            "--skeleton-width": width,
          } as React.CSSProperties
        }
      />
    </div>
  )
})
SidebarMenuSkeleton.displayName = "SidebarMenuSkeleton"

const SidebarMenuSub = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu-sub"
    className={cn(
      "mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l border-sidebar-border px-2.5 py-0.5",
      "group-data-[collapsible=icon]:hidden",
      className
    )}
    {...props}
  />
))
SidebarMenuSub.displayName = "SidebarMenuSub"

const SidebarMenuSubItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ ...props }, ref) => <li ref={ref} {...props} />)
SidebarMenuSubItem.displayName = "SidebarMenuSubItem"

const SidebarMenuSubButton = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentProps<"a"> & {
    asChild?: boolean
    size?: "sm" | "md"
    isActive?: boolean
  }
>(({ asChild = false, size = "md", isActive, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        "flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground outline-none ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        size === "sm" && "text-xs",
        size === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuSubButton.displayName = "SidebarMenuSubButton"

export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
}
</file>

<file path="client/src/components/ui/skeleton.tsx">
import { cn } from "@/lib/utils"

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-muted", className)}
      {...props}
    />
  )
}

export { Skeleton }
</file>

<file path="client/src/components/ui/slider.tsx">
import * as React from "react"
import * as SliderPrimitive from "@radix-ui/react-slider"

import { cn } from "@/lib/utils"

const Slider = React.forwardRef<
  React.ElementRef<typeof SliderPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>
>(({ className, ...props }, ref) => (
  <SliderPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex w-full touch-none select-none items-center",
      className
    )}
    {...props}
  >
    <SliderPrimitive.Track className="relative h-2 w-full grow overflow-hidden rounded-full bg-secondary">
      <SliderPrimitive.Range className="absolute h-full bg-primary" />
    </SliderPrimitive.Track>
    <SliderPrimitive.Thumb className="block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50" />
  </SliderPrimitive.Root>
))
Slider.displayName = SliderPrimitive.Root.displayName

export { Slider }
</file>

<file path="client/src/components/ui/switch.tsx">
import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }
</file>

<file path="client/src/components/ui/table.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className)}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}
</file>

<file path="client/src/components/ui/tabs.tsx">
import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }
</file>

<file path="client/src/components/ui/textarea.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

const Textarea = React.forwardRef<
  HTMLTextAreaElement,
  React.ComponentProps<"textarea">
>(({ className, ...props }, ref) => {
  return (
    <textarea
      className={cn(
        "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      ref={ref}
      {...props}
    />
  )
})
Textarea.displayName = "Textarea"

export { Textarea }
</file>

<file path="client/src/components/ui/toast.tsx">
import * as React from "react"
import * as ToastPrimitives from "@radix-ui/react-toast"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const ToastProvider = ToastPrimitives.Provider

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    )}
    {...props}
  />
))
ToastViewport.displayName = ToastPrimitives.Viewport.displayName

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive:
          "destructive group border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  )
})
Toast.displayName = ToastPrimitives.Root.displayName

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    )}
    {...props}
  />
))
ToastAction.displayName = ToastPrimitives.Action.displayName

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
))
ToastClose.displayName = ToastPrimitives.Close.displayName

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold", className)}
    {...props}
  />
))
ToastTitle.displayName = ToastPrimitives.Title.displayName

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
))
ToastDescription.displayName = ToastPrimitives.Description.displayName

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>

type ToastActionElement = React.ReactElement<typeof ToastAction>

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
}
</file>

<file path="client/src/components/ui/toaster.tsx">
import { useToast } from "@/hooks/use-toast"
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "@/components/ui/toast"

export function Toaster() {
  const { toasts } = useToast()

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        )
      })}
      <ToastViewport />
    </ToastProvider>
  )
}
</file>

<file path="client/src/components/ui/toggle-group.tsx">
"use client"

import * as React from "react"
import * as ToggleGroupPrimitive from "@radix-ui/react-toggle-group"
import { type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"
import { toggleVariants } from "@/components/ui/toggle"

const ToggleGroupContext = React.createContext<
  VariantProps<typeof toggleVariants>
>({
  size: "default",
  variant: "default",
})

const ToggleGroup = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, children, ...props }, ref) => (
  <ToggleGroupPrimitive.Root
    ref={ref}
    className={cn("flex items-center justify-center gap-1", className)}
    {...props}
  >
    <ToggleGroupContext.Provider value={{ variant, size }}>
      {children}
    </ToggleGroupContext.Provider>
  </ToggleGroupPrimitive.Root>
))

ToggleGroup.displayName = ToggleGroupPrimitive.Root.displayName

const ToggleGroupItem = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Item> &
    VariantProps<typeof toggleVariants>
>(({ className, children, variant, size, ...props }, ref) => {
  const context = React.useContext(ToggleGroupContext)

  return (
    <ToggleGroupPrimitive.Item
      ref={ref}
      className={cn(
        toggleVariants({
          variant: context.variant || variant,
          size: context.size || size,
        }),
        className
      )}
      {...props}
    >
      {children}
    </ToggleGroupPrimitive.Item>
  )
})

ToggleGroupItem.displayName = ToggleGroupPrimitive.Item.displayName

export { ToggleGroup, ToggleGroupItem }
</file>

<file path="client/src/components/ui/toggle.tsx">
import * as React from "react"
import * as TogglePrimitive from "@radix-ui/react-toggle"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const toggleVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0 gap-2",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline:
          "border border-input bg-transparent hover:bg-accent hover:text-accent-foreground",
      },
      size: {
        default: "h-10 px-3 min-w-10",
        sm: "h-9 px-2.5 min-w-9",
        lg: "h-11 px-5 min-w-11",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const Toggle = React.forwardRef<
  React.ElementRef<typeof TogglePrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, ...props }, ref) => (
  <TogglePrimitive.Root
    ref={ref}
    className={cn(toggleVariants({ variant, size, className }))}
    {...props}
  />
))

Toggle.displayName = TogglePrimitive.Root.displayName

export { Toggle, toggleVariants }
</file>

<file path="client/src/components/ui/tooltip.tsx">
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-tooltip-content-transform-origin]",
      className
    )}
    {...props}
  />
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }
</file>

<file path="client/src/components/ui/use-toast.ts">
// Adapted from shadcn-ui toast component
import * as React from "react"

import {
  type ToastActionElement,
  type ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 5
const TOAST_REMOVE_DELAY = 1000000

type ToastType = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_VALUE
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToastType
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToastType>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToastType["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToastType["id"]
    }

interface State {
  toasts: ToastType[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

interface Toast extends Omit<ToastType, "id"> {}

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToastType) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open: boolean) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }
</file>

<file path="client/src/components/whatsapp/WhatsappButton.tsx">
import { MessageCircle } from 'lucide-react';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';

interface WhatsappButtonProps {
  onClick: () => void;
  className?: string;
}

const WhatsappButton = ({ onClick, className = '' }: WhatsappButtonProps) => {
  return (
    <TooltipProvider>
      <Tooltip>
        <TooltipTrigger asChild>
          <button
            onClick={onClick}
            className={`p-1.5 text-green-600 dark:text-green-400 hover:bg-green-50 dark:hover:bg-green-900/20 rounded transition-colors ${className}`}
            aria-label="Abrir WhatsApp"
          >
            <MessageCircle size={18} />
          </button>
        </TooltipTrigger>
        <TooltipContent>
          <p>Abrir WhatsApp</p>
        </TooltipContent>
      </Tooltip>
    </TooltipProvider>
  );
};

export default WhatsappButton;
</file>

<file path="client/src/components/whatsapp/WhatsappChat.tsx">
import { useState, useEffect, useRef, FormEvent } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { Lead, WhatsappMessage } from '@shared/schema';
import { apiRequest } from '@/lib/queryClient';
import { useToast } from '@/hooks/use-toast';
import { 
  Paperclip, Send, Image, Mic, AlertCircle, MoreVertical, ChevronLeft, 
  Video, FileText, X, Check, RotateCw 
} from 'lucide-react';

import { Button } from '@/components/ui/button';
import { Avatar, AvatarFallback } from '@/components/ui/avatar';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { 
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuPortal,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import WhatsappTemplateSelector from './WhatsappTemplateSelector';

interface WhatsappChatProps {
  lead: Lead;
  onClose?: () => void;
}

const WhatsappChat = ({ lead, onClose }: WhatsappChatProps) => {
  const [message, setMessage] = useState('');
  const [attaching, setAttaching] = useState(false);
  const [showMediaDialog, setShowMediaDialog] = useState(false);
  const [mediaType, setMediaType] = useState<'image' | 'document' | 'audio' | 'video'>('image');
  const [mediaUrl, setMediaUrl] = useState('');
  const [mediaCaption, setMediaCaption] = useState('');
  const [documentName, setDocumentName] = useState('');
  // Missing state variables for image dialog
  const [showImageDialog, setShowImageDialog] = useState(false);
  const [imageUrl, setImageUrl] = useState('');
  const [imageCaption, setImageCaption] = useState('');
  const endOfMessagesRef = useRef<HTMLDivElement>(null);
  const queryClient = useQueryClient();
  const { toast } = useToast();

  // Buscar mensagens do lead
  const { data: messages = [], isLoading, error } = useQuery<WhatsappMessage[]>({
    queryKey: [`/api/whatsapp/lead/${lead.id}`],
    refetchInterval: 10000, // Atualizar a cada 10 segundos
  });

  // Function to reset media dialog state
  const resetMediaDialog = () => {
    setShowImageDialog(false);
    setImageUrl('');
    setImageCaption('');
    setShowMediaDialog(false);
    setMediaUrl('');
    setMediaCaption('');
    setDocumentName('');
  };

  // Error handler for media sending
  const handleSendMediaError = (error: any) => {
    console.error('Erro ao enviar mídia:', error);
    
    let errorMessage = 'Não foi possível enviar a mídia';
    
    // Verificar se é um erro específico de número não autorizado
    if (error?.response?.data?.isUnauthorizedNumber) {
      errorMessage = `Número ${lead.phone} não autorizado. Apenas números verificados podem receber mensagens no ambiente de teste.`;
    } else if (error?.response?.data?.error) {
      // Usar mensagem de erro da API quando disponível
      errorMessage = error.response.data.error;
    }
    
    toast({
      title: 'Erro no envio de mídia',
      description: errorMessage,
      variant: 'destructive',
    });
  };

  // Mutação para enviar mensagem de texto
  const sendMessageMutation = useMutation({
    mutationFn: async (content: string) => {
      return apiRequest('POST', '/api/whatsapp/send', {
        leadId: lead.id,
        direction: 'outgoing',
        content,
        status: 'sent',
      });
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [`/api/whatsapp/lead/${lead.id}`] });
      setMessage('');
    },
    onError: (error: any) => {
      console.error('Erro ao enviar mensagem:', error);
      
      let errorMessage = 'Não foi possível enviar a mensagem';
      
      // Verificar se é um erro específico de número não autorizado
      if (error?.response?.data?.isUnauthorizedNumber) {
        errorMessage = `Número ${lead.phone} não autorizado. Apenas números verificados podem receber mensagens no ambiente de teste.`;
      } else if (error?.response?.data?.error) {
        // Usar mensagem de erro da API quando disponível
        errorMessage = error.response.data.error;
      }
      
      toast({
        title: 'Erro no envio',
        description: errorMessage,
        variant: 'destructive',
      });
    },
  });
  
  // Mutação para enviar imagem
  const sendImageMutation = useMutation({
    mutationFn: async ({ url, caption }: { url: string; caption: string }) => {
      return apiRequest('POST', '/api/whatsapp/send-image', {
        leadId: lead.id,
        imageUrl: url,
        caption
      });
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [`/api/whatsapp/lead/${lead.id}`] });
      resetMediaDialog();
      toast({
        title: 'Imagem enviada',
        description: 'Imagem enviada com sucesso'
      });
    },
    onError: handleSendMediaError
  });

  // Rolar para o final das mensagens quando novas mensagens chegarem
  useEffect(() => {
    if (endOfMessagesRef.current) {
      endOfMessagesRef.current.scrollIntoView({ behavior: 'smooth' });
    }
  }, [messages]);
  
  // Verificar status das mensagens recentes periodicamente
  useEffect(() => {
    if (!messages.length) return;
    
    // Função para verificar status das mensagens enviadas recentemente
    const checkRecentMessageStatus = async () => {
      // Selecionar mensagens enviadas nas últimas 24 horas que têm messageId e não estão com status final
      const recentMessages = messages.filter(msg => {
        // Verifica se tem messageId, é de saída e não está em status final
        if (!msg.messageId || msg.direction !== 'outgoing') return false;
        if (msg.status === 'read' || msg.status === 'failed') return false;
        
        // Verifica se é recente (últimas 24 horas)
        const messageTime = new Date(msg.timestamp).getTime();
        const oneDayAgo = Date.now() - (24 * 60 * 60 * 1000);
        return messageTime > oneDayAgo;
      });
      
      // Verificar status de cada mensagem
      for (const message of recentMessages) {
        try {
          const response = await fetch(`/api/whatsapp/message-status/${message.messageId}`);
          if (response.ok) {
            const data = await response.json();
            if (data.success && data.status !== message.status) {
              // Se o status mudou, atualizar as mensagens
              queryClient.invalidateQueries({ queryKey: [`/api/whatsapp/lead/${lead.id}`] });
              break; // Uma atualização é suficiente para recarregar todas as mensagens
            }
          }
        } catch (error) {
          console.warn('Erro ao verificar status da mensagem:', error);
        }
      }
    };
    
    // Verificar inicialmente após 10 segundos
    const initialTimeout = setTimeout(checkRecentMessageStatus, 10000);
    
    // Depois verificar a cada 30 segundos
    const interval = setInterval(checkRecentMessageStatus, 30000);
    
    return () => {
      clearTimeout(initialTimeout);
      clearInterval(interval);
    };
  }, [messages, lead.id, queryClient]);

  const handleSendMessage = (e: React.FormEvent) => {
    e.preventDefault();
    
    if (message.trim()) {
      sendMessageMutation.mutate(message.trim());
    }
  };
  
  const handleSendImage = () => {
    if (!imageUrl) {
      toast({
        title: 'URL da imagem obrigatória',
        description: 'Por favor, insira uma URL válida para a imagem',
        variant: 'destructive'
      });
      return;
    }
    
    sendImageMutation.mutate({ 
      url: imageUrl, 
      caption: imageCaption 
    });
  };

  const formatTime = (timestamp: string | Date) => {
    const date = new Date(timestamp);
    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-full">
        <div className="animate-spin rounded-full h-8 w-8 border-4 border-t-primary border-gray-200"></div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="flex items-center justify-center h-full text-red-500">
        <AlertCircle className="mr-2" />
        <span>Erro ao carregar mensagens</span>
      </div>
    );
  }

  return (
    <div className="flex flex-col h-full bg-background rounded-lg overflow-hidden border">
      {/* Cabeçalho do chat */}
      <div className="p-4 border-b flex items-center justify-between">
        <div className="flex items-center">
          <Avatar className="h-10 w-10 mr-3">
            <AvatarFallback className="bg-primary-light text-white font-semibold">
              {lead.name.substring(0, 2).toUpperCase()}
            </AvatarFallback>
          </Avatar>
          <div>
            <h3 className="font-medium text-sm">{lead.name}</h3>
            <p className="text-xs text-muted-foreground">{lead.phone || 'Sem telefone'}</p>
          </div>
        </div>
        <div className="flex items-center space-x-1">
          {/* Seletor de templates */}
          <WhatsappTemplateSelector lead={lead} onSuccess={() => {
            if (endOfMessagesRef.current) {
              setTimeout(() => endOfMessagesRef.current?.scrollIntoView({ behavior: 'smooth' }), 1000);
            }
          }} />
          
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button variant="ghost" size="icon" className="h-8 w-8">
                  <MoreVertical size={16} className="text-muted-foreground" />
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Mais opções</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        </div>
      </div>

      {/* Área de mensagens */}
      <div 
        className="flex-1 overflow-y-auto p-4 space-y-3" 
        style={{ backgroundImage: 'url("data:image/svg+xml,%3Csvg width=\'20\' height=\'20\' viewBox=\'0 0 40 40\' xmlns=\'http://www.w3.org/2000/svg\'%3E%3Cg fill=\'%239C92AC\' fill-opacity=\'0.05\' fill-rule=\'evenodd\'%3E%3Cpath d=\'M0 20L20 0h20L0 40z\'/%3E%3Cpath d=\'M20 40L40 20 40 40z\'/%3E%3C/g%3E%3C/svg%3E")' }}
      >
        {messages.length === 0 ? (
          <div className="flex flex-col items-center justify-center h-full text-center">
            <div className="bg-muted rounded-full p-4 mb-3">
              <AlertCircle className="h-6 w-6 text-muted-foreground" />
            </div>
            <h3 className="font-medium mb-1">Nenhuma mensagem ainda</h3>
            <p className="text-sm text-muted-foreground mb-2">
              Envie uma mensagem para iniciar a conversa com {lead.name}.
            </p>
          </div>
        ) : (
          messages.map((msg) => (
            <div 
              key={msg.id} 
              className={`flex ${msg.direction === 'outgoing' ? 'justify-end' : 'justify-start'}`}
            >
              <div 
                className={`max-w-xs md:max-w-md rounded-lg p-3 ${msg.direction === 'outgoing' ? 'bg-primary text-primary-foreground rounded-br-none' : 'bg-gray-100 dark:bg-muted text-gray-900 dark:text-muted-foreground rounded-bl-none'}`}
              >
                {msg.mediaUrl && msg.mediaType === 'image' ? (
                  <div className="space-y-2">
                    <img 
                      src={msg.mediaUrl} 
                      alt="Imagem" 
                      className="max-w-full rounded-md"
                      onError={(e) => {
                        e.currentTarget.src = 'https://via.placeholder.com/300x200?text=Erro+ao+carregar+imagem';
                      }} 
                    />
                    {msg.content && msg.content !== '[Imagem enviada]' && (
                      <p className="whitespace-pre-wrap break-words text-sm">{msg.content}</p>
                    )}
                  </div>
                ) : (
                  <p className="whitespace-pre-wrap break-words text-sm">{msg.content}</p>
                )}
                <div className="text-xs opacity-80 text-right mt-1 flex justify-end items-center">
                  {formatTime(msg.timestamp)}
                  {msg.direction === 'outgoing' && (
                    <span className="ml-1">
                      {msg.status === 'read' ? (
                        <span className="text-blue-400">✓✓</span>
                      ) : msg.status === 'delivered' ? (
                        <span>✓✓</span>
                      ) : (
                        <span>✓</span>
                      )}
                    </span>
                  )}
                </div>
              </div>
            </div>
          ))
        )}
        <div ref={endOfMessagesRef} />
      </div>

      {/* Input para nova mensagem */}
      <form onSubmit={handleSendMessage} className="p-3 border-t flex items-end">
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button 
                type="button"
                variant="ghost"
                size="icon"
                className="h-9 w-9 mr-1"
                onClick={() => setAttaching(!attaching)}
              >
                <Paperclip size={18} className="text-muted-foreground" />
              </Button>
            </TooltipTrigger>
            <TooltipContent side="top">
              <p>Anexar arquivo</p>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
        
        {attaching && (
          <div className="flex space-x-1">
            <TooltipProvider>
              <Tooltip>
                <TooltipTrigger asChild>
                  <Button 
                    type="button" 
                    variant="ghost" 
                    size="icon" 
                    className="h-9 w-9"
                    onClick={() => setShowImageDialog(true)}
                  >
                    <Image size={18} className="text-muted-foreground" />
                  </Button>
                </TooltipTrigger>
                <TooltipContent side="top">
                  <p>Enviar imagem</p>
                </TooltipContent>
              </Tooltip>
            </TooltipProvider>
            
            <TooltipProvider>
              <Tooltip>
                <TooltipTrigger asChild>
                  <Button type="button" variant="ghost" size="icon" className="h-9 w-9">
                    <Mic size={18} className="text-muted-foreground" />
                  </Button>
                </TooltipTrigger>
                <TooltipContent side="top">
                  <p>Enviar áudio</p>
                </TooltipContent>
              </Tooltip>
            </TooltipProvider>
          </div>
        )}
        
        <div className="flex-1 mr-2">
          <textarea
            value={message}
            onChange={(e) => setMessage(e.target.value)}
            placeholder="Digite uma mensagem"
            className="w-full p-2 border rounded-lg focus:outline-none focus:ring-1 focus:ring-primary resize-none min-h-[40px] max-h-32 text-sm"
            onKeyDown={(e) => {
              if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                if (message.trim()) {
                  handleSendMessage(e);
                }
              }
            }}
          />
        </div>
        
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button 
                type="submit" 
                className="h-9 w-9 p-0 rounded-full"
                disabled={!message.trim() || sendMessageMutation.isPending}
              >
                <Send size={16} />
              </Button>
            </TooltipTrigger>
            <TooltipContent side="top">
              <p>Enviar mensagem</p>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
      </form>
      
      {/* Dialog para upload de imagem */}
      <Dialog open={showImageDialog} onOpenChange={setShowImageDialog}>
        <DialogContent className="sm:max-w-md">
          <DialogHeader>
            <DialogTitle>Enviar Imagem</DialogTitle>
          </DialogHeader>
          <div className="space-y-4 py-2">
            <div className="space-y-2">
              <Label htmlFor="imageUrl">URL da Imagem</Label>
              <Input
                id="imageUrl"
                placeholder="https://exemplo.com/imagem.jpg"
                value={imageUrl}
                onChange={(e) => setImageUrl(e.target.value)}
              />
              <p className="text-xs text-muted-foreground">
                Insira a URL de uma imagem pública disponível na internet
              </p>
            </div>
            
            <div className="space-y-2">
              <Label htmlFor="caption">Legenda (opcional)</Label>
              <Input
                id="caption"
                placeholder="Escreva uma legenda para a imagem..."
                value={imageCaption}
                onChange={(e) => setImageCaption(e.target.value)}
              />
            </div>
            
            {imageUrl && (
              <div className="border rounded-md p-2 mt-2">
                <img 
                  src={imageUrl} 
                  alt="Pré-visualização" 
                  className="max-w-full h-auto rounded" 
                  onError={(e) => {
                    e.currentTarget.src = 'https://via.placeholder.com/300x200?text=Erro+ao+carregar+imagem';
                    toast({
                      title: 'Erro ao carregar imagem',
                      description: 'Verifique se a URL é válida e acessível',
                      variant: 'destructive'
                    });
                  }}
                />
              </div>
            )}
          </div>
          <div className="flex justify-end space-x-2">
            <Button variant="outline" onClick={() => setShowImageDialog(false)}>
              Cancelar
            </Button>
            <Button 
              onClick={handleSendImage} 
              disabled={!imageUrl || sendImageMutation.isPending}
            >
              Enviar Imagem
            </Button>
          </div>
        </DialogContent>
      </Dialog>
    </div>
  );
};

export default WhatsappChat;
</file>

<file path="client/src/components/whatsapp/WhatsappConfigForm.tsx">
import { useState, useEffect } from 'react';
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { apiRequest } from '@/lib/queryClient';
import { useToast } from '@/hooks/use-toast';
import { Eye, EyeOff, RefreshCw, RotateCw, Check, X } from 'lucide-react';

import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Separator } from '@/components/ui/separator';
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Badge } from '@/components/ui/badge';
import { Skeleton } from '@/components/ui/skeleton';

export default function WhatsappConfigForm() {
  const [apiUrl, setApiUrl] = useState('');
  const [apiToken, setApiToken] = useState('');
  const [apiInstance, setApiInstance] = useState('');
  const [activeTab, setActiveTab] = useState('general');
  const [showToken, setShowToken] = useState(false);
  const [qrCodeVisible, setQrCodeVisible] = useState(false);
  const { toast } = useToast();
  const queryClient = useQueryClient();

  // Consulta para obter a configuração atual
  const { data: configData, isLoading: isLoadingConfig } = useQuery({
    queryKey: ['/api/whatsapp/config'],
    onSuccess: (data) => {
      setApiUrl(data.apiUrl || '');
      setApiInstance(data.apiInstance || 'default');
      // Não definimos o token aqui pois o servidor não retorna o token completo por segurança
    },
    onError: (error: any) => {
      toast({
        title: 'Erro ao carregar configurações',
        description: 'Não foi possível carregar as configurações do WhatsApp.',
        variant: 'destructive',
      });
    },
  });

  // Consulta para verificar o status da conexão
  const { data: statusData, isLoading: isLoadingStatus, refetch: refetchStatus } = useQuery({
    queryKey: ['/api/whatsapp/status'],
    refetchInterval: 30000, // Refetch every 30 seconds
  });

  // Mutação para salvar as configurações
  const saveConfigMutation = useMutation({
    mutationFn: async () => {
      return apiRequest('POST', '/api/whatsapp/config', {
        apiUrl: apiUrl.trim(),
        apiToken: apiToken.trim() || undefined,
        apiInstance: apiInstance.trim() || 'default',
      });
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['/api/whatsapp/config'] });
      queryClient.invalidateQueries({ queryKey: ['/api/whatsapp/status'] });
      toast({
        title: 'Configurações salvas',
        description: 'As configurações do WhatsApp foram salvas com sucesso.',
      });
      // Limpar o campo de token por segurança
      setApiToken('');
      setShowToken(false);
    },
    onError: (error: any) => {
      toast({
        title: 'Erro ao salvar configurações',
        description: error?.response?.data?.message || 'Não foi possível salvar as configurações do WhatsApp.',
        variant: 'destructive',
      });
    },
  });

  // Mutação para obter o QR Code
  const qrCodeMutation = useMutation({
    mutationFn: async () => {
      return apiRequest('GET', '/api/whatsapp/qrcode');
    },
    onSuccess: (data) => {
      setQrCodeVisible(true);
      // Também atualizamos o status para ver se o QR code funcionou
      setTimeout(() => {
        refetchStatus();
      }, 5000);
    },
    onError: (error: any) => {
      toast({
        title: 'Erro ao gerar QR Code',
        description: error?.response?.data?.message || 'Não foi possível gerar o QR Code para conexão.',
        variant: 'destructive',
      });
    },
  });

  // Salvar configurações
  const handleSaveConfig = () => {
    if (!apiUrl) {
      toast({
        title: 'URL da API obrigatória',
        description: 'Por favor, informe a URL da Evolution API.',
        variant: 'destructive',
      });
      return;
    }
    saveConfigMutation.mutate();
  };

  // Gerar QR Code
  const handleGenerateQRCode = () => {
    qrCodeMutation.mutate();
  };

  return (
    <Tabs value={activeTab} onValueChange={setActiveTab} className="w-full">
      <TabsList className="grid w-full grid-cols-2">
        <TabsTrigger value="general">Geral</TabsTrigger>
        <TabsTrigger value="connection">Conexão</TabsTrigger>
      </TabsList>
      
      <TabsContent value="general" className="mt-4">
        <Card>
          <CardHeader>
            <CardTitle>Configurações da Evolution API</CardTitle>
            <CardDescription>
              Configure a integração com a Evolution API para enviar e receber mensagens via WhatsApp.
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="api-url">URL da API</Label>
              <Input
                id="api-url"
                value={apiUrl}
                onChange={(e) => setApiUrl(e.target.value)}
                placeholder="https://evolution-api.exemplo.com/api/v1"
                disabled={isLoadingConfig}
              />
              <p className="text-xs text-muted-foreground">
                URL completa da Evolution API, incluindo o prefixo e versão (ex: https://evolution-api.exemplo.com/api/v1)
              </p>
            </div>
            
            <div className="space-y-2">
              <Label htmlFor="api-token">Token da API</Label>
              <div className="flex gap-2">
                <div className="relative flex-1">
                  <Input
                    id="api-token"
                    type={showToken ? "text" : "password"}
                    value={apiToken}
                    onChange={(e) => setApiToken(e.target.value)}
                    placeholder={configData?.hasToken ? "••••••••••••••••" : "Token de autenticação"}
                    disabled={isLoadingConfig}
                  />
                  <button 
                    type="button"
                    className="absolute right-2 top-1/2 transform -translate-y-1/2 text-gray-500 hover:text-gray-700"
                    onClick={() => setShowToken(!showToken)}
                  >
                    {showToken ? <EyeOff size={18} /> : <Eye size={18} />}
                  </button>
                </div>
              </div>
              <p className="text-xs text-muted-foreground">
                {configData?.hasToken
                  ? "Token já configurado. Preencha apenas se desejar alterar."
                  : "Token de autenticação para a Evolution API (obrigatório)"}
              </p>
            </div>
            
            <div className="space-y-2">
              <Label htmlFor="api-instance">Nome da Instância</Label>
              <Input
                id="api-instance"
                value={apiInstance}
                onChange={(e) => setApiInstance(e.target.value)}
                placeholder="default"
                disabled={isLoadingConfig}
              />
              <p className="text-xs text-muted-foreground">
                Nome da instância na Evolution API. Use "default" se não tiver certeza.
              </p>
            </div>
          </CardContent>
          <CardFooter className="flex justify-between">
            <div className="flex items-center text-sm text-muted-foreground">
              {configData?.lastUpdated && (
                <span>Última atualização: {new Date(configData.lastUpdated).toLocaleString()}</span>
              )}
            </div>
            <Button 
              onClick={handleSaveConfig} 
              disabled={saveConfigMutation.isPending || isLoadingConfig}
            >
              {saveConfigMutation.isPending ? (
                <>
                  <RotateCw className="mr-2 h-4 w-4 animate-spin" />
                  Salvando...
                </>
              ) : (
                'Salvar Configurações'
              )}
            </Button>
          </CardFooter>
        </Card>
      </TabsContent>
      
      <TabsContent value="connection" className="mt-4">
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center justify-between">
              <span>Status da Conexão</span>
              <Button
                variant="outline"
                size="sm"
                onClick={() => refetchStatus()}
                disabled={isLoadingStatus}
              >
                <RefreshCw className={`h-4 w-4 mr-2 ${isLoadingStatus ? 'animate-spin' : ''}`} />
                Atualizar
              </Button>
            </CardTitle>
            <CardDescription>
              Verifique o status da conexão com o WhatsApp e configure o dispositivo.
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            {isLoadingStatus ? (
              <div className="space-y-2">
                <Skeleton className="h-4 w-[250px]" />
                <Skeleton className="h-4 w-[200px]" />
                <Skeleton className="h-12 w-full" />
              </div>
            ) : statusData ? (
              <div className="space-y-4">
                <div className="flex items-center justify-between">
                  <div>
                    <p className="text-sm font-medium">Status:</p>
                    <div className="flex items-center gap-2 mt-1">
                      {statusData.status === 'connected' ? (
                        <Badge variant="outline" className="bg-green-50 text-green-700 border-green-200">
                          <Check className="h-3 w-3 mr-1" /> Conectado
                        </Badge>
                      ) : (
                        <Badge variant="outline" className="bg-red-50 text-red-700 border-red-200">
                          <X className="h-3 w-3 mr-1" /> Desconectado
                        </Badge>
                      )}
                    </div>
                  </div>
                  
                  <div>
                    <p className="text-sm font-medium">Telefone:</p>
                    <p className="text-sm text-muted-foreground mt-1">
                      {statusData.phone || 'Não disponível'}
                    </p>
                  </div>
                </div>
                
                <Separator />
                
                {statusData.status !== 'connected' && (
                  <div className="space-y-4">
                    <p className="text-sm">
                      Para conectar o WhatsApp, escaneie o QR Code abaixo com seu celular:
                    </p>
                    
                    <div className="flex flex-col items-center justify-center border rounded-lg p-4">
                      {qrCodeMutation.isPending ? (
                        <div className="w-64 h-64 flex items-center justify-center">
                          <RotateCw className="h-10 w-10 animate-spin text-primary" />
                        </div>
                      ) : qrCodeMutation.data?.details?.qrcode ? (
                        <div className="space-y-2">
                          <div className="overflow-hidden rounded-lg border border-gray-200">
                            <img
                              src={qrCodeMutation.data.details.qrcode}
                              alt="QR Code para conexão do WhatsApp"
                              className="w-64 h-64 object-contain"
                            />
                          </div>
                          <p className="text-xs text-center text-muted-foreground">
                            Este QR Code expira após alguns minutos. Se expirar, gere um novo.
                          </p>
                        </div>
                      ) : (
                        <div className="text-center space-y-4">
                          <p className="text-sm text-muted-foreground">
                            Clique no botão abaixo para gerar um QR Code para conexão
                          </p>
                          <Button 
                            onClick={handleGenerateQRCode}
                            disabled={!configData || qrCodeMutation.isPending}
                          >
                            Gerar QR Code
                          </Button>
                        </div>
                      )}
                    </div>
                    
                    <Alert className="bg-amber-50 border-amber-200">
                      <AlertTitle className="text-amber-800">Como conectar</AlertTitle>
                      <AlertDescription className="text-amber-700">
                        <ol className="list-decimal list-inside space-y-1 text-sm">
                          <li>Abra o WhatsApp no seu telefone</li>
                          <li>Toque em Menu ou Configurações</li>
                          <li>Selecione "Aparelhos conectados"</li>
                          <li>Toque em "Conectar um aparelho"</li>
                          <li>Escaneie o QR Code gerado</li>
                        </ol>
                      </AlertDescription>
                    </Alert>
                  </div>
                )}
                
                {statusData.status === 'connected' && (
                  <Alert className="bg-green-50 border-green-200">
                    <AlertTitle className="text-green-800">WhatsApp Conectado</AlertTitle>
                    <AlertDescription className="text-green-700">
                      <p className="text-sm">
                        Sua conta de WhatsApp está conectada e pronta para enviar e receber mensagens.
                      </p>
                    </AlertDescription>
                  </Alert>
                )}
              </div>
            ) : (
              <Alert variant="destructive">
                <AlertTitle>Erro de Conexão</AlertTitle>
                <AlertDescription>
                  Não foi possível obter o status da conexão. Verifique as configurações da API.
                </AlertDescription>
              </Alert>
            )}
          </CardContent>
        </Card>
      </TabsContent>
    </Tabs>
  );
}
</file>

<file path="client/src/components/whatsapp/WhatsappModal.tsx">
import { Sheet, SheetContent } from '@/components/ui/sheet';
import WhatsappChat from './WhatsappChat';
import { Lead } from '@shared/schema';

interface WhatsappModalProps {
  isOpen: boolean;
  onClose: () => void;
  lead: Lead | null;
}

const WhatsappModal = ({ isOpen, onClose, lead }: WhatsappModalProps) => {
  if (!lead) return null;
  
  return (
    <Sheet open={isOpen} onOpenChange={onClose}>
      <SheetContent side="right" className="p-0 sm:max-w-md w-full">
        <div className="h-full">
          <WhatsappChat lead={lead} onClose={onClose} />
        </div>
      </SheetContent>
    </Sheet>
  );
};

export default WhatsappModal;
</file>

<file path="client/src/components/whatsapp/WhatsappTemplateSelector.tsx">
import { useState } from 'react';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { Lead } from '@shared/schema';
import { apiRequest } from '@/lib/queryClient';
import { useToast } from '@/hooks/use-toast';
import { Send, AlertCircle } from 'lucide-react';
import { Button } from '@/components/ui/button';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
  DialogFooter,
  DialogClose
} from '@/components/ui/dialog';
import {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';

interface WhatsappTemplateSelectorProps {
  lead: Lead;
  onSuccess?: () => void;
}

// Tipos de template disponíveis conforme documentação
interface Template {
  id: string;
  name: string;
  description: string;
  category?: string;
}

// Utilizamos apenas templates pré-aprovados pela Meta
const availableTemplates: Template[] = [
  {
    id: 'hello_world',
    name: 'Boas-vindas',
    description: 'Mensagem de boas-vindas para novos leads',
    category: 'MARKETING'
  },
  {
    id: 'welcome_personal_training',
    name: 'Boas-vindas Treinamento',
    description: 'Mensagem de boas-vindas específica para treinamento pessoal',
    category: 'MARKETING'
  },
  {
    id: 'special_offer',
    name: 'Oferta Especial',
    description: 'Informar sobre promoção ou pacote especial',
    category: 'MARKETING'
  },
  {
    id: 'workout_plan',
    name: 'Plano de Treino',
    description: 'Confirmação de envio do plano de treino personalizado',
    category: 'UTILITY'
  },
  {
    id: 'agendamento_confirmado',
    name: 'Confirmação de Agendamento',
    description: 'Confirmar um agendamento de sessão de treinamento',
    category: 'UTILITY'
  },
  {
    id: 'lembrete_sessao',
    name: 'Lembrete de Sessão',
    description: 'Lembrar o cliente sobre uma sessão agendada',
    category: 'UTILITY'
  },
  {
    id: 'nutritional_plan',
    name: 'Plano Nutricional',
    description: 'Confirmação de envio do plano nutricional',
    category: 'UTILITY'
  },
  {
    id: 'progress_update',
    name: 'Atualização de Progresso',
    description: 'Solicitar atualização de progresso do aluno',
    category: 'UTILITY'
  }
];

const WhatsappTemplateSelector = ({ lead, onSuccess }: WhatsappTemplateSelectorProps) => {
  const [templateId, setTemplateId] = useState<string>('');
  const [isOpen, setIsOpen] = useState(false);
  const queryClient = useQueryClient();
  const { toast } = useToast();

  // Mutação para enviar template
  const sendTemplateMutation = useMutation({
    mutationFn: async (template: string) => {
      return apiRequest('POST', '/api/whatsapp/template', {
        leadId: lead.id,
        templateName: template,
        language: 'pt_BR'
      });
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [`/api/whatsapp/lead/${lead.id}`] });
      toast({
        title: 'Sucesso',
        description: 'Template enviado com sucesso',
      });
      if (onSuccess) onSuccess();
      setIsOpen(false);
    },
    onError: (error: any) => {
      console.error('Erro ao enviar template:', error);
      
      let errorMessage = 'Não foi possível enviar o template';
      
      // Verificar se é um erro específico de número não autorizado
      if (error?.response?.data?.isUnauthorizedNumber) {
        errorMessage = `Número ${lead.phone} não autorizado. Apenas números verificados podem receber mensagens no ambiente de teste.`;
      } else if (error?.response?.data?.error) {
        // Usar mensagem de erro da API quando disponível
        errorMessage = error.response.data.error;
      }
      
      // Verificar se o erro menciona template não encontrado
      if (errorMessage.toLowerCase().includes('template não encontrado') ||
          errorMessage.toLowerCase().includes('template not found')) {
        errorMessage = `Template "${availableTemplates.find(t => t.id === templateId)?.name || templateId}" não encontrado na plataforma Meta. Verifique se o template foi aprovado.`;
      }
      
      toast({
        title: 'Erro no envio do template',
        description: errorMessage,
        variant: 'destructive',
      });
    },
  });

  const handleSendTemplate = () => {
    if (templateId) {
      sendTemplateMutation.mutate(templateId);
    }
  };

  const getAvailableTemplatesByCategory = (category: string) => {
    return availableTemplates.filter(template => template.category === category);
  };

  const marketingTemplates = getAvailableTemplatesByCategory('MARKETING');
  const utilityTemplates = getAvailableTemplatesByCategory('UTILITY');
  
  return (
    <Dialog open={isOpen} onOpenChange={setIsOpen}>
      <DialogTrigger asChild>
        <Button 
          variant="ghost"
          size="sm"
          className="flex items-center gap-1 h-8 text-xs"
        >
          <Send size={14} />
          <span>Templates</span>
        </Button>
      </DialogTrigger>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Enviar Template</DialogTitle>
          <DialogDescription>
            Selecione um template pré-aprovado para enviar para {lead.name}.
          </DialogDescription>
        </DialogHeader>
        
        <div className="py-4">
          <Select value={templateId} onValueChange={setTemplateId}>
            <SelectTrigger className="w-full">
              <SelectValue placeholder="Escolha um template" />
            </SelectTrigger>
            <SelectContent>
              <SelectGroup>
                <SelectLabel>Marketing</SelectLabel>
                {marketingTemplates.map(template => (
                  <SelectItem key={template.id} value={template.id}>
                    {template.name}
                  </SelectItem>
                ))}
              </SelectGroup>
              <SelectGroup>
                <SelectLabel>Utilitários</SelectLabel>
                {utilityTemplates.map(template => (
                  <SelectItem key={template.id} value={template.id}>
                    {template.name}
                  </SelectItem>
                ))}
              </SelectGroup>
            </SelectContent>
          </Select>
          
          {templateId && (
            <div className="mt-4 p-3 bg-muted rounded-md">
              <h4 className="text-sm font-medium mb-1">
                {availableTemplates.find(t => t.id === templateId)?.name}
              </h4>
              <p className="text-xs text-muted-foreground">
                {availableTemplates.find(t => t.id === templateId)?.description}
              </p>
            </div>
          )}
        </div>
        
        <DialogFooter>
          <DialogClose asChild>
            <Button variant="outline" size="sm">Cancelar</Button>
          </DialogClose>
          <Button 
            onClick={handleSendTemplate} 
            disabled={!templateId || sendTemplateMutation.isPending}
            size="sm"
          >
            {sendTemplateMutation.isPending ? 'Enviando...' : 'Enviar Template'}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

export default WhatsappTemplateSelector;
</file>

<file path="client/src/config/openai.example.ts">
// Exemplo de configuração da API OpenAI
// Copie este arquivo para openai.ts e configure com suas credenciais
export const OPENAI_CONFIG = {
  API_KEY: 'sua-chave-da-api-openai-aqui',
  BASE_URL: 'https://api.openai.com/v1',
  MODEL: 'gpt-3.5-turbo',
  MAX_TOKENS: 1000,
  TEMPERATURE: 0.7
} as const;
</file>

<file path="client/src/context/LeadContext.tsx">
import { createContext, useContext, useState, useEffect, ReactNode } from "react";
import { Lead, InsertLead } from "@shared/schema";
import { apiRequest } from "@/lib/queryClient";
import { useQuery, useQueryClient } from "@tanstack/react-query";
import { useToast } from "@/hooks/use-toast";

interface LeadContextProps {
  selectedLead: Lead | null;
  setSelectedLead: (lead: Lead | null) => void;
  isDialogOpen: boolean;
  setIsDialogOpen: (isOpen: boolean) => void;
  createLead: (lead: InsertLead) => Promise<void>;
  updateLead: (id: number, lead: Partial<InsertLead>) => Promise<void>;
  deleteLead: (id: number) => Promise<void>;
  updateLeadsInBatch: (ids: number[], updates: Partial<InsertLead>) => Promise<number>;
  deleteLeadsInBatch: (ids: number[]) => Promise<number>;
  selectedLeadIds: number[];
  setSelectedLeadIds: (ids: number[]) => void;
}

const LeadContext = createContext<LeadContextProps | undefined>(undefined);

export function LeadProvider({ children }: { children: ReactNode }) {
  const [selectedLead, setSelectedLead] = useState<Lead | null>(null);
  const [isDialogOpen, setIsDialogOpen] = useState(false);
  const [selectedLeadIds, setSelectedLeadIds] = useState<number[]>([]);
  const queryClient = useQueryClient();
  const { toast } = useToast();

  // Create a new lead
  const createLead = async (lead: InsertLead) => {
    try {
      await apiRequest("POST", "/api/leads", lead);
      await queryClient.invalidateQueries({ queryKey: ["/api/leads"] });
      await queryClient.invalidateQueries({ queryKey: ["/api/stats"] });
      
      toast({
        title: "Sucesso",
        description: "Lead criado com sucesso",
      });
      
      setIsDialogOpen(false);
    } catch (error) {
      toast({
        title: "Erro",
        description: "Falha ao criar lead",
        variant: "destructive",
      });
      console.error("Error creating lead:", error);
    }
  };

  // Update an existing lead
  const updateLead = async (id: number, lead: Partial<InsertLead>) => {
    try {
      await apiRequest<Lead>("PATCH", `/api/leads/${id}`, lead);
      await queryClient.invalidateQueries({ queryKey: ["/api/leads"] });
      await queryClient.invalidateQueries({ queryKey: ["/api/stats"] });
      
      toast({
        title: "Sucesso",
        description: "Lead atualizado com sucesso",
      });
      
      setIsDialogOpen(false);
      setSelectedLead(null);
    } catch (error) {
      toast({
        title: "Erro",
        description: "Falha ao atualizar lead",
        variant: "destructive",
      });
      console.error("Error updating lead:", error);
    }
  };

  // Delete a lead
  const deleteLead = async (id: number) => {
    try {
      await apiRequest<void>("DELETE", `/api/leads/${id}`);
      await queryClient.invalidateQueries({ queryKey: ["/api/leads"] });
      await queryClient.invalidateQueries({ queryKey: ["/api/stats"] });
      
      toast({
        title: "Sucesso",
        description: "Lead excluído com sucesso",
      });
      
      setSelectedLead(null);
    } catch (error) {
      toast({
        title: "Erro",
        description: "Falha ao excluir lead",
        variant: "destructive",
      });
      console.error("Error deleting lead:", error);
    }
  };

  // Batch operations
  const updateLeadsInBatch = async (ids: number[], updates: Partial<InsertLead>): Promise<number> => {
    try {
      const response = await apiRequest<{ updatedCount: number }>("POST", "/api/leads/batch/update", { ids, updates });
      await queryClient.invalidateQueries({ queryKey: ["/api/leads"] });
      await queryClient.invalidateQueries({ queryKey: ["/api/stats"] });
      
      const updatedCount = response.updatedCount || 0;
      
      toast({
        title: "Sucesso",
        description: `${updatedCount} leads atualizados com sucesso`,
      });
      
      setSelectedLeadIds([]);
      return updatedCount;
    } catch (error) {
      toast({
        title: "Erro",
        description: "Falha ao atualizar leads em lote",
        variant: "destructive",
      });
      console.error("Error updating leads in batch:", error);
      return 0;
    }
  };

  const deleteLeadsInBatch = async (ids: number[]): Promise<number> => {
    try {
      const response = await apiRequest<{ deletedCount: number }>("POST", "/api/leads/batch/delete", { ids });
      await queryClient.invalidateQueries({ queryKey: ["/api/leads"] });
      await queryClient.invalidateQueries({ queryKey: ["/api/stats"] });
      
      const deletedCount = response.deletedCount || 0;
      
      toast({
        title: "Sucesso",
        description: `${deletedCount} leads excluídos com sucesso`,
      });
      
      setSelectedLeadIds([]);
      return deletedCount;
    } catch (error) {
      toast({
        title: "Erro",
        description: "Falha ao excluir leads em lote",
        variant: "destructive",
      });
      console.error("Error deleting leads in batch:", error);
      return 0;
    }
  };

  const value = {
    selectedLead,
    setSelectedLead,
    isDialogOpen,
    setIsDialogOpen,
    createLead,
    updateLead,
    deleteLead,
    updateLeadsInBatch,
    deleteLeadsInBatch,
    selectedLeadIds,
    setSelectedLeadIds
  };

  return <LeadContext.Provider value={value}>{children}</LeadContext.Provider>;
}

export function useLeadContext() {
  const context = useContext(LeadContext);
  if (context === undefined) {
    throw new Error("useLeadContext must be used within a LeadProvider");
  }
  return context;
}
</file>

<file path="client/src/context/TaskContext.tsx">
import React, { createContext, useContext, useState, useEffect, ReactNode, useCallback } from "react";
import { useToast } from "@/components/ui/use-toast";
import { apiRequest } from "@/lib/queryClient";
import { useAuth } from "@/hooks/use-auth";

interface Task {
  id: number;
  title: string;
  description?: string;
  assignedById: number;
  assignedToId: number;
  assignedByName?: string;
  assignedToName?: string;
  dueDate?: Date;
  priority: "low" | "medium" | "high";
  status: "backlog" | "pending" | "in_progress" | "completed" | "cancelled";
  // No longer using relatedLeadId and relatedLeadName
  // Tasks are now assigned to system users only
  createdAt: Date;
  updatedAt: Date;
  comments?: TaskComment[];
}

interface TaskComment {
  id: number;
  taskId: number;
  userId: number;
  userName?: string;
  content: string;
  createdAt: Date;
  updatedAt: Date;
}

interface TaskContextType {
  tasks: Task[];
  loading: boolean;
  error: string | null;
  fetchTasks: () => Promise<void>;
  fetchTaskById: (id: number) => Promise<Task | undefined>;
  createTask: (task: Omit<Task, "id" | "createdAt" | "updatedAt" | "comments">) => Promise<Task>;
  updateTask: (id: number, task: Partial<Task>) => Promise<Task>;
  deleteTask: (id: number) => Promise<boolean>;
  addComment: (taskId: number, content: string) => Promise<TaskComment>;
  addTaskComment: (taskId: number, comment: Partial<TaskComment>) => Promise<TaskComment>;
  deleteTaskComment: (commentId: number) => Promise<boolean>;
  myTasks: Task[];
  assignedTasks: Task[];
  completedTasks: Task[];
}

const TaskContext = createContext<TaskContextType | undefined>(undefined);

interface TaskProviderProps {
  children: ReactNode;
}

export const TaskProvider = ({ children }: TaskProviderProps) => {
  const [tasks, setTasks] = useState<Task[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const { toast } = useToast();
  const { user } = useAuth();

  // Carregar tarefas ao inicializar
  const fetchTasks = useCallback(async () => {
    setLoading(true);
    try {
      const response = await fetch('/api/tasks');
      if (!response.ok) {
        throw new Error(`Erro ao buscar tarefas: ${response.status}`);
      }
      
      const data = await response.json();
      
      // Converter datas de string para Date
      const processedTasks = data.map((task: any) => ({
        ...task,
        dueDate: task.dueDate ? new Date(task.dueDate) : undefined,
        createdAt: new Date(task.createdAt),
        updatedAt: new Date(task.updatedAt),
        comments: task.comments?.map((comment: any) => ({
          ...comment,
          createdAt: new Date(comment.createdAt),
          updatedAt: new Date(comment.updatedAt),
        })),
      }));
      
      setTasks(processedTasks);
      setLoading(false);
    } catch (err) {
      console.error("Erro ao carregar tarefas:", err);
      setError("Erro ao carregar tarefas");
      setLoading(false);
      
      toast({
        variant: "destructive",
        title: "Erro",
        description: "Não foi possível carregar as tarefas.",
      });
    }
  }, [toast]);

  useEffect(() => {
    fetchTasks();
  }, [fetchTasks]);

  const fetchTaskById = useCallback(async (id: number) => {
    try {
      const response = await fetch(`/api/tasks/${id}`);
      if (!response.ok) {
        throw new Error(`Erro ao buscar tarefa: ${response.status}`);
      }
      
      const task = await response.json();
      
      // Converter datas de string para Date
      const processedTask = {
        ...task,
        dueDate: task.dueDate ? new Date(task.dueDate) : undefined,
        createdAt: new Date(task.createdAt),
        updatedAt: new Date(task.updatedAt),
        comments: task.comments?.map((comment: any) => ({
          ...comment,
          createdAt: new Date(comment.createdAt),
          updatedAt: new Date(comment.updatedAt),
        })),
      };
      
      return processedTask;
    } catch (err) {
      console.error("Erro ao carregar detalhes da tarefa:", err);
      setError("Erro ao carregar detalhes da tarefa");
      
      toast({
        variant: "destructive",
        title: "Erro",
        description: "Não foi possível carregar os detalhes da tarefa.",
      });
      
      return undefined;
    }
  }, [toast]);

  const createTask = useCallback(async (task: Omit<Task, "id" | "createdAt" | "updatedAt" | "comments">) => {
    try {
      const response = await fetch('/api/tasks', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(task)
      });
      
      if (!response.ok) {
        throw new Error(`Erro ao criar tarefa: ${response.status}`);
      }
      
      const data = await response.json();
      
      // Converter datas de string para Date
      const newTask = {
        ...data,
        dueDate: data.dueDate ? new Date(data.dueDate) : undefined,
        createdAt: new Date(data.createdAt),
        updatedAt: new Date(data.updatedAt),
        comments: data.comments?.map((comment: any) => ({
          ...comment,
          createdAt: new Date(comment.createdAt),
          updatedAt: new Date(comment.updatedAt),
        })) || [],
      };
      
      // Atualizar estado local
      setTasks(prev => [...prev, newTask]);
      
      toast({
        title: "Sucesso",
        description: "Tarefa criada com sucesso.",
      });
      
      return newTask;
    } catch (err) {
      console.error("Erro ao criar tarefa:", err);
      setError("Erro ao criar tarefa");
      
      toast({
        variant: "destructive",
        title: "Erro",
        description: "Não foi possível criar a tarefa.",
      });
      
      throw err;
    }
  }, [toast]);

  const updateTask = useCallback(async (id: number, taskUpdate: Partial<Task>) => {
    try {
      const response = await fetch(`/api/tasks/${id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(taskUpdate)
      });
      
      if (!response.ok) {
        // Tenta obter detalhes do erro do backend
        let errorDetail = '';
        try {
          // Tenta JSON
          const errorData = await response.json();
          errorDetail = errorData.message || errorData.details || '';
        } catch (jsonError) {
          // Se não for JSON, tenta texto puro
          try {
            const text = await response.text();
            errorDetail = text || `${response.status}`;
          } catch {
            errorDetail = `${response.status}`;
          }
        }
        console.error(`Server error response: ${errorDetail}`);
        throw new Error(`Erro ao atualizar tarefa: ${errorDetail}`);
      }
      
      // Tentar processar a resposta com tratamento de erro robusto
      let data;
      try {
        const text = await response.text();
        data = text ? JSON.parse(text) : {};
      } catch (parseError) {
        console.error("Erro ao processar resposta JSON:", parseError);
        throw new Error("Formato de resposta inválido do servidor");
      }
      
      // Converter datas de string para Date com tratamento de valores inválidos
      const updatedTask = {
        ...data,
        dueDate: data.dueDate ? new Date(data.dueDate) : undefined,
        createdAt: data.createdAt ? new Date(data.createdAt) : new Date(),
        updatedAt: data.updatedAt ? new Date(data.updatedAt) : new Date(),
        comments: Array.isArray(data.comments) 
          ? data.comments.map((comment: any) => ({
              ...comment,
              createdAt: comment.createdAt ? new Date(comment.createdAt) : new Date(),
              updatedAt: comment.updatedAt ? new Date(comment.updatedAt) : new Date(),
            }))
          : [],
      };
      
      // Atualizar estado local
      setTasks(prev => prev.map(task => 
        task.id === id ? updatedTask : task
      ));
      
      toast({
        title: "Sucesso",
        description: "Tarefa atualizada com sucesso.",
      });
      
      return updatedTask;
    } catch (err) {
      console.error("Erro ao atualizar tarefa:", err);
      setError("Erro ao atualizar tarefa");
      
      toast({
        variant: "destructive",
        title: "Erro",
        description: `Não foi possível atualizar a tarefa. ${err instanceof Error ? err.message : ''}`,
      });
      
      throw err;
    }
  }, [toast]);

  const deleteTask = useCallback(async (id: number) => {
    try {
      const response = await fetch(`/api/tasks/${id}`, {
        method: 'DELETE'
      });
      
      if (!response.ok) {
        throw new Error(`Erro ao excluir tarefa: ${response.status}`);
      }
      
      // Atualizar estado local
      setTasks(prev => prev.filter(task => task.id !== id));
      
      toast({
        title: "Sucesso",
        description: "Tarefa excluída com sucesso.",
      });
      
      return true;
    } catch (err) {
      console.error("Erro ao excluir tarefa:", err);
      setError("Erro ao excluir tarefa");
      
      toast({
        variant: "destructive",
        title: "Erro",
        description: "Não foi possível excluir a tarefa.",
      });
      
      return false;
    }
  }, [toast]);

  const addComment = useCallback(async (taskId: number, content: string) => {
    if (!user) {
      toast({
        variant: "destructive",
        title: "Erro",
        description: "Você precisa estar logado para adicionar um comentário.",
      });
      return Promise.reject("Usuário não logado");
    }
    try {
      const response = await fetch(`/api/tasks/${taskId}/comments`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ content, userId: user.id })
      });

      if (!response.ok) {
        throw new Error(`Erro ao adicionar comentário: ${response.status}`);
      }

      const data = await response.json();
      const newComment = {
        ...data,
        createdAt: new Date(data.createdAt),
        updatedAt: new Date(data.updatedAt),
      };

      setTasks(prevTasks =>
        prevTasks.map(task =>
          task.id === taskId
            ? { ...task, comments: [...(task.comments || []), newComment] }
            : task
        )
      );

      toast({
        title: "Sucesso",
        description: "Comentário adicionado com sucesso.",
      });

      return newComment;
    } catch (err) {
      console.error("Erro ao adicionar comentário:", err);
      setError("Erro ao adicionar comentário");
      toast({
        variant: "destructive",
        title: "Erro",
        description: "Não foi possível adicionar o comentário.",
      });
      throw err;
    }
  }, [toast, user]);
  
  const addTaskComment = useCallback(async (taskId: number, comment: Partial<TaskComment>) => {
    if (!user) {
      toast({
        variant: "destructive",
        title: "Erro",
        description: "Você precisa estar logado para adicionar um comentário.",
      });
      return Promise.reject("Usuário não logado");
    }
    try {
      // Assume comment object includes userId if needed by backend or add it here
      const response = await fetch(`/api/tasks/${taskId}/comments`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ ...comment, userId: user.id }) // Ensure userId is sent
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ message: `Erro ao adicionar comentário: ${response.status}` }));
        throw new Error(errorData.message || `Erro ao adicionar comentário: ${response.status}`);
      }

      const data = await response.json();
      const newComment = {
        ...data,
        createdAt: new Date(data.createdAt),
        updatedAt: new Date(data.updatedAt),
        // Ensure userName is populated if backend sends it, or fetch/construct it
        userName: data.userName || user?.username || 'Usuário Desconhecido' 
      };

      setTasks(prevTasks =>
        prevTasks.map(task =>
          task.id === taskId
            ? { ...task, comments: [...(task.comments || []), newComment] }
            : task
        )
      );

      toast({
        title: "Sucesso",
        description: "Comentário adicionado com sucesso.",
      });

      return newComment;
    } catch (err: any) {
      console.error("Erro ao adicionar comentário:", err);
      setError(err.message || "Erro ao adicionar comentário");
      toast({
        variant: "destructive",
        title: "Erro",
        description: err.message || "Não foi possível adicionar o comentário.",
      });
      throw err;
    }
  }, [toast, user]);

  const deleteTaskComment = useCallback(async (commentId: number) => {
    try {
      const response = await fetch(`/api/tasks/comments/${commentId}`, {
        method: 'DELETE'
      });
      
      if (!response.ok) {
        throw new Error(`Erro ao excluir comentário: ${response.status}`);
      }
      
      // Update the tasks state to remove the comment
      setTasks(prevTasks => 
        prevTasks.map(task => {
          if (!task.comments) return task;
          
          return {
            ...task,
            comments: task.comments.filter(comment => comment.id !== commentId)
          };
        })
      );
      
      toast({
        title: "Sucesso",
        description: "Comentário excluído com sucesso.",
      });
      
      return true;
    } catch (err) {
      console.error("Erro ao excluir comentário:", err);
      setError("Erro ao excluir comentário");
      
      toast({
        variant: "destructive",
        title: "Erro",
        description: "Não foi possível excluir o comentário.",
      });
      
      return false;
    }
  }, [toast]);

  // Filtrar tarefas por usuário e status
  const currentUserId = user?.id || 0;
  const myTasks = tasks.filter(task => task.assignedToId === currentUserId && task.status !== "completed");
  const assignedTasks = tasks.filter(task => task.assignedById === currentUserId && task.status !== "completed");
  const completedTasks = tasks.filter(task => 
    (task.assignedToId === currentUserId || task.assignedById === currentUserId) && 
    task.status === "completed"
  );

  return (
    <TaskContext.Provider
      value={{
        tasks,
        loading,
        error,
        fetchTasks,
        fetchTaskById,
        createTask,
        updateTask,
        deleteTask,
        addComment,
        addTaskComment,
        deleteTaskComment,
        myTasks,
        assignedTasks,
        completedTasks,
      }}
    >
      {children}
    </TaskContext.Provider>
  );
};

export const useTaskContext = () => {
  const context = useContext(TaskContext);
  
  if (context === undefined) {
    throw new Error("useTaskContext deve ser usado dentro de um TaskProvider");
  }
  
  return context;
};
</file>

<file path="client/src/context/WhatsappContext.tsx">
import { createContext, useContext, useState, ReactNode, useEffect } from 'react';
import { Lead } from '@shared/schema';
import { useQuery } from '@tanstack/react-query';

interface WhatsappConnectionStatus {
  status: 'connected' | 'disconnected' | 'checking' | 'error';
  message?: string;
  details?: {
    name?: string;
    phone?: string;
    quality?: string;
    [key: string]: any;
  };
}

interface WhatsappContextProps {
  isWhatsappOpen: boolean;
  selectedLeadForWhatsapp: Lead | null;
  openWhatsappChat: (lead: Lead) => void;
  closeWhatsappChat: () => void;
  connectionStatus: WhatsappConnectionStatus;
  refreshConnectionStatus: () => void;
}

const WhatsappContext = createContext<WhatsappContextProps | undefined>(undefined);

export function WhatsappProvider({ children }: { children: ReactNode }) {
  const [isWhatsappOpen, setIsWhatsappOpen] = useState(false);
  const [selectedLeadForWhatsapp, setSelectedLeadForWhatsapp] = useState<Lead | null>(null);

  // Consulta do status da conexão WhatsApp
  const { data: statusData, refetch: refetchStatus, isLoading: isStatusLoading } = useQuery<{
    status: 'connected' | 'disconnected' | 'error';
    message: string;
    details?: {
      name?: string;
      phone?: string;
      quality?: string;
      [key: string]: any;
    };
  }>({
    queryKey: ['/api/whatsapp/status'],
    retry: 1,
    refetchOnWindowFocus: false,
    refetchInterval: 60000, // Verificar a cada minuto
  });

  // Definir o status da conexão com base na resposta da API
  const connectionStatus: WhatsappConnectionStatus = isStatusLoading
    ? { status: 'checking' }
    : statusData
      ? { 
          status: statusData.status, 
          message: statusData.message,
          details: statusData.details
        }
      : { status: 'error', message: 'Não foi possível verificar a conexão' };

  // Atualizar manualmente o status da conexão
  const refreshConnectionStatus = () => {
    refetchStatus();
  };

  const openWhatsappChat = (lead: Lead) => {
    setSelectedLeadForWhatsapp(lead);
    setIsWhatsappOpen(true);
  };

  const closeWhatsappChat = () => {
    setIsWhatsappOpen(false);
  };

  const value = {
    isWhatsappOpen,
    selectedLeadForWhatsapp,
    openWhatsappChat,
    closeWhatsappChat,
    connectionStatus,
    refreshConnectionStatus,
  };

  return <WhatsappContext.Provider value={value}>{children}</WhatsappContext.Provider>;
}

export function useWhatsappContext() {
  const context = useContext(WhatsappContext);
  if (context === undefined) {
    throw new Error('useWhatsappContext must be used within a WhatsappProvider');
  }
  return context;
}
</file>

<file path="client/src/global.d.ts">
declare module 'react-beautiful-dnd';
</file>

<file path="client/src/hooks/use-auth.tsx">
import { createContext, ReactNode, useContext } from "react";
import {
  useQuery,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { User, InsertUser } from "@shared/schema";
import { getQueryFn, apiRequest, queryClient } from "../lib/queryClient";
import { useToast } from "@/hooks/use-toast";

type AuthContextType = {
  user: User | null;
  isLoading: boolean;
  error: Error | null;
  loginMutation: UseMutationResult<User, Error, LoginData>;
  logoutMutation: UseMutationResult<void, Error, void>;
  registerMutation: UseMutationResult<User, Error, InsertUser>;
};

type LoginData = Pick<InsertUser, "username" | "password">;

export const AuthContext = createContext<AuthContextType | null>(null);

export function AuthProvider({ children }: { children: ReactNode }) {
  const { toast } = useToast();
  
  const {
    data: user,
    error,
    isLoading,
  } = useQuery<User | null, Error>({
    queryKey: ["/api/user"],
    queryFn: getQueryFn({ on401: "returnNull" }),
  });

  const loginMutation = useMutation({
    mutationFn: async (credentials: LoginData) => {
      return await apiRequest("POST", "/api/login", credentials);
    },
    onSuccess: (user: User) => {
      queryClient.setQueryData(["/api/user"], user);
      toast({
        title: "Login realizado",
        description: "Bem-vindo de volta!",
      });
      // Redirecionar para a página principal
      window.location.href = "/";
    },
    onError: (error: Error) => {
      toast({
        title: "Falha no login",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  const registerMutation = useMutation({
    mutationFn: async (credentials: InsertUser) => {
      return await apiRequest("POST", "/api/register", credentials);
    },
    onSuccess: (user: User) => {
      queryClient.setQueryData(["/api/user"], user);
      toast({
        title: "Registro realizado",
        description: "Sua conta foi criada com sucesso!",
      });
    },
    onError: (error: Error) => {
      toast({
        title: "Falha no registro",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  const logoutMutation = useMutation({
    mutationFn: async () => {
      await apiRequest("POST", "/api/logout");
    },
    onSuccess: () => {
      queryClient.setQueryData(["/api/user"], null);
      toast({
        title: "Logout realizado",
        description: "Você saiu da sua conta.",
      });
      // Redirecionar o usuário para a página de login
      window.location.href = '/auth';
    },
    onError: (error: Error) => {
      toast({
        title: "Falha no logout",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  return (
    <AuthContext.Provider
      value={{
        user: user ?? null,
        isLoading,
        error,
        loginMutation,
        logoutMutation,
        registerMutation,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error("useAuth deve ser usado dentro de um AuthProvider");
  }
  return context;
}
</file>

<file path="client/src/hooks/use-mobile.tsx">
import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}
</file>

<file path="client/src/hooks/use-toast.ts">
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }
</file>

<file path="client/src/index.css">
@import url('https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&family=Montserrat:wght@500;600;700&display=swap');
@import url('https://fonts.googleapis.com/icon?family=Material+Icons');

@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --background: 0 0% 100%;
  --foreground: 240 10% 3.9%;
  
  --muted: 240 4.8% 95.9%;
  --muted-foreground: 240 3.8% 46.1%;
  
  --popover: 0 0% 100%;
  --popover-foreground: 240 10% 3.9%;
  
  --card: 0 0% 100%;
  --card-foreground: 240 10% 3.9%;
  
  --border: 240 5.9% 90%;
  --input: 240 5.9% 90%;
  
  /* Favale&Pink brand colors */
  --primary: 340 86% 51%; /* #E91E63 (pink) */
  --primary-foreground: 0 0% 100%;
  
  --secondary: 260 69% 34%; /* #311B92 (dark purple) */
  --secondary-foreground: 0 0% 100%;
  
  --accent: 260 69% 45%;
  --accent-foreground: 0 0% 100%;
  
  --destructive: 0 84.2% 60.2%;
  --destructive-foreground: 0 0% 98%;
  
  --ring: 340 86% 51%;
  
  --radius: 0.5rem;
  
  /* Glow effect */
  --glow-primary: 0 0 20px hsla(340, 86%, 51%, 0.5);
  --glow-primary-strong: 0 0 30px hsla(340, 86%, 51%, 0.7);
  --glow-xs: 0 0 8px hsla(340, 86%, 51%, 0.4);
  --glow-focus: 0 0 0 2px hsla(340, 86%, 51%, 0.2);
  --glow-subtle: 0 0 5px hsla(340, 86%, 51%, 0.2);

  /* Chart colors */
  --chart-1: 340 86% 51%;
  --chart-2: 260 69% 34%;
  --chart-3: 212 100% 48%;
  --chart-4: 130 65% 38%;
  --chart-5: 45 93% 47%;
}

.dark {
  --background: 220 15% 12%; /* #191c22 em HSL aproximado */
  --foreground: 0 0% 98%; /* Texto quase branco */
  
  --muted: 220 10% 18%; /* Cinza intermediário para áreas menos importantes */
  --muted-foreground: 220 8% 70%;
  
  --popover: 220 15% 16%; /* Fundo de popover um pouco mais claro */
  --popover-foreground: 0 0% 98%;
  
  --card: 220 15% 14%; /* Cards levemente elevados */
  --card-foreground: 0 0% 98%;
  
  --border: 220 10% 30% / 0.25; /* Borda translúcida e mais suave */
  --input: 220 14% 20%;
  
  --primary: 260 100% 70%; /* Azul neon moderno */
  --primary-foreground: 0 0% 100%;
  
  --secondary: 280 80% 60%; /* Roxo suave */
  --secondary-foreground: 0 0% 100%;
  
  --accent: 260 85% 65%; /* Roxo suave para detalhes ao invés de verde */
  --accent-foreground: 0 0% 100%;
  
  --destructive: 0 70% 40%;
  --destructive-foreground: 0 0% 100%;
  
  --ring: 260 100% 70%;
  
  /* Glow bem suave para bordas e elementos */
  --glow-primary: 0 0 0 2px hsla(260, 100%, 70%, 0.10);
  --glow-primary-strong: 0 0 0 4px hsla(260, 100%, 70%, 0.15);
  --glow-primary-intense: 0 0 0 6px hsla(260, 100%, 70%, 0.18);
  --glow-xs: 0 0 0 1px hsla(260, 100%, 70%, 0.08);
  --glow-focus: 0 0 0 2px hsla(260, 100%, 70%, 0.12);
  --glow-subtle: 0 0 0 2px hsla(260, 100%, 70%, 0.07);
  --glow-border: 0 0 0 2px hsla(260, 100%, 70%, 0.10);
  --glow-text: 0 0 2px hsla(260, 100%, 70%, 0.18);

  /* Sugestão para popovers/menus modernos */
  /*
  .dark .popover, .dark .menu {
    background: hsla(var(--popover) / 0.85);
    backdrop-filter: blur(8px);
  }
  */
}

@layer base {
  * {
    @apply border-border;
  }
  
  body {
    @apply bg-background text-foreground font-sans antialiased transition-colors duration-300;
  }
  
  h1, h2, h3, h4, h5, h6 {
    @apply font-heading;
  }
  
  /* Transições suaves para melhor UX */
  button, a, input, select, textarea {
    @apply transition-all duration-200;
  }
  
  /* Efeitos de Glow no Dark Mode */
  .dark .glow {
    box-shadow: var(--glow-primary);
    transition: all 0.3s ease;
  }
  
  .dark .glow:hover {
    box-shadow: var(--glow-primary-strong);
  }
  
  .dark .glow-text {
    text-shadow: var(--glow-primary);
  }
  
  .dark .glow-text-subtle {
    text-shadow: var(--glow-subtle);
  }
  
  .dark .glow-text-intense {
    text-shadow: var(--glow-text);
  }
  
  .dark .glow-title {
    text-shadow: var(--glow-primary-strong);
  }
  
  .dark .glow-value {
    font-weight: 600;
    text-shadow: var(--glow-primary);
    letter-spacing: 0.02em;
  }
  
  .dark .glow-border {
    border-color: hsl(var(--primary));
    box-shadow: var(--glow-primary);
  }
  
  .dark .glow-border-subtle {
    border-color: hsl(var(--primary) / 0.6);
    box-shadow: var(--glow-subtle);
  }
  
  .dark .glow-xs {
    box-shadow: var(--glow-xs);
  }
  
  /* Botões com efeito Glow */
  .dark .glow-button-xs {
    box-shadow: var(--glow-xs);
    transition: all 0.2s ease;
  }
  
  .dark .glow-button-xs:hover {
    box-shadow: var(--glow-primary);
    transform: translateY(-1px);
  }
  
  .dark .glow-button-sm {
    box-shadow: var(--glow-primary);
    transition: all 0.2s ease;
  }
  
  .dark .glow-button-sm:hover {
    box-shadow: var(--glow-primary-strong);
    transform: translateY(-2px);
  }
  
  /* Efeitos para diferentes cores */
  .dark .glow-red-sm {
    box-shadow: 0 0 15px rgba(244, 67, 54, 0.5);
    transition: all 0.2s ease;
  }
  
  .dark .glow-red-sm:hover {
    box-shadow: 0 0 20px rgba(244, 67, 54, 0.7);
  }
  
  /* Cards com efeito Glow */
  .dark .glow-card {
    @apply border-primary/30 bg-card/90;
    box-shadow: var(--glow-subtle);
    transition: all 0.3s ease;
  }
  
  .dark .glow-card:hover {
    @apply border-primary/50;
    box-shadow: var(--glow-xs);
    transform: translateY(-2px);
  }
  
  /* Card com glow mais intenso */
  .dark .glow-card-intense {
    @apply border-primary/40 bg-card/90;
    box-shadow: var(--glow-primary);
    transition: all 0.3s ease;
  }
  
  .dark .glow-card-intense:hover {
    @apply border-primary/60;
    box-shadow: var(--glow-primary-strong);
    transform: translateY(-3px);
  }
  
  /* Card pulsante */
  .dark .glow-card-pulse {
    @apply border-primary/30 bg-card/95;
    animation: pulse 3s infinite ease-in-out;
  }
  
  @keyframes pulse {
    0% {
      box-shadow: var(--glow-subtle);
    }
    50% {
      box-shadow: var(--glow-primary);
    }
    100% {
      box-shadow: var(--glow-subtle);
    }
  }
  
  /* Focus styles */
  .focus-ring {
    @apply focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary/20 focus-visible:ring-offset-2 focus-visible:ring-offset-background;
  }
}

/* React Big Calendar Dark Mode Improvements */
.dark .rbc-calendar {
  background-color: hsl(var(--card));
  color: hsl(var(--card-foreground));
}

.dark .rbc-header {
  background-color: hsl(var(--muted));
  color: hsl(var(--foreground));
  border-bottom: 1px solid hsl(var(--border));
  font-weight: 600;
}

.dark .rbc-month-view {
  background-color: hsl(var(--card));
  border: 1px solid hsl(var(--border));
}

.dark .rbc-day-bg {
  background-color: hsl(var(--card));
  border: 1px solid hsl(var(--border));
}

.dark .rbc-day-bg.rbc-off-range-bg {
  background-color: hsl(var(--muted));
  opacity: 0.5;
}

.dark .rbc-today {
  background-color: hsl(var(--primary) / 0.1);
  border: 1px solid hsl(var(--primary) / 0.3);
}

.dark .rbc-event {
  background-color: hsl(var(--primary));
  color: hsl(var(--primary-foreground));
  border: none;
  border-radius: 4px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
}

.dark .rbc-selected {
  background-color: hsl(var(--primary) / 0.8);
}

.dark .rbc-date-cell {
  color: hsl(var(--foreground));
  padding: 8px;
}

.dark .rbc-date-cell > a {
  color: hsl(var(--foreground));
  text-decoration: none;
}

.dark .rbc-date-cell.rbc-off-range {
  color: hsl(var(--muted-foreground));
}

.dark .rbc-toolbar {
  background-color: hsl(var(--card));
  border-bottom: 1px solid hsl(var(--border));
  padding: 16px;
}

.dark .rbc-toolbar button {
  background-color: hsl(var(--muted));
  color: hsl(var(--foreground));
  border: 1px solid hsl(var(--border));
  padding: 8px 16px;
  border-radius: 6px;
  transition: all 0.2s ease;
}

.dark .rbc-toolbar button:hover {
  background-color: hsl(var(--primary));
  color: hsl(var(--primary-foreground));
  border-color: hsl(var(--primary));
}

.dark .rbc-toolbar button.rbc-active {
  background-color: hsl(var(--primary));
  color: hsl(var(--primary-foreground));
  border-color: hsl(var(--primary));
}

.dark .rbc-toolbar-label {
  color: hsl(var(--foreground));
  font-weight: 600;
  font-size: 1.125rem;
}

/* Calendar legend improvements */
.dark .calendar-legend {
  background-color: hsl(var(--card));
  border: 1px solid hsl(var(--border));
  border-radius: 8px;
  padding: 16px;
}

.dark .legend-item {
  color: hsl(var(--foreground));
}

/* Select component improvements in dark mode */
.dark .select-trigger {
  background-color: hsl(var(--input));
  border: 1px solid hsl(var(--border));
  color: hsl(var(--foreground));
}

.dark .select-trigger:focus {
  border-color: hsl(var(--primary));
  box-shadow: 0 0 0 2px hsl(var(--primary) / 0.2);
}

.dark .select-content {
  background-color: hsl(var(--popover));
  border: 1px solid hsl(var(--border));
  color: hsl(var(--popover-foreground));
}

.dark .select-item {
  color: hsl(var(--foreground));
}

.dark .select-item:hover {
  background-color: hsl(var(--primary) / 0.1);
  color: hsl(var(--primary));
}

/* Tab improvements */
.dark .tabs-list {
  background-color: hsl(var(--muted));
  border: 1px solid hsl(var(--border));
}

.dark .tabs-trigger {
  color: hsl(var(--muted-foreground));
}

.dark .tabs-trigger[data-state="active"] {
  background-color: hsl(var(--card));
  color: hsl(var(--foreground));
  border-bottom: 2px solid hsl(var(--primary));
}

/* Custom scrollbar */
::-webkit-scrollbar {
  @apply w-2 h-2;
}

::-webkit-scrollbar-track {
  @apply bg-slate-100 dark:bg-slate-900;
}

::-webkit-scrollbar-thumb {
  @apply bg-primary/70 rounded-sm;
}

::-webkit-scrollbar-thumb:hover {
  @apply bg-primary/90;
}

.dark ::-webkit-scrollbar-thumb {
  box-shadow: var(--glow-xs);
}

.font-heading {
  font-family: 'Montserrat', sans-serif;
}

.font-sans {
  font-family: 'Roboto', sans-serif;
}

/* Estilos do tipo ShadCN UI aprimorados */
.hover-card-item {
  @apply transition-all duration-200 ease-in-out hover:bg-slate-50 dark:hover:bg-slate-800/50 p-3 rounded-md cursor-pointer dark:hover:shadow-primary/10;
}

.input-shadow {
  @apply shadow-sm hover:shadow transition-shadow duration-200 ease-in-out focus:shadow-md dark:focus:shadow-primary/20;
}

.card-hover {
  @apply transition-all duration-200 hover:shadow-md dark:hover:shadow-primary/10 hover:-translate-y-1;
}

/* Rótulos e ações com estilo Pink */
.tag-pink {
  @apply bg-primary/10 text-primary dark:bg-primary/20 dark:text-pink-300 text-xs px-2 py-0.5 rounded-full font-medium transition-all duration-200 hover:bg-primary/20 dark:hover:bg-primary/30;
}

.dark .tag-pink:hover {
  box-shadow: var(--glow-xs);
}

.btn-primary-glow {
  @apply bg-primary text-white hover:bg-primary/90 rounded-md px-4 py-2 transition-all duration-200;
}

.dark .btn-primary-glow {
  box-shadow: 0 0 10px hsla(var(--primary), 0.3);
}

.dark .btn-primary-glow:hover {
  box-shadow: 0 0 15px hsla(var(--primary), 0.5);
  transform: translateY(-2px);
}

/* Utilidades para efeitos de sombra e glow - funcionam em ambos os temas */
.shadow-glow-sm {
  box-shadow: 0 0 15px hsla(340, 86%, 51%, 0.5);
}

.shadow-glow-xs {
  box-shadow: 0 0 8px hsla(340, 86%, 51%, 0.4);
}

.shadow-glow-md {
  box-shadow: 0 0 20px hsla(340, 86%, 51%, 0.6);
}

/* Efeitos de hover para elementos interativos */
.hover-scale {
  @apply transition-transform duration-200 hover:scale-[1.02];
}

.hover-lift {
  @apply transition-all duration-200 hover:-translate-y-0.5 hover:shadow-md dark:hover:shadow-primary/20;
}

.hover-lift-sm {
  @apply transition-all duration-200 hover:-translate-y-0.5 hover:shadow-sm dark:hover:shadow-primary/10;
}

/* Efeitos para cards */
.card-lift {
  @apply transition-all duration-300 hover:-translate-y-1 hover:shadow-lg dark:hover:shadow-primary/20;
}

.dark .glow-card {
  box-shadow: 0 0 8px hsla(var(--primary), 0.15);
  @apply border-primary/30;
}

.dark .glow-card:hover {
  box-shadow: 0 0 15px hsla(var(--primary), 0.25);
  @apply border-primary/40;
  transform: translateY(-2px);
}

/* Animações */
.slide-in {
  animation: slideIn 0.3s ease forwards;
}

@keyframes slideIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Efeitos específicos para gráficos */
.drop-shadow-glow {
  filter: drop-shadow(0 0 3px rgba(233, 30, 99, 0.5));
}

.drop-shadow-glow-secondary {
  filter: drop-shadow(0 0 3px rgba(103, 58, 183, 0.5));
}

/* Classes responsivas personalizadas */
.mobile-chart-container {
  @apply w-full overflow-auto pb-2;
}

.mobile-chart-content {
  @apply min-w-[320px] xs:min-w-[400px] sm:min-w-full h-full;
}

.mobile-text-xs {
  @apply text-[10px] xs:text-xs sm:text-sm;
}

.mobile-padding {
  @apply p-2 xs:p-3 sm:p-4 md:p-6;
}

.mobile-margin {
  @apply m-2 xs:m-3 sm:m-4 md:m-6;
}

.dark .glow-border, .dark .glow-card, .dark .glow-card-intense {
  box-shadow: 0 0 0 2px hsla(var(--primary), 0.10), 0 2px 8px 0 rgba(25,28,34,0.10);
  border-color: hsl(var(--primary) / 0.25);
}

.dark .glow-border-subtle {
  box-shadow: 0 0 0 1.5px hsla(var(--primary), 0.07);
  border-color: hsl(var(--primary) / 0.15);
}

/* Estilos customizados para markdown no FavaleIA */
.favale-ia-markdown {
  line-height: 1.6;
}

.favale-ia-markdown h1,
.favale-ia-markdown h2,
.favale-ia-markdown h3 {
  margin-top: 1.5em;
  margin-bottom: 0.5em;
  font-weight: 600;
}

.favale-ia-markdown h1:first-child,
.favale-ia-markdown h2:first-child,
.favale-ia-markdown h3:first-child {
  margin-top: 0;
}

.favale-ia-markdown ul,
.favale-ia-markdown ol {
  padding-left: 1.5em;
  margin-bottom: 1em;
}

.favale-ia-markdown li {
  margin-bottom: 0.25em;
}

.favale-ia-markdown strong {
  font-weight: 600;
  color: hsl(var(--foreground));
}

.favale-ia-markdown code {
  background-color: hsl(var(--muted));
  padding: 0.125rem 0.25rem;
  border-radius: 0.25rem;
  font-size: 0.875em;
  font-family: ui-monospace, SFMono-Regular, "SF Mono", Consolas, "Liberation Mono", Menlo, monospace;
}

.favale-ia-markdown pre {
  background-color: hsl(var(--muted));
  padding: 1rem;
  border-radius: 0.5rem;
  overflow-x: auto;
  margin: 1em 0;
  border: 1px solid hsl(var(--border));
}

.favale-ia-markdown pre code {
  background-color: transparent;
  padding: 0;
  border-radius: 0;
}

.favale-ia-markdown blockquote {
  border-left: 4px solid hsl(var(--primary));
  padding-left: 1rem;
  margin: 1em 0;
  background-color: hsl(var(--muted) / 0.5);
  border-radius: 0 0.25rem 0.25rem 0;
  padding-top: 0.5rem;
  padding-bottom: 0.5rem;
}

/* Animação suave para o scroll - TEMPORARIAMENTE DESABILITADO */
.smooth-scroll {
  scroll-behavior: smooth;
}

/* Fix para prevenir scroll indesejado na página FavaleIA */
.favale-ia-container {
  height: 100%;
  max-height: 100%;
  overflow: hidden;
}
</file>

<file path="client/src/lib/queryClient.ts">
import { QueryClient, QueryFunction } from "@tanstack/react-query";

async function throwIfResNotOk(res: Response) {
  if (!res.ok) {
    const text = (await res.text()) || res.statusText;
    throw new Error(`${res.status}: ${text}`);
  }
}

export async function apiRequest<T = any>(
  method: string,
  url: string,
  data?: unknown | undefined,
): Promise<T> {
  const res = await fetch(url, {
    method,
    headers: data ? { "Content-Type": "application/json" } : {},
    body: data ? JSON.stringify(data) : undefined,
    credentials: "include",
  });

  await throwIfResNotOk(res);
  // Para métodos ou rotas específicas que não retornam JSON
  if (method === 'HEAD' || res.status === 204 || url === '/api/logout') {
    return {} as T;
  }
  
  try {
    return await res.json();
  } catch (error) {
    console.warn('Resposta não é um JSON válido:', error);
    return {} as T;
  }
}

type UnauthorizedBehavior = "returnNull" | "throw";
export const getQueryFn: <T>(options: {
  on401: UnauthorizedBehavior;
}) => QueryFunction<T> =
  ({ on401: unauthorizedBehavior }) =>
  async ({ queryKey }) => {
    const res = await fetch(queryKey[0] as string, {
      credentials: "include",
    });

    if (unauthorizedBehavior === "returnNull" && res.status === 401) {
      return null;
    }

    await throwIfResNotOk(res);
    return await res.json();
  };

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      queryFn: getQueryFn({ on401: "throw" }),
      refetchInterval: false,
      refetchOnWindowFocus: false,
      staleTime: Infinity,
      retry: false,
    },
    mutations: {
      retry: false,
    },
  },
});
</file>

<file path="client/src/lib/utils.ts">
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
</file>

<file path="client/src/main.tsx">
import { createRoot } from "react-dom/client";
import App from "./App";
import "./index.css";
import { QueryClientProvider } from "@tanstack/react-query";
import { queryClient } from "./lib/queryClient";

createRoot(document.getElementById("root")!).render(
  <QueryClientProvider client={queryClient}>
    <App />
  </QueryClientProvider>
);
</file>

<file path="client/src/pages/AuthPage.tsx">
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { useAuth } from "@/hooks/use-auth";
import { Redirect } from "wouter";
import { Button } from "@/components/ui/button";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Loader2 } from "lucide-react";
import gymPixelImage from "@/assets/gym-pixel.png";

const loginSchema = z.object({
  username: z.string().min(1, "Nome de usuário é obrigatório"),
  password: z.string().min(1, "Senha é obrigatória"),
});

type LoginFormValues = z.infer<typeof loginSchema>;

export default function AuthPage() {
  const { user, loginMutation } = useAuth();

  const form = useForm<LoginFormValues>({
    resolver: zodResolver(loginSchema),
    defaultValues: {
      username: "",
      password: "",
    },
  });

  const onSubmit = (values: LoginFormValues) => {
    loginMutation.mutate(values);
  };

  // Redirect to home if already logged in
  if (user) {
    return <Redirect to="/" />;
  }

  return (
    <div 
      className="min-h-screen flex items-center justify-center p-4"
      style={{
        backgroundImage: `url(${gymPixelImage})`,
        backgroundSize: 'cover',
        backgroundPosition: 'center',
        backgroundRepeat: 'no-repeat',
        position: 'relative'
      }}
    >
      {/* Overlay para melhorar legibilidade do formulário */}
      <div 
        className="absolute inset-0" 
        style={{ 
          backgroundColor: 'rgba(0,0,0,0.65)',
          backdropFilter: 'blur(1px)'
        }}
      ></div>
      
      <div className="w-full max-w-md z-10 relative">
        <div className="text-center mb-8 sm:mb-10">
          <h1 className="text-3xl sm:text-4xl font-bold text-white">Favale & Pink</h1>
          <p className="text-sm sm:text-base text-gray-300 mt-2">
            Sistema de Gerenciamento de Leads
          </p>
        </div>

        <div className="bg-white/90 dark:bg-gray-900/90 p-6 sm:p-8 rounded-xl shadow-lg backdrop-blur-sm">
          <div className="flex flex-col items-center mb-6">
            <div className="w-16 h-16 bg-primary/20 rounded-full flex items-center justify-center mb-4">
              <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="none" viewBox="0 0 24 24" stroke="currentColor" className="text-primary">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
              </svg>
            </div>
            <h2 className="text-2xl sm:text-3xl font-bold text-center">Login</h2>
            <p className="text-gray-700 dark:text-gray-300 text-sm mt-1">
              Acesse o FavaleTrainer
            </p>
          </div>
          
          <Form {...form}>
            <form
              onSubmit={form.handleSubmit(onSubmit)}
              className="space-y-5"
            >
              <FormField
                control={form.control}
                name="username"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel className="text-gray-700 dark:text-gray-300">Nome de Usuário</FormLabel>
                    <FormControl>
                      <Input 
                        placeholder="Digite seu usuário" 
                        className="py-6" 
                        {...field} 
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="password"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel className="text-gray-700 dark:text-gray-300">Senha</FormLabel>
                    <FormControl>
                      <Input
                        type="password"
                        placeholder="Digite sua senha"
                        className="py-6"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <Button
                type="submit"
                className="w-full py-6 text-lg mt-8"
                disabled={loginMutation.isPending}
              >
                {loginMutation.isPending ? (
                  <>
                    <Loader2 className="mr-2 h-5 w-5 animate-spin" /> Entrando...
                  </>
                ) : (
                  "Entrar"
                )}
              </Button>
            </form>
          </Form>

          <div className="mt-8 pt-6 border-t border-gray-100 dark:border-gray-800">
            <p className="text-sm text-center text-gray-500 dark:text-gray-400">
              Entre em contato com o administrador do sistema para solicitar acesso.
            </p>
            <p className="text-xs text-center mt-4">
              <a
                href="/politica-de-privacidade"
                target="_blank"
                rel="noopener noreferrer"
                className="text-blue-600 hover:underline dark:text-blue-400"
              >
                Política de Privacidade
              </a>
            </p>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="client/src/pages/CalendarPage.tsx">
import { useState, useCallback, useMemo } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { Calendar, momentLocalizer, Event, View } from "react-big-calendar";
import moment from "moment";
import "react-big-calendar/lib/css/react-big-calendar.css";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Plus, Filter, RefreshCw, Calendar as CalendarIcon, List } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { useToast } from "@/hooks/use-toast";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import MultiDateAppointmentDialog from "@/components/scheduling/MultiDateAppointmentDialog";
import AppointmentDetailsDialog from "@/components/scheduling/AppointmentDetailsDialog";
import { RecurringAppointmentDialog } from "@/components/scheduling/RecurringAppointmentDialog";
import AppointmentsManagement from "@/components/scheduling/AppointmentsManagement";
import type { IAula, IProfessor } from "@/types";

// Setup moment localizer for react-big-calendar
const localizer = momentLocalizer(moment);

// Configure moment to Portuguese
moment.locale('pt-br', {
  months: 'Janeiro_Fevereiro_Março_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
  monthsShort: 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
  weekdays: 'Domingo_Segunda_Terça_Quarta_Quinta_Sexta_Sábado'.split('_'),
  weekdaysShort: 'Dom_Seg_Ter_Qua_Qui_Sex_Sáb'.split('_'),
  weekdaysMin: 'Do_Se_Te_Qu_Qu_Se_Sá'.split('_'),
});

export default function CalendarPage() {
  const [currentDate, setCurrentDate] = useState(new Date());
  const [currentView, setCurrentView] = useState<View>("month");
  const [selectedEvent, setSelectedEvent] = useState<IAula | null>(null);
  const [isAppointmentDialogOpen, setIsAppointmentDialogOpen] = useState(false);
  const [isDetailsDialogOpen, setIsDetailsDialogOpen] = useState(false);
  const [isRecurringDialogOpen, setIsRecurringDialogOpen] = useState(false);
  const [filterProfessor, setFilterProfessor] = useState<string>("all");
  const [filterStatus, setFilterStatus] = useState<string>("all");

  const { toast } = useToast();
  const queryClient = useQueryClient();

  // Calculate date range for queries
  const dateRange = useMemo(() => {
    let startOfPeriod: moment.Moment;
    let endOfPeriod: moment.Moment;

    switch (currentView) {
      case "day":
        startOfPeriod = moment(currentDate).startOf("day");
        endOfPeriod = moment(currentDate).endOf("day");
        break;
      case "week":
        startOfPeriod = moment(currentDate).startOf("week");
        endOfPeriod = moment(currentDate).endOf("week");
        break;
      case "month":
        startOfPeriod = moment(currentDate).startOf("month").startOf("week");
        endOfPeriod = moment(currentDate).endOf("month").endOf("week");
        break;
      default:
        startOfPeriod = moment(currentDate).startOf("month");
        endOfPeriod = moment(currentDate).endOf("month");
    }

    // Add buffer to ensure we capture all events
    const start = startOfPeriod.subtract(1, 'week').toDate();
    const end = endOfPeriod.add(1, 'week').toDate();
    return { start, end };
  }, [currentDate, currentView]);

  // Fetch appointments/classes
  const { data: appointments = [], isLoading: isLoadingAppointments, error: appointmentsError, refetch } = useQuery({
    queryKey: ["/api/appointments", dateRange],
    queryFn: async () => {
      const response = await fetch("/api/appointments");
      if (!response.ok) {
        throw new Error('Failed to fetch appointments');
      }
      return response.json();
    },
  });

  // Fetch professors for filter
  const { data: professors = [] } = useQuery({
    queryKey: ["/api/users/professors"],
    select: (data) => data as IProfessor[]
  });

  // Transform appointments for react-big-calendar
  const events: Event[] = useMemo(() => {
    let filteredAppointments = appointments;

    // Apply professor filter
    if (filterProfessor !== "all") {
      filteredAppointments = filteredAppointments.filter(
        (appointment: IAula) => appointment.professorId === parseInt(filterProfessor)
      );
    }

    // Apply status filter
    if (filterStatus !== "all") {
      filteredAppointments = filteredAppointments.filter(
        (appointment: IAula) => appointment.status === filterStatus
      );
    }

    return filteredAppointments.map((appointment: IAula) => ({
      id: appointment.id,
      title: appointment.title || appointment.service || "Aula",
      start: new Date(appointment.startTime),
      end: new Date(appointment.endTime),
      resource: appointment,
    }));
  }, [appointments, filterProfessor, filterStatus]);

  // Event style getter for color coding
  const eventStyleGetter = useCallback((event: Event) => {
    const appointment = event.resource as IAula;
    let backgroundColor = '#3174ad'; // default blue

    switch (appointment.status) {
      case 'agendado':
        backgroundColor = '#3b82f6'; // blue
        break;
      case 'em_andamento':
        backgroundColor = '#f59e0b'; // amber
        break;
      case 'concluido':
        backgroundColor = '#10b981'; // green
        break;
      case 'cancelado':
        backgroundColor = '#ef4444'; // red
        break;
      case 'remarcado':
        backgroundColor = '#8b5cf6'; // purple
        break;
    }

    return {
      style: {
        backgroundColor,
        borderRadius: '4px',
        opacity: 0.8,
        color: 'white',
        border: '0px',
        display: 'block',
        fontSize: '0.875rem',
        padding: '2px 4px',
      }
    };
  }, []);

  // Handle event selection for details view
  const handleSelectEvent = useCallback((event: Event) => {
    setSelectedEvent(event.resource as IAula);
    setIsDetailsDialogOpen(true);
  }, []);

  // Handle date navigation
  const handleNavigate = useCallback((newDate: Date) => {
    setCurrentDate(newDate);
  }, []);

  // Handle view change
  const handleViewChange = useCallback((view: View) => {
    setCurrentView(view);
  }, []);

  // Handle appointment dialog close (for creation)
  const handleAppointmentDialogClose = useCallback(() => {
    setIsAppointmentDialogOpen(false);
    setSelectedEvent(null);
    // Refetch appointments to update the calendar
    refetch();
  }, [refetch]);

  // Handle details dialog close (for viewing)
  const handleDetailsDialogClose = useCallback(() => {
    setIsDetailsDialogOpen(false);
    setSelectedEvent(null);
    // Refetch appointments to update the calendar
    refetch();
  }, [refetch]);

  // Handle edit from details dialog
  const handleEditAppointment = useCallback((appointment: IAula) => {
    setSelectedEvent(appointment);
    setIsDetailsDialogOpen(false);
    setIsAppointmentDialogOpen(true);
  }, []);

  // Handle recurring dialog close
  const handleRecurringDialogClose = useCallback(() => {
    setIsRecurringDialogOpen(false);
    // Refetch appointments to update the calendar
    refetch();
  }, [refetch]);

  // Handle refresh
  const handleRefresh = useCallback(() => {
    refetch();
    toast({
      title: "Calendário atualizado",
      description: "Os agendamentos foram atualizados com sucesso.",
    });
  }, [refetch, toast]);

  // Custom messages for Portuguese
  const messages = {
    allDay: 'Dia inteiro',
    previous: 'Anterior',
    next: 'Próximo',
    today: 'Hoje',
    month: 'Mês',
    week: 'Semana',
    day: 'Dia',
    agenda: 'Agenda',
    date: 'Data',
    time: 'Horário',
    event: 'Evento',
    noEventsInRange: 'Não há eventos neste período.',
    showMore: (total: number) => `+ ${total} mais`,
  };



  const getEventColor = (source: 'Favale' | 'Pink' | 'FavalePink') => {
    switch (source) {
      case 'Favale':
        return '#2563eb'; // Blue
      case 'Pink':
        return '#db2777'; // Pink
      case 'FavalePink':
        return '#7e22ce'; // Purple
      default:
        return '#6b7280'; // Gray
    }
  };

  const handleSelectSlot = useCallback(
    (slotInfo: any) => {
      console.log('selected slot', slotInfo);
    },
    []
  );


  if (appointmentsError) {
    console.error("Error loading appointments:", appointmentsError);
  }

  return (
    <div className="p-6 space-y-6">
      {/* Header */}
      <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
        <div>
        </div>

        <div className="flex items-center gap-2">
          <Button
            variant="outline"
            size="sm"
            onClick={handleRefresh}
            disabled={isLoadingAppointments}
          >
            <RefreshCw className="h-4 w-4 mr-2" />
            Atualizar
          </Button>

          <Button
            onClick={() => setIsAppointmentDialogOpen(true)}
            className="bg-pink-600 hover:bg-pink-700"
          >
            <Plus className="h-4 w-4 mr-2" />
            Novo Agendamento
          </Button>

          <Button
            onClick={() => setIsRecurringDialogOpen(true)}
            className="bg-purple-600 hover:bg-purple-700"
          >
            <Plus className="h-4 w-4 mr-2" />
            Agendar Serviço Recorrente
          </Button>
        </div>
      </div>

      {/* Filters */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Filter className="h-5 w-5" />
            Filtros
          </CardTitle>
        </CardHeader>
        <CardContent>
          <div className="flex flex-col sm:flex-row gap-4">
            <div className="flex-1">
              <label className="text-sm font-medium text-gray-700 mb-2 block">
                Professor
              </label>
              <Select value={filterProfessor} onValueChange={setFilterProfessor}>
                <SelectTrigger>
                  <SelectValue placeholder="Todos os professores" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="all">Todos os professores</SelectItem>
                  {professors.map((professor) => (
                    <SelectItem key={professor.id} value={professor.id.toString()}>
                      {professor.name || professor.username}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>

            <div className="flex-1">
              <label className="text-sm font-medium text-gray-700 mb-2 block">
                Status
              </label>
              <Select value={filterStatus} onValueChange={setFilterStatus}>
                <SelectTrigger>
                  <SelectValue placeholder="Todos os status" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="all">Todos os status</SelectItem>
                  <SelectItem value="agendado">Agendado</SelectItem>
                  <SelectItem value="em_andamento">Em Andamento</SelectItem>
                  <SelectItem value="concluido">Concluído</SelectItem>
                  <SelectItem value="cancelado">Cancelado</SelectItem>
                  <SelectItem value="remarcado">Remarcado</SelectItem>
                </SelectContent>
              </Select>
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Legend */}
      <Card>
        <CardContent className="pt-6">
          <div className="flex flex-wrap gap-4">
            <div className="flex items-center gap-2">
              <div className="w-4 h-4 bg-blue-500 rounded"></div>
              <span className="text-sm">Agendado</span>
            </div>
            <div className="flex items-center gap-2">
              <div className="w-4 h-4 bg-amber-500 rounded"></div>
              <span className="text-sm">Em Andamento</span>
            </div>
            <div className="flex items-center gap-2">
              <div className="w-4 h-4 bg-green-500 rounded"></div>
              <span className="text-sm">Concluído</span>
            </div>
            <div className="flex items-center gap-2">
              <div className="w-4 h-4 bg-red-500 rounded"></div>
              <span className="text-sm">Cancelado</span>
            </div>
            <div className="flex items-center gap-2">
              <div className="w-4 h-4 bg-purple-500 rounded"></div>
              <span className="text-sm">Remarcado</span>
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Calendar */}
      <Card>
        <CardContent className="p-6">
          <Tabs defaultValue="calendar" className="w-full">
            <TabsList className="grid w-full grid-cols-2">
              <TabsTrigger value="calendar" className="flex items-center gap-2">
                <CalendarIcon className="h-4 w-4" />
                Calendário
              </TabsTrigger>
              <TabsTrigger value="appointments" className="flex items-center gap-2">
                <List className="h-4 w-4" />
                Agendamentos
              </TabsTrigger>
            </TabsList>

            <TabsContent value="calendar" className="mt-6">
              {isLoadingAppointments ? (
                <div className="text-center">
                  <RefreshCw className="h-8 w-8 animate-spin mx-auto mb-4 text-pink-600" />
                  <p className="text-gray-600">Carregando agendamentos...</p>
                </div>
              ) : (
                <div className="h-[600px]">
                  <Calendar
                    localizer={localizer}
                    events={events}
                    startAccessor="start"
                    endAccessor="end"
                    style={{ height: '100%' }}
                    onSelectEvent={handleSelectEvent}
                    onNavigate={handleNavigate}
                    onView={handleViewChange}
                    view={currentView}
                    date={currentDate}
                    eventPropGetter={eventStyleGetter}
                    messages={messages}
                    formats={{
                      monthHeaderFormat: 'MMMM YYYY',
                      dayHeaderFormat: 'dddd, DD/MM/YYYY',
                      weekdayFormat: 'ddd',
                    }}
                  />
                </div>
              )}
            </TabsContent>

            <TabsContent value="appointments" className="mt-6">
              <AppointmentsManagement onRefresh={refetch} />
            </TabsContent>
          </Tabs>
        </CardContent>
      </Card>

      {/* Create/Edit Appointment Dialog */}
      <MultiDateAppointmentDialog
        isOpen={isAppointmentDialogOpen}
        onClose={handleAppointmentDialogClose}
        professors={professors}
      />

      {/* Appointment Details Dialog */}
      <AppointmentDetailsDialog
        isOpen={isDetailsDialogOpen}
        onClose={handleDetailsDialogClose}
        appointment={selectedEvent}
        onEdit={handleEditAppointment}
      />

      {/* Recurring Appointment Dialog */}
      <RecurringAppointmentDialog
        isOpen={isRecurringDialogOpen}
        onClose={handleRecurringDialogClose}
      />
    </div>
  );
}
</file>

<file path="client/src/pages/ConfigPage.tsx">
import { useState } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { useAuth } from "@/hooks/use-auth";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Switch } from "@/components/ui/switch";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Separator } from "@/components/ui/separator";
import { toast } from "@/hooks/use-toast";
import { Loader2, PlusCircle, Trash2, Shield } from "lucide-react";
import { Dialog, DialogContent, DialogDescription, DialogFooter, 
         DialogHeader, DialogTitle, DialogTrigger } from "@/components/ui/dialog";
import { useQuery } from "@tanstack/react-query";
import { apiRequest, queryClient } from "@/lib/queryClient";
import AuditLogViewer from "@/components/admin/AuditLogViewer";
// Removed Google Calendar integration

const userProfileSchema = z.object({
  username: z.string().min(3, "Nome de usuário deve ter pelo menos 3 caracteres"),
  currentPassword: z.string().min(1, "Senha atual é obrigatória"),
  newPassword: z.string().min(6, "Nova senha deve ter pelo menos 6 caracteres"),
  confirmPassword: z.string().min(1, "Confirmação de senha é obrigatória"),
}).refine((data) => data.newPassword === data.confirmPassword, {
  message: "As senhas não coincidem",
  path: ["confirmPassword"],
});

const newUserSchema = z.object({
  username: z.string().min(3, "Nome de usuário deve ter pelo menos 3 caracteres"),
  password: z.string().min(6, "Senha deve ter pelo menos 6 caracteres"),
  confirmPassword: z.string().min(1, "Confirmação de senha é obrigatória"),
  role: z.string().min(1, "Perfil é obrigatório"),
}).refine((data) => data.password === data.confirmPassword, {
  message: "As senhas não coincidem",
  path: ["confirmPassword"],
});

const notificationSettingsSchema = z.object({
  emailNotifications: z.boolean().default(true),
  smsNotifications: z.boolean().default(false),
  leadAssignmentNotification: z.boolean().default(true),
  statusChangeNotification: z.boolean().default(true),
  marketingUpdates: z.boolean().default(false),
});

const systemSettingsSchema = z.object({
  companyName: z.string().min(1, "Nome da empresa é obrigatório"),
  primaryPhone: z.string().min(1, "Telefone principal é obrigatório"),
  primaryEmail: z.string().email("E-mail inválido").min(1, "E-mail principal é obrigatório"),
  defaultLeadStatus: z.string().min(1, "Status padrão é obrigatório"),
  defaultLeadSource: z.string().min(1, "Fonte padrão é obrigatória"),
});

type UserProfileValues = z.infer<typeof userProfileSchema>;
type NotificationSettingsValues = z.infer<typeof notificationSettingsSchema>;
type SystemSettingsValues = z.infer<typeof systemSettingsSchema>;
type NewUserValues = z.infer<typeof newUserSchema>;

type User = {
  id: number;
  username: string;
  role?: string;
};

export default function ConfigPage() {
  const { user } = useAuth();
  const [activeTab, setActiveTab] = useState<string>("profile");
  const [isNewUserDialogOpen, setIsNewUserDialogOpen] = useState(false);
  const [isUpdating, setIsUpdating] = useState(false);
  
  // O ID do usuário atual para comparação
  const currentUserId = user?.id || 0;
  
  // Buscar lista de usuários
  const { data: users = [], isLoading: isLoadingUsers, refetch: refetchUsers } = useQuery<User[]>({ 
    queryKey: ["/api/users"],
    refetchOnWindowFocus: true,
    staleTime: 0, // Para garantir que os dados sejam sempre atualizados
  });
  
  const newUserForm = useForm<NewUserValues>({
    resolver: zodResolver(newUserSchema),
    defaultValues: {
      username: "",
      password: "",
      confirmPassword: "",
      role: "",
    },
  });

  const userProfileForm = useForm<UserProfileValues>({
    resolver: zodResolver(userProfileSchema),
    defaultValues: {
      username: user?.username || "",
      currentPassword: "",
      newPassword: "",
      confirmPassword: "",
    },
  });

  const notificationSettingsForm = useForm<NotificationSettingsValues>({
    resolver: zodResolver(notificationSettingsSchema),
    defaultValues: {
      emailNotifications: true,
      smsNotifications: false,
      leadAssignmentNotification: true,
      statusChangeNotification: true,
      marketingUpdates: false,
    },
  });

  const systemSettingsForm = useForm<SystemSettingsValues>({
    resolver: zodResolver(systemSettingsSchema),
    defaultValues: {
      companyName: "Favale & Pink Personal Training",
      primaryPhone: "+55 (11) 99999-9999",
      primaryEmail: "contato@favalepink.com.br",
      defaultLeadStatus: "Lead",
      defaultLeadSource: "Favale",
    },
  });

  const onProfileSubmit = (values: UserProfileValues) => {
    console.log("Profile values:", values);
    // Aqui você implementaria a lógica para atualizar o perfil
    toast({
      title: "Perfil atualizado",
      description: "Suas informações de perfil foram atualizadas com sucesso.",
    });
  };

  const onNotificationSettingsSubmit = (values: NotificationSettingsValues) => {
    console.log("Notification settings:", values);
    // Aqui você implementaria a lógica para salvar as configurações de notificação
    toast({
      title: "Notificações atualizadas",
      description: "Suas preferências de notificação foram salvas.",
    });
  };

  const onSystemSettingsSubmit = (values: SystemSettingsValues) => {
    console.log("System settings:", values);
    // Aqui você implementaria a lógica para salvar as configurações do sistema
    toast({
      title: "Configurações do sistema atualizadas",
      description: "As configurações do sistema foram atualizadas com sucesso.",
    });
  };
  
  const onCreateUserSubmit = async (values: NewUserValues) => {
    try {
      setIsUpdating(true);
      const { confirmPassword, ...userData } = values;
      
      await apiRequest("POST", "/api/users", userData);
      
      toast({
        title: "Usuário criado",
        description: `O usuário ${values.username} foi criado com sucesso.`,
      });
      
      newUserForm.reset();
      setIsNewUserDialogOpen(false);
      // Invalidar a consulta e forçar uma nova busca de dados
      await queryClient.invalidateQueries({ queryKey: ["/api/users"] });
      await refetchUsers(); // Forçar busca imediata dos dados
    } catch (error) {
      toast({
        title: "Erro ao criar usuário",
        description: error instanceof Error ? error.message : "Ocorreu um erro inesperado.",
        variant: "destructive",
      });
    } finally {
      setIsUpdating(false);
    }
  };
  
  const deleteUser = async (userId: number) => {
    if (!confirm("Tem certeza que deseja excluir este usuário?")) return;
    
    try {
      await apiRequest("DELETE", `/api/users/${userId}`);
      
      toast({
        title: "Usuário excluído",
        description: "O usuário foi excluído com sucesso.",
      });
      
      // Invalidar a consulta e forçar uma nova busca de dados
      await queryClient.invalidateQueries({ queryKey: ["/api/users"] });
      await refetchUsers(); // Forçar busca imediata dos dados
    } catch (error) {
      toast({
        title: "Erro ao excluir usuário",
        description: error instanceof Error ? error.message : "Ocorreu um erro inesperado.",
        variant: "destructive",
      });
    }
  };

  return (
    <div className="space-y-6">
      <Tabs value={activeTab} onValueChange={setActiveTab} className="space-y-4">
            <TabsList className="bg-gray-100 dark:bg-gray-800 mb-4">
              <TabsTrigger 
                value="profile" 
                className="text-sm data-[state=active]:bg-white dark:data-[state=active]:bg-gray-700"
              >
                Perfil
              </TabsTrigger>
              <TabsTrigger 
                value="notifications" 
                className="text-sm data-[state=active]:bg-white dark:data-[state=active]:bg-gray-700"
              >
                Notificações
              </TabsTrigger>
              <TabsTrigger 
                value="system" 
                className="text-sm data-[state=active]:bg-white dark:data-[state=active]:bg-gray-700"
              >
                Sistema
              </TabsTrigger>
              <TabsTrigger 
                value="users" 
                className="text-sm data-[state=active]:bg-white dark:data-[state=active]:bg-gray-700"
              >
                Usuários
              </TabsTrigger>

              {user?.role === 'admin' && (
                <TabsTrigger 
                  value="audit" 
                  className="text-sm data-[state=active]:bg-white dark:data-[state=active]:bg-gray-700"
                >
                  Auditoria
                </TabsTrigger>
              )}
            </TabsList>
            
            <TabsContent value="profile" className="space-y-4">
              <Card className="border-gray-100 dark:border-gray-700 shadow-sm rounded-xl">
                <CardHeader className="pb-3">
                  <CardTitle className="text-lg font-medium text-gray-800 dark:text-white">Alterar Senha</CardTitle>
                  <CardDescription className="text-gray-500 dark:text-gray-400">
                    Atualize sua senha para manter sua conta segura
                  </CardDescription>
                </CardHeader>
                <CardContent>
                  <Form {...userProfileForm}>
                    <form onSubmit={userProfileForm.handleSubmit(onProfileSubmit)} className="space-y-4">
                      <FormField
                        control={userProfileForm.control}
                        name="username"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel>Nome de Usuário</FormLabel>
                            <FormControl>
                              <Input {...field} />
                            </FormControl>
                            <FormDescription>Este é seu nome de usuário público.</FormDescription>
                            <FormMessage />
                          </FormItem>
                        )}
                      />

                      <Separator className="my-4" />
                      <h3 className="text-lg font-medium mb-4">Alterar Senha</h3>

                      <FormField
                        control={userProfileForm.control}
                        name="currentPassword"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel>Senha Atual</FormLabel>
                            <FormControl>
                              <Input type="password" {...field} />
                            </FormControl>
                            <FormMessage />
                          </FormItem>
                        )}
                      />

                      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <FormField
                          control={userProfileForm.control}
                          name="newPassword"
                          render={({ field }) => (
                            <FormItem>
                              <FormLabel>Nova Senha</FormLabel>
                              <FormControl>
                                <Input type="password" {...field} />
                              </FormControl>
                              <FormMessage />
                            </FormItem>
                          )}
                        />

                        <FormField
                          control={userProfileForm.control}
                          name="confirmPassword"
                          render={({ field }) => (
                            <FormItem>
                              <FormLabel>Confirmar Nova Senha</FormLabel>
                              <FormControl>
                                <Input type="password" {...field} />
                              </FormControl>
                              <FormMessage />
                            </FormItem>
                          )}
                        />
                      </div>

                      <Button type="submit" className="mt-4">
                        Salvar Alterações
                      </Button>
                    </form>
                  </Form>
                </CardContent>
              </Card>
            </TabsContent>
            
            <TabsContent value="notifications" className="space-y-4">
              <Card className="border-gray-100 dark:border-gray-700 shadow-sm rounded-xl">
                <CardHeader className="pb-3">
                  <CardTitle className="text-lg font-medium text-gray-800 dark:text-white">Preferências de Notificação</CardTitle>
                  <CardDescription className="text-gray-500 dark:text-gray-400">
                    Configure como e quando deseja receber notificações
                  </CardDescription>
                </CardHeader>
                <CardContent>
                  <Form {...notificationSettingsForm}>
                    <form
                      onSubmit={notificationSettingsForm.handleSubmit(onNotificationSettingsSubmit)}
                      className="space-y-4"
                    >
                      <div className="space-y-4">
                        <h3 className="text-lg font-medium">Canais de Notificação</h3>

                        <FormField
                          control={notificationSettingsForm.control}
                          name="emailNotifications"
                          render={({ field }) => (
                            <FormItem className="flex flex-row items-center justify-between p-3 border rounded-md">
                              <div className="space-y-0.5">
                                <FormLabel>Notificações por Email</FormLabel>
                                <FormDescription>
                                  Receba atualizações e alertas por email.
                                </FormDescription>
                              </div>
                              <FormControl>
                                <Switch
                                  checked={field.value}
                                  onCheckedChange={field.onChange}
                                />
                              </FormControl>
                            </FormItem>
                          )}
                        />

                        <FormField
                          control={notificationSettingsForm.control}
                          name="smsNotifications"
                          render={({ field }) => (
                            <FormItem className="flex flex-row items-center justify-between p-3 border rounded-md">
                              <div className="space-y-0.5">
                                <FormLabel>Notificações por SMS</FormLabel>
                                <FormDescription>
                                  Receba alertas importantes por SMS.
                                </FormDescription>
                              </div>
                              <FormControl>
                                <Switch
                                  checked={field.value}
                                  onCheckedChange={field.onChange}
                                />
                              </FormControl>
                            </FormItem>
                          )}
                        />
                      </div>

                      <Separator className="my-4" />

                      <div className="space-y-4">
                        <h3 className="text-lg font-medium">Tipos de Notificação</h3>

                        <FormField
                          control={notificationSettingsForm.control}
                          name="leadAssignmentNotification"
                          render={({ field }) => (
                            <FormItem className="flex flex-row items-center justify-between p-3 border rounded-md">
                              <div className="space-y-0.5">
                                <FormLabel>Atribuição de Leads</FormLabel>
                                <FormDescription>
                                  Notificar quando um novo lead for atribuído a você.
                                </FormDescription>
                              </div>
                              <FormControl>
                                <Switch
                                  checked={field.value}
                                  onCheckedChange={field.onChange}
                                />
                              </FormControl>
                            </FormItem>
                          )}
                        />

                        <FormField
                          control={notificationSettingsForm.control}
                          name="statusChangeNotification"
                          render={({ field }) => (
                            <FormItem className="flex flex-row items-center justify-between p-3 border rounded-md">
                              <div className="space-y-0.5">
                                <FormLabel>Mudanças de Status</FormLabel>
                                <FormDescription>
                                  Notificar quando o status de um lead mudar.
                                </FormDescription>
                              </div>
                              <FormControl>
                                <Switch
                                  checked={field.value}
                                  onCheckedChange={field.onChange}
                                />
                              </FormControl>
                            </FormItem>
                          )}
                        />

                        <FormField
                          control={notificationSettingsForm.control}
                          name="marketingUpdates"
                          render={({ field }) => (
                            <FormItem className="flex flex-row items-center justify-between p-3 border rounded-md">
                              <div className="space-y-0.5">
                                <FormLabel>Atualizações de Marketing</FormLabel>
                                <FormDescription>
                                  Receba novidades sobre campanhas e promoções.
                                </FormDescription>
                              </div>
                              <FormControl>
                                <Switch
                                  checked={field.value}
                                  onCheckedChange={field.onChange}
                                />
                              </FormControl>
                            </FormItem>
                          )}
                        />
                      </div>

                      <Button type="submit" className="mt-4">
                        Salvar Preferências
                      </Button>
                    </form>
                  </Form>
                </CardContent>
              </Card>
            </TabsContent>
            
            <TabsContent value="system" className="space-y-4">
              <Card className="border-gray-100 dark:border-gray-700 shadow-sm rounded-xl">
                <CardHeader className="pb-3">
                  <CardTitle className="text-lg font-medium text-gray-800 dark:text-white">Configurações Gerais</CardTitle>
                  <CardDescription className="text-gray-500 dark:text-gray-400">
                    Configure os parâmetros gerais do sistema
                  </CardDescription>
                </CardHeader>
                <CardContent>
                  <Form {...systemSettingsForm}>
                    <form
                      onSubmit={systemSettingsForm.handleSubmit(onSystemSettingsSubmit)}
                      className="space-y-4"
                    >
                      <div className="space-y-4">
                        <h3 className="text-lg font-medium">Informações da Empresa</h3>

                        <FormField
                          control={systemSettingsForm.control}
                          name="companyName"
                          render={({ field }) => (
                            <FormItem>
                              <FormLabel>Nome da Empresa</FormLabel>
                              <FormControl>
                                <Input {...field} />
                              </FormControl>
                              <FormMessage />
                            </FormItem>
                          )}
                        />

                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                          <FormField
                            control={systemSettingsForm.control}
                            name="primaryPhone"
                            render={({ field }) => (
                              <FormItem>
                                <FormLabel>Telefone Principal</FormLabel>
                                <FormControl>
                                  <Input {...field} />
                                </FormControl>
                                <FormMessage />
                              </FormItem>
                            )}
                          />

                          <FormField
                            control={systemSettingsForm.control}
                            name="primaryEmail"
                            render={({ field }) => (
                              <FormItem>
                                <FormLabel>Email Principal</FormLabel>
                                <FormControl>
                                  <Input {...field} />
                                </FormControl>
                                <FormMessage />
                              </FormItem>
                            )}
                          />
                        </div>
                      </div>

                      <Separator className="my-4" />

                      <div className="space-y-4">
                        <h3 className="text-lg font-medium">Configurações Padrão de Leads</h3>

                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                          <FormField
                            control={systemSettingsForm.control}
                            name="defaultLeadStatus"
                            render={({ field }) => (
                              <FormItem>
                                <FormLabel>Status Padrão de Lead</FormLabel>
                                <FormControl>
                                  <Input {...field} />
                                </FormControl>
                                <FormDescription>
                                  Status atribuído a novos leads.
                                </FormDescription>
                                <FormMessage />
                              </FormItem>
                            )}
                          />

                          <FormField
                            control={systemSettingsForm.control}
                            name="defaultLeadSource"
                            render={({ field }) => (
                              <FormItem>
                                <FormLabel>Fonte Padrão de Lead</FormLabel>
                                <FormControl>
                                  <Input {...field} />
                                </FormControl>
                                <FormDescription>
                                  Fonte atribuída a novos leads.
                                </FormDescription>
                                <FormMessage />
                              </FormItem>
                            )}
                          />
                        </div>
                      </div>

                      <Button type="submit" className="mt-4">
                        Salvar Configurações
                      </Button>
                    </form>
                  </Form>
                </CardContent>
              </Card>
            </TabsContent>

            
            <TabsContent value="users" className="space-y-4">
              <div className="flex justify-between items-center mb-4">
                <h3 className="text-lg font-medium text-gray-800 dark:text-white">Gerenciamento de Usuários</h3>
                <Dialog open={isNewUserDialogOpen} onOpenChange={setIsNewUserDialogOpen}>
                  <DialogTrigger asChild>
                    <Button className="bg-[#ff9810] hover:bg-[#ff9810]/90 text-white">
                      <PlusCircle className="h-4 w-4 mr-2" />
                      Novo Usuário
                    </Button>
                  </DialogTrigger>
                  <DialogContent className="sm:max-w-[480px] bg-white dark:bg-gray-800 border-gray-100 dark:border-gray-700 rounded-xl">
                    <DialogHeader>
                      <DialogTitle className="text-gray-800 dark:text-white">Criar Novo Usuário</DialogTitle>
                      <DialogDescription className="text-gray-500 dark:text-gray-400">
                        Crie um novo usuário para acessar o sistema
                      </DialogDescription>
                    </DialogHeader>
                    
                    <Form {...newUserForm}>
                      <form onSubmit={newUserForm.handleSubmit(onCreateUserSubmit)} className="space-y-4">
                        <FormField
                          control={newUserForm.control}
                          name="username"
                          render={({ field }) => (
                            <FormItem>
                              <FormLabel>Nome de Usuário</FormLabel>
                              <FormControl>
                                <Input placeholder="Digite o nome de usuário" {...field} />
                              </FormControl>
                              <FormMessage />
                            </FormItem>
                          )}
                        />
                        
                        <FormField
                          control={newUserForm.control}
                          name="role"
                          render={({ field }) => (
                            <FormItem>
                              <FormLabel>Perfil</FormLabel>
                              <Select onValueChange={field.onChange} defaultValue={field.value}>
                                <FormControl>
                                  <SelectTrigger>
                                    <SelectValue placeholder="Selecione um perfil" />
                                  </SelectTrigger>
                                </FormControl>
                                <SelectContent>
                                  <SelectItem value="admin">Administrador</SelectItem>
                                  <SelectItem value="marketing">Marketing</SelectItem>
                                  <SelectItem value="comercial">Comercial</SelectItem>
                                  <SelectItem value="trainer">Personal Trainer</SelectItem>
                                </SelectContent>
                              </Select>
                              <FormMessage />
                            </FormItem>
                          )}
                        />
                        
                        <FormField
                          control={newUserForm.control}
                          name="password"
                          render={({ field }) => (
                            <FormItem>
                              <FormLabel>Senha</FormLabel>
                              <FormControl>
                                <Input type="password" placeholder="Digite a senha" {...field} />
                              </FormControl>
                              <FormMessage />
                            </FormItem>
                          )}
                        />
                        
                        <FormField
                          control={newUserForm.control}
                          name="confirmPassword"
                          render={({ field }) => (
                            <FormItem>
                              <FormLabel>Confirmar Senha</FormLabel>
                              <FormControl>
                                <Input type="password" placeholder="Confirme a senha" {...field} />
                              </FormControl>
                              <FormMessage />
                            </FormItem>
                          )}
                        />
                        
                        <DialogFooter>
                          <Button 
                            variant="outline" 
                            type="button" 
                            onClick={() => setIsNewUserDialogOpen(false)}
                          >
                            Cancelar
                          </Button>
                          <Button type="submit" disabled={isUpdating}>
                            {isUpdating ? (
                              <>
                                <Loader2 className="mr-2 h-4 w-4 animate-spin" /> Salvando...
                              </>
                            ) : (
                              "Salvar"
                            )}
                          </Button>
                        </DialogFooter>
                      </form>
                    </Form>
                  </DialogContent>
                </Dialog>
              </div>
              
              <Card className="border-gray-100 dark:border-gray-700 shadow-sm rounded-xl">
                <CardContent className="p-6">
                  {isLoadingUsers ? (
                    <div className="flex justify-center py-8">
                      <Loader2 className="h-8 w-8 animate-spin text-primary" />
                    </div>
                  ) : (
                    <div className="border rounded-md">
                      <table className="w-full">
                        <thead>
                          <tr className="border-b bg-muted/50">
                            <th className="py-3 px-4 text-left font-medium">Nome de Usuário</th>
                            <th className="py-3 px-4 text-left font-medium">Perfil</th>
                            <th className="py-3 px-4 text-right font-medium">Ações</th>
                          </tr>
                        </thead>
                        <tbody>
                          {users.length > 0 ? (
                            users.map((user) => (
                              <tr key={user.id} className="border-b hover:bg-muted/30">
                                <td className="py-3 px-4">{user.username}</td>
                                <td className="py-3 px-4">
                                  {{
                                    admin: "Administrador",
                                    marketing: "Marketing",
                                    comercial: "Comercial",
                                    trainer: "Personal Trainer"
                                  }[user.role || ""] || "Não definido"}
                                </td>
                                <td className="py-3 px-4 text-right">
                                  <Button
                                    variant="ghost"
                                    size="sm"
                                    onClick={() => deleteUser(user.id)}
                                    disabled={user.id === currentUserId} // Não permite excluir o próprio usuário
                                  >
                                    <Trash2 className="h-4 w-4 text-destructive" />
                                  </Button>
                                </td>
                              </tr>
                            ))
                          ) : (
                            <tr>
                              <td colSpan={3} className="py-6 text-center text-muted-foreground">
                                Nenhum usuário encontrado
                              </td>
                            </tr>
                          )}
                        </tbody>
                      </table>
                    </div>
                  )}
                </CardContent>
              </Card>
            </TabsContent>
            
            {user?.role === 'admin' && (
              <TabsContent value="audit" className="space-y-4">
                <Card className="border-gray-100 dark:border-gray-700 shadow-sm rounded-xl">
                  <CardHeader className="pb-3">
                    <CardTitle className="text-lg font-medium text-gray-800 dark:text-white">Log de Auditoria</CardTitle>
                    <CardDescription className="text-gray-500 dark:text-gray-400">
                      Monitoramento de atividades do sistema
                    </CardDescription>
                  </CardHeader>
                  <CardContent>
                    <AuditLogViewer />
                  </CardContent>
                </Card>
              </TabsContent>
            )}
      </Tabs>
    </div>
  );
}
</file>

<file path="client/src/pages/DashboardPage.tsx">
import Dashboard from "@/components/dashboard/Dashboard";

export default function DashboardPage() {
  return (
    <Dashboard />
  );
}
</file>

<file path="client/src/pages/FavaleIAPage.tsx">
import React, { useState, useRef, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Avatar, AvatarFallback } from '@/components/ui/avatar';
import { Send, Bot, User, Plus, MessageSquare, Trash2, MoreVertical, Coffee } from 'lucide-react';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { cn } from '@/lib/utils';
import { openAIService, type ChatMessage } from '@/services/openai';
import { MarkdownRenderer } from '@/components/ui/MarkdownRenderer';
import { useAuth } from '@/hooks/use-auth';

interface Message {
  id: string;
  content: string;
  role: 'user' | 'assistant';
  timestamp: Date;
}

interface Conversation {
  id: string;
  title: string;
  messages: Message[];
  createdAt: Date;
}

export function FavaleIAPage() {
  const { user } = useAuth();
  const [conversations, setConversations] = useState<Conversation[]>([]);
  const [currentConversation, setCurrentConversation] = useState<string | null>(null);
  const [message, setMessage] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const messagesEndRef = useRef<HTMLDivElement>(null);

  // Função para obter saudação baseada na hora do dia
  const getGreeting = () => {
    const hour = new Date().getHours();
    if (hour < 12) return 'Bom dia';
    if (hour < 18) return 'Boa tarde';
    return 'Boa noite';
  };

  // Carrega conversas do localStorage na inicialização
  useEffect(() => {
    const savedConversations = localStorage.getItem('favale-ia-conversations');
    if (savedConversations) {
      try {
        const parsed = JSON.parse(savedConversations);
        const conversationsWithDates = parsed.map((conv: any) => ({
          ...conv,
          createdAt: new Date(conv.createdAt),
          messages: conv.messages.map((msg: any) => ({
            ...msg,
            timestamp: new Date(msg.timestamp)
          }))
        }));
        setConversations(conversationsWithDates);
      } catch (error) {
        console.error('Erro ao carregar conversas:', error);
      }
    }
  }, []);

  // Salva conversas no localStorage sempre que mudam
  useEffect(() => {
    if (conversations.length > 0) {
      localStorage.setItem('favale-ia-conversations', JSON.stringify(conversations));
    }
  }, [conversations]);

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };

  // Referência para o campo de entrada na interface de chat
  const inputRef = useRef<HTMLInputElement>(null);

  // Acompanha a quantidade de mensagens da conversa atual para scroll
  const [currentConvMessagesCount, setCurrentConvMessagesCount] = useState<number>(0);
  
  // Esse useEffect apenas acompanha mudanças na contagem de mensagens da conversa atual
  useEffect(() => {
    const currentConv = getCurrentConversation();
    if (currentConv) {
      setCurrentConvMessagesCount(currentConv.messages.length);
    } else {
      setCurrentConvMessagesCount(0);
    }
  }, [conversations, currentConversation]);
  
  // Esse useEffect faz o scroll apenas quando há mudança real nas mensagens
  useEffect(() => {
    // Só faz scroll quando há mensagens na conversa atual e a quantidade mudou
    if (currentConvMessagesCount > 0) {
      scrollToBottom();
      
      // Foca o input após uma pequena pausa para permitir que as animações terminem
      setTimeout(() => {
        inputRef.current?.focus();
      }, 300);
    }
  }, [currentConvMessagesCount]);

  const createNewConversation = () => {
    const newConversation: Conversation = {
      id: Date.now().toString(),
      title: 'Nova Conversa',
      messages: [],
      createdAt: new Date()
    };
    setConversations(prev => [newConversation, ...prev]);
    setCurrentConversation(newConversation.id);
    // Limpa a mensagem se houver alguma pendente
    setMessage('');
  };

  const deleteConversation = (conversationId: string) => {
    setConversations(prev => prev.filter(conv => conv.id !== conversationId));
    if (currentConversation === conversationId) {
      setCurrentConversation(null);
    }
  };

  const clearAllConversations = () => {
    setConversations([]);
    setCurrentConversation(null);
    localStorage.removeItem('favale-ia-conversations');
  };

  const getCurrentConversation = () => {
    return conversations.find(conv => conv.id === currentConversation);
  };

  const addMessage = (content: string, role: 'user' | 'assistant') => {
    if (!currentConversation) return;

    const newMessage: Message = {
      id: Date.now().toString(),
      content,
      role,
      timestamp: new Date()
    };

    setConversations(prev => prev.map(conv => {
      if (conv.id === currentConversation) {
        const updatedMessages = [...conv.messages, newMessage];
        // Cria um título mais inteligente baseado na primeira mensagem do usuário
        let newTitle = conv.title;
        if (conv.messages.length === 0 && role === 'user') {
          // Extrai palavras-chave da primeira mensagem para criar um título mais descritivo
          const keywords = content
            .toLowerCase()
            .split(' ')
            .filter(word => word.length > 3)
            .slice(0, 3)
            .join(' ');
          newTitle = keywords.length > 0 
            ? keywords.charAt(0).toUpperCase() + keywords.slice(1)
            : content.slice(0, 30) + '...';
        }
        return {
          ...conv,
          messages: updatedMessages,
          title: newTitle
        };
      }
      return conv;
    }));
  };

  const sendMessage = async () => {
    if (!message.trim() || isLoading) return;

    const userMessage = message;
    setMessage('');
    setIsLoading(true);

    try {
      let chatMessages: ChatMessage[] = [];
      
      // Se não tiver conversa atual, cria uma nova
      if (!currentConversation) {
        const newConversation: Conversation = {
          id: Date.now().toString(),
          title: userMessage.slice(0, 30) + (userMessage.length > 30 ? '...' : ''),
          messages: [{
            id: Date.now().toString(),
            content: userMessage,
            role: 'user',
            timestamp: new Date()
          }],
          createdAt: new Date()
        };
        
        // Já cria a conversa com a mensagem do usuário incluída
        setConversations(prev => [newConversation, ...prev]);
        setCurrentConversation(newConversation.id);
        
        // Use diretamente as mensagens da nova conversa para evitar problemas de estado assíncrono
        chatMessages = [{ role: 'user', content: userMessage }];
      } else {
        // Adiciona mensagem do usuário na conversa existente
        addMessage(userMessage, 'user');
        
        // Prepara histórico de mensagens para a API
        const currentConv = getCurrentConversation();
        chatMessages = [
          ...(currentConv?.messages.map(msg => ({
            role: msg.role,
            content: msg.content
          })) || []),
          { role: 'user', content: userMessage }
        ];
      }

      // Chama a API da OpenAI
      const response = await openAIService.sendMessage(chatMessages);
      addMessage(response, 'assistant');
    } catch (error) {
      console.error('Erro ao enviar mensagem:', error);
      const errorMessage = error instanceof Error ? error.message : 'Erro desconhecido ao processar sua mensagem.';
      addMessage(errorMessage, 'assistant');
    } finally {
      setIsLoading(false);
    }
  };

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      sendMessage();
    }
  };

  // Adiciona classes para animação de transição entre estados
  const chatAreaClasses = cn(
    "flex-1 flex flex-col h-full min-w-0 bg-card border border-border",
    "transition-all duration-300 ease-in-out"
  );

  return (
    <div className="favale-ia-container w-full flex bg-background">
      {/* Sidebar com conversas - Layout fixo */}
      <div className="w-80 border-r border-border bg-card flex flex-col h-full overflow-hidden">
        {/* Header da sidebar - fixo */}
        <div className="p-4 border-b border-border flex-shrink-0 bg-card">
          <div className="flex items-center space-x-2">
            <Button
              onClick={createNewConversation}
              className="flex-1 bg-primary hover:bg-primary/90"
            >
              <Plus className="w-4 h-4 mr-2" />
              Nova Conversa
            </Button>
            
            {conversations.length > 0 && (
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button variant="ghost" size="sm" className="h-10 w-10 p-0">
                    <MoreVertical className="h-4 w-4" />
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent align="end" className="w-48">
                  <DropdownMenuItem
                    onClick={clearAllConversations}
                    className="text-red-600 focus:text-red-600"
                  >
                    <Trash2 className="w-4 h-4 mr-2" />
                    Limpar todas as conversas
                  </DropdownMenuItem>
                </DropdownMenuContent>
              </DropdownMenu>
            )}
          </div>
        </div>
        
        {/* Lista de conversas - scroll interno */}
        <div className="flex-1 overflow-y-auto">
          <div className="p-2">
            {conversations.map((conversation) => (
              <Card
                key={conversation.id}
                className={cn(
                  "mb-2 cursor-pointer transition-colors hover:bg-accent group",
                  currentConversation === conversation.id && "bg-accent border-primary"
                )}
              >
                <CardContent className="p-3">
                  <div className="flex items-center space-x-2">
                    <MessageSquare className="w-4 h-4 text-muted-foreground flex-shrink-0" />
                    <div 
                      className="flex-1 min-w-0" 
                      onClick={() => setCurrentConversation(conversation.id)}
                    >
                      <p className="text-sm truncate text-[#ffffff] font-normal">
                        {conversation.title}
                      </p>
                      <p className="text-xs text-[#ffffff] font-medium">
                        {conversation.messages.length} mensagens
                      </p>
                    </div>
                    
                    <DropdownMenu>
                      <DropdownMenuTrigger asChild>
                        <Button
                          variant="ghost"
                          size="sm"
                          className="h-6 w-6 p-0 opacity-0 group-hover:opacity-100 hover:bg-accent/50"
                          onClick={(e) => e.stopPropagation()}
                        >
                          <MoreVertical className="h-3 w-3" />
                        </Button>
                      </DropdownMenuTrigger>
                      <DropdownMenuContent align="end" className="w-48">
                        <DropdownMenuItem
                          onClick={(e) => {
                            e.stopPropagation();
                            deleteConversation(conversation.id);
                          }}
                          className="text-red-600 focus:text-red-600"
                        >
                          <Trash2 className="w-4 h-4 mr-2" />
                          Excluir conversa
                        </DropdownMenuItem>
                      </DropdownMenuContent>
                    </DropdownMenu>
                  </div>
                </CardContent>
              </Card>
            ))}
          </div>
        </div>
      </div>
      {/* Área principal do chat - Layout fixo */}
      <div className={chatAreaClasses}>
        {currentConversation ? (
          <>
            {/* Header do chat - Layout fixo */}
            <div className="p-4 border-b border-border bg-card flex-shrink-0">
              <div className="flex items-center justify-between">
                <div className="flex items-center space-x-3">
                  <Avatar className="w-8 h-8 flex-shrink-0">
                    <AvatarFallback className="bg-primary text-primary-foreground">
                      <Bot className="w-4 h-4" />
                    </AvatarFallback>
                  </Avatar>
                  <div className="min-w-0">
                    <h1 className="text-lg font-semibold truncate">FavaleIA</h1>
                    <p className="text-sm text-muted-foreground truncate">
                      Assistente de IA para seu CRM
                    </p>
                  </div>
                </div>
                <div className="flex items-center space-x-2">
                  <Coffee className="w-4 h-4 text-muted-foreground" />
                  <span className="text-sm font-medium text-muted-foreground">
                    {getGreeting()}, {user?.username || 'Visitante'}
                  </span>
                </div>
              </div>
            </div>

            {/* Mensagens - Área com scroll interno */}
            <div className="flex-1 overflow-y-auto min-h-0">
              <div className="p-4 h-full">
                <div className="space-y-6 max-w-4xl mx-auto pb-4">
                  {getCurrentConversation()?.messages.map((msg) => (
                    <div
                      key={msg.id}
                      className={cn(
                        "flex space-x-3",
                        msg.role === 'user' ? "flex-row-reverse space-x-reverse" : ""
                      )}
                    >
                      <Avatar className="w-8 h-8 flex-shrink-0 mt-1">
                        <AvatarFallback className={cn(
                          msg.role === 'assistant' 
                            ? "bg-primary text-primary-foreground" 
                            : "bg-secondary"
                        )}>
                          {msg.role === 'assistant' ? (
                            <Bot className="w-4 h-4" />
                          ) : (
                            <User className="w-4 h-4" />
                          )}
                        </AvatarFallback>
                      </Avatar>
                      
                      <div className={cn(
                        "max-w-[85%] rounded-lg p-4 text-sm min-w-0", // min-w-0 para quebra de linha
                        msg.role === 'assistant'
                          ? "bg-card border border-border"
                          : "bg-primary text-primary-foreground"
                      )}>
                        {msg.role === 'assistant' ? (
                          <MarkdownRenderer 
                            content={msg.content}
                            className={cn(
                              "prose-sm",
                              "prose-headings:text-foreground",
                              "prose-p:text-foreground",
                              "prose-strong:text-foreground",
                              "prose-code:text-foreground",
                              "prose-pre:bg-muted/50"
                            )}
                          />
                        ) : (
                          <p className="whitespace-pre-wrap break-words">{msg.content}</p>
                        )}
                        <p className={cn(
                          "text-xs mt-2 opacity-70",
                          msg.role === 'assistant' ? "text-muted-foreground" : "text-primary-foreground/70"
                        )}>
                          {msg.timestamp.toLocaleTimeString()}
                        </p>
                      </div>
                    </div>
                  ))}
                  
                  {isLoading && (
                    <div className="flex space-x-3">
                      <Avatar className="w-8 h-8 flex-shrink-0 mt-1">
                        <AvatarFallback className="bg-primary text-primary-foreground">
                          <Bot className="w-4 h-4" />
                        </AvatarFallback>
                      </Avatar>
                      <div className="bg-card border border-border rounded-lg p-4 text-sm">
                        <div className="flex space-x-1">
                          <div className="w-2 h-2 bg-primary rounded-full animate-bounce"></div>
                          <div className="w-2 h-2 bg-primary rounded-full animate-bounce" style={{ animationDelay: '0.1s' }}></div>
                          <div className="w-2 h-2 bg-primary rounded-full animate-bounce" style={{ animationDelay: '0.2s' }}></div>
                        </div>
                      </div>
                    </div>
                  )}
                  
                  <div ref={messagesEndRef} />
                </div>
              </div>
            </div>

            {/* Input de mensagem - Layout fixo */}
            <div className="p-4 border-t border-border bg-card flex-shrink-0">
              <div className="max-w-4xl mx-auto flex space-x-3">
                <Input
                  ref={inputRef}
                  value={message}
                  onChange={(e) => setMessage(e.target.value)}
                  onKeyPress={handleKeyPress}
                  placeholder="Digite sua mensagem..."
                  className="flex-1 min-w-0"
                  disabled={isLoading}
                />
                <Button
                  onClick={sendMessage}
                  disabled={!message.trim() || isLoading}
                  className="bg-primary hover:bg-primary/90 flex-shrink-0"
                >
                  <Send className="w-4 h-4" />
                </Button>
              </div>
            </div>
          </>
        ) : (
          // Estado inicial - nenhuma conversa selecionada, agora parecido com o Claude
          (<div className="flex-1 flex flex-col bg-background h-full">
            <div className="flex-1 flex flex-col items-center justify-center p-8">
              <div className="flex items-center justify-center space-x-2 mb-8">
                <div className="flex items-center space-x-2">
                  <Coffee className="w-5 h-5 text-primary" />
                  <h1 className="text-xl text-primary font-medium">{getGreeting()}, {user?.username || 'Visitante'}</h1>
                </div>
              </div>
              
              <div className="w-full max-w-3xl mx-auto">
                <div className="border border-border rounded-lg shadow-sm bg-card transition-all duration-300 ease-in-out">
                  <div className="flex items-center p-4">
                    <Input
                      ref={inputRef}
                      autoFocus
                      value={message}
                      onChange={(e) => setMessage(e.target.value)}
                      onKeyPress={handleKeyPress}
                      placeholder="Como posso ajudar você hoje?"
                      className="flex-1 bg-transparent focus-visible:ring-0 focus-visible:ring-offset-0 border-0 focus-visible:border-0"
                    />
                    <Button
                      onClick={sendMessage}
                      disabled={!message.trim() || isLoading}
                      className="bg-primary hover:bg-primary/90 ml-2"
                    >
                      <Send className="w-4 h-4" />
                    </Button>
                  </div>
                </div>
              </div>
            </div>
          </div>)
        )}
      </div>
    </div>
  );
}
</file>

<file path="client/src/pages/LeadsPage.tsx">
import LeadManagement from "@/components/leads/LeadManagement";
import { LeadProvider } from "@/context/LeadContext";

export default function LeadsPage() {
  return (
    <LeadProvider>
      <LeadManagement />
    </LeadProvider>
  );
}
</file>

<file path="client/src/pages/not-found.tsx">
import { Card, CardContent } from "@/components/ui/card";
import { AlertCircle } from "lucide-react";

export default function NotFound() {
  return (
    <div className="min-h-screen w-full flex items-center justify-center bg-gray-50">
      <Card className="w-full max-w-md mx-4">
        <CardContent className="pt-6">
          <div className="flex mb-4 gap-2">
            <AlertCircle className="h-8 w-8 text-red-500" />
            <h1 className="text-2xl font-bold text-gray-900">404 Page Not Found</h1>
          </div>

          <p className="mt-4 text-sm text-gray-600">
            Did you forget to add the page to the router?
          </p>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="client/src/pages/PrivacyPolicyPage.tsx">
import React from 'react';

const PrivacyPolicyPage: React.FC = () => (
  <div className="max-w-2xl mx-auto p-6 text-justify">
    <h1 className="text-2xl font-bold mb-4">Política de Privacidade</h1>
    <p className="mb-2 text-sm text-gray-500">Última atualização: 07/06/2024</p>
    <p className="mb-4">Esta Política de Privacidade descreve como coletamos, usamos, armazenamos e protegemos as informações pessoais dos usuários do nosso CRM.</p>
    <h2 className="text-xl font-semibold mt-6 mb-2">1. Informações que coletamos</h2>
    <ul className="list-disc ml-6 mb-4">
      <li>Nome completo</li>
      <li>Endereço de e-mail</li>
      <li>Número de telefone</li>
      <li>Empresa/Organização</li>
      <li>Informações de contato de leads e clientes</li>
      <li>Dados inseridos manualmente no sistema (ex: anotações, tarefas, agendamentos)</li>
      <li>Dados de uso do sistema (logs de acesso, interações)</li>
    </ul>
    <h2 className="text-xl font-semibold mt-6 mb-2">2. Como usamos as informações</h2>
    <ul className="list-disc ml-6 mb-4">
      <li>Gerenciar e organizar contatos, leads e clientes</li>
      <li>Facilitar o agendamento de tarefas e compromissos</li>
      <li>Melhorar a experiência do usuário no CRM</li>
      <li>Enviar comunicações relacionadas ao uso do sistema</li>
      <li>Cumprir obrigações legais e regulatórias</li>
    </ul>
    <h2 className="text-xl font-semibold mt-6 mb-2">3. Compartilhamento de informações</h2>
    <p className="mb-4">Não compartilhamos informações pessoais com terceiros, exceto quando necessário para:</p>
    <ul className="list-disc ml-6 mb-4">
      <li>Cumprir obrigações legais</li>
      <li>Proteger nossos direitos e propriedade</li>
      <li>Fornecer funcionalidades essenciais do sistema (ex: integrações com WhatsApp, e-mail, etc.)</li>
    </ul>
    <h2 className="text-xl font-semibold mt-6 mb-2">4. Segurança das informações</h2>
    <p className="mb-4">Adotamos medidas técnicas e organizacionais para proteger os dados pessoais contra acesso não autorizado, alteração, divulgação ou destruição.</p>
    <h2 className="text-xl font-semibold mt-6 mb-2">5. Direitos dos titulares dos dados</h2>
    <p className="mb-4">Você pode solicitar, a qualquer momento:</p>
    <ul className="list-disc ml-6 mb-4">
      <li>Acesso aos seus dados pessoais</li>
      <li>Correção de informações incorretas</li>
      <li>Exclusão dos seus dados, quando aplicável</li>
      <li>Limitação ou oposição ao tratamento dos dados</li>
    </ul>
    <p className="mb-4">Para exercer seus direitos, entre em contato pelo e-mail: <a href="mailto:marketing@favalefisicosaude" className="text-blue-600 underline">marketing@favalefisicosaude</a></p>
    <h2 className="text-xl font-semibold mt-6 mb-2">6. Alterações nesta política</h2>
    <p className="mb-4">Podemos atualizar esta Política de Privacidade periodicamente. Notificaremos sobre alterações relevantes por meio do sistema ou por e-mail.</p>
    <h2 className="text-xl font-semibold mt-6 mb-2">7. Contato</h2>
    <p>Em caso de dúvidas sobre esta Política de Privacidade, entre em contato conosco pelo e-mail: <a href="mailto:marketing@favalefisicosaude" className="text-blue-600 underline">marketing@favalefisicosaude</a></p>
  </div>
);

export default PrivacyPolicyPage;
</file>

<file path="client/src/pages/ProfessorsPage.tsx">
import { useState, useEffect } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { Plus, Search, Filter, MoreHorizontal, Edit, Trash2 } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { useToast } from "@/hooks/use-toast";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { ProfessorDialog } from "@/components/professors/ProfessorDialog";
import type { IProfessor } from "@/types";

export default function ProfessorsPage() {
  const [searchTerm, setSearchTerm] = useState("");
  const [selectedProfessor, setSelectedProfessor] = useState<IProfessor | null>(null);
  const [isDialogOpen, setIsDialogOpen] = useState(false);
  const { toast } = useToast();
  const queryClient = useQueryClient();

  // Fetch professors
  const { data: professors = [], isLoading, error } = useQuery({
    queryKey: ["/api/users/professors"],
    select: (data) => data as IProfessor[]
  });

  // Delete professor mutation
  const deleteProfessorMutation = useMutation({
    mutationFn: async (id: number) => {
      const response = await fetch(`/api/users/professors/${id}`, {
        method: "DELETE",
      });
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.message || "Erro ao excluir professor");
      }
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/users/professors"] });
      toast({
        title: "Professor excluído",
        description: "Professor excluído com sucesso",
      });
    },
    onError: (error: Error) => {
      toast({
        title: "Erro ao excluir professor",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  // Filter professors based on search term
  const filteredProfessors = professors.filter((professor) =>
    professor.name?.toLowerCase().includes(searchTerm.toLowerCase()) ||
    professor.username.toLowerCase().includes(searchTerm.toLowerCase()) ||
    professor.email?.toLowerCase().includes(searchTerm.toLowerCase())
  );

  const handleEditProfessor = (professor: IProfessor) => {
    setSelectedProfessor(professor);
    setIsDialogOpen(true);
  };

  const handleDeleteProfessor = (professor: IProfessor) => {
    if (confirm(`Tem certeza que deseja excluir o professor ${professor.name || professor.username}?`)) {
      deleteProfessorMutation.mutate(professor.id);
    }
  };

  const handleNewProfessor = () => {
    setSelectedProfessor(null);
    setIsDialogOpen(true);
  };

  const handleCloseDialog = () => {
    setIsDialogOpen(false);
    setSelectedProfessor(null);
  };

  if (error) {
    return (
      <div className="container mx-auto p-6">
        <Card>
          <CardContent className="p-6">
            <p className="text-red-500">Erro ao carregar professores: {error.message}</p>
          </CardContent>
        </Card>
      </div>
    );
  }

  return (
    <div className="container mx-auto p-6">
      <div className="flex flex-col gap-6">
        {/* Header */}
        <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4">
          <div>
            <h1 className="text-3xl font-bold tracking-tight">Professores</h1>
            <p className="text-muted-foreground">
              Gerencie os professores e instrutores da academia
            </p>
          </div>
          <Button onClick={handleNewProfessor} className="gap-2">
            <Plus className="h-4 w-4" />
            Novo Professor
          </Button>
        </div>

        {/* Search and Filters */}
        <Card>
          <CardContent className="p-6">
            <div className="flex flex-col sm:flex-row gap-4">
              <div className="relative flex-1">
                <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-muted-foreground h-4 w-4" />
                <Input
                  placeholder="Buscar por nome, usuário ou email..."
                  value={searchTerm}
                  onChange={(e) => setSearchTerm(e.target.value)}
                  className="pl-9"
                />
              </div>
              <Button variant="outline" className="gap-2">
                <Filter className="h-4 w-4" />
                Filtros
              </Button>
            </div>
          </CardContent>
        </Card>

        {/* Stats Cards */}
        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
          <Card>
            <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
              <CardTitle className="text-sm font-medium">Total de Professores</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="text-2xl font-bold">{professors.length}</div>
            </CardContent>
          </Card>
          <Card>
            <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
              <CardTitle className="text-sm font-medium">Professores Ativos</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="text-2xl font-bold">
                {professors.filter(p => p.active).length}
              </div>
            </CardContent>
          </Card>
          <Card>
            <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
              <CardTitle className="text-sm font-medium">Especialidades</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="text-2xl font-bold">
                {new Set(professors.flatMap(p => p.specialties || [])).size}
              </div>
            </CardContent>
          </Card>
        </div>

        {/* Professors Table */}
        <Card>
          <CardHeader>
            <CardTitle>Lista de Professores</CardTitle>
          </CardHeader>
          <CardContent>
            {isLoading ? (
              <div className="flex justify-center p-8">
                <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary"></div>
              </div>
            ) : (
              <Table>
                <TableHeader>
                  <TableRow>
                    <TableHead>Nome</TableHead>
                    <TableHead>Email</TableHead>
                    <TableHead>Telefone</TableHead>
                    <TableHead>Especialidades</TableHead>
                    <TableHead>Status</TableHead>
                    <TableHead className="w-[50px]"></TableHead>
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {filteredProfessors.length === 0 ? (
                    <TableRow>
                      <TableCell colSpan={6} className="text-center py-8">
                        Nenhum professor encontrado
                      </TableCell>
                    </TableRow>
                  ) : (
                    filteredProfessors.map((professor) => (
                      <TableRow key={professor.id}>
                        <TableCell className="font-medium">
                          <div>
                            <div>{professor.name || professor.username}</div>
                            <div className="text-sm text-muted-foreground">
                              @{professor.username}
                            </div>
                          </div>
                        </TableCell>
                        <TableCell>{professor.email || "-"}</TableCell>
                        <TableCell>{professor.phone || "-"}</TableCell>
                        <TableCell>
                          <div className="flex flex-wrap gap-1">
                            {professor.specialties?.length ? (
                              professor.specialties.map((specialty) => (
                                <Badge key={specialty} variant="secondary" className="text-xs">
                                  {specialty}
                                </Badge>
                              ))
                            ) : (
                              <span className="text-muted-foreground">-</span>
                            )}
                          </div>
                        </TableCell>
                        <TableCell>
                          <Badge 
                            variant={professor.active ? "default" : "secondary"}
                            className={professor.active ? "bg-green-500" : ""}
                          >
                            {professor.active ? "Ativo" : "Inativo"}
                          </Badge>
                        </TableCell>
                        <TableCell>
                          <DropdownMenu>
                            <DropdownMenuTrigger asChild>
                              <Button variant="ghost" className="h-8 w-8 p-0">
                                <MoreHorizontal className="h-4 w-4" />
                              </Button>
                            </DropdownMenuTrigger>
                            <DropdownMenuContent align="end">
                              <DropdownMenuItem onClick={() => handleEditProfessor(professor)}>
                                <Edit className="mr-2 h-4 w-4" />
                                Editar
                              </DropdownMenuItem>
                              <DropdownMenuItem 
                                onClick={() => handleDeleteProfessor(professor)}
                                className="text-red-600"
                              >
                                <Trash2 className="mr-2 h-4 w-4" />
                                Excluir
                              </DropdownMenuItem>
                            </DropdownMenuContent>
                          </DropdownMenu>
                        </TableCell>
                      </TableRow>
                    ))
                  )}
                </TableBody>
              </Table>
            )}
          </CardContent>
        </Card>
      </div>

      {/* Professor Dialog */}
      <ProfessorDialog
        professor={selectedProfessor}
        open={isDialogOpen}
        onClose={handleCloseDialog}
      />
    </div>
  );
}
</file>

<file path="client/src/pages/ReportPage.tsx">
import { SessionReport } from '@/components/scheduling/SessionReport';

export default function ReportPage() {
  return <SessionReport />;
}
</file>

<file path="client/src/pages/SecurityPage.tsx">
import React from 'react';
import Layout from "@/components/Layout";
import AuditLogViewer from "@/components/admin/AuditLogViewer";
import { useAuth } from "@/hooks/use-auth";
import { Redirect } from "wouter";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Shield, FileLock, AlertTriangle, Lock } from "lucide-react";

export default function SecurityPage() {
  const { user } = useAuth();
  
  // Verificar se o usuário é administrador
  if (!user || user.role !== "admin") {
    return <Redirect to="/" />;
  }

  return (
    <Layout>
      <div className="container mx-auto p-4">
        <div className="flex items-center mb-6">
          <Shield className="h-8 w-8 mr-2 text-primary" />
          <h1 className="text-3xl font-bold">Segurança e Privacidade</h1>
        </div>
        
        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-6">
          <Card>
            <CardHeader className="pb-3">
              <div className="flex items-center">
                <FileLock className="h-5 w-5 mr-2 text-primary" />
                <CardTitle>Logs de Auditoria</CardTitle>
              </div>
              <CardDescription>
                Rastreamento das ações realizadas no sistema
              </CardDescription>
            </CardHeader>
            <CardContent>
              <p className="text-sm">
                Os logs registram eventos importantes como logins, modificações de dados e exclusões, permitindo rastrear ações e detectar problemas de segurança.
              </p>
            </CardContent>
          </Card>
          
          <Card>
            <CardHeader className="pb-3">
              <div className="flex items-center">
                <Lock className="h-5 w-5 mr-2 text-primary" />
                <CardTitle>Criptografia de Dados</CardTitle>
              </div>
              <CardDescription>
                Proteção de informações sensíveis
              </CardDescription>
            </CardHeader>
            <CardContent>
              <p className="text-sm">
                Todas as senhas são armazenadas com criptografia de alto nível (scrypt) e salting, e as conexões com o banco de dados são protegidas com SSL.
              </p>
            </CardContent>
          </Card>
          
          <Card>
            <CardHeader className="pb-3">
              <div className="flex items-center">
                <AlertTriangle className="h-5 w-5 mr-2 text-primary" />
                <CardTitle>Controle de Acesso</CardTitle>
              </div>
              <CardDescription>
                Gerenciamento de permissões por perfil
              </CardDescription>
            </CardHeader>
            <CardContent>
              <p className="text-sm">
                O sistema implementa controle de acesso baseado em papéis (RBAC), garantindo que apenas usuários autorizados possam acessar áreas e funções específicas.
              </p>
            </CardContent>
          </Card>
        </div>
        
        <Tabs defaultValue="audit-logs" className="w-full">
          <TabsList className="mb-6">
            <TabsTrigger value="audit-logs">Logs de Auditoria</TabsTrigger>
            <TabsTrigger value="privacy-policy">Política de Privacidade</TabsTrigger>
            <TabsTrigger value="security-settings">Configurações de Segurança</TabsTrigger>
          </TabsList>
          
          <TabsContent value="audit-logs">
            <AuditLogViewer />
          </TabsContent>
          
          <TabsContent value="privacy-policy">
            <Card>
              <CardHeader>
                <CardTitle>Política de Privacidade</CardTitle>
                <CardDescription>
                  Como o sistema protege os dados dos usuários e alunos
                </CardDescription>
              </CardHeader>
              <CardContent className="space-y-4">
                <div>
                  <h3 className="text-lg font-medium mb-2">Coleta de Dados</h3>
                  <p>
                    A Favale & Pink coleta apenas as informações necessárias para o gerenciamento de leads e alunos. 
                    Estes dados incluem nome, e-mail, telefone, estado e informações relacionadas às campanhas e interesses.
                  </p>
                </div>
                
                <div>
                  <h3 className="text-lg font-medium mb-2">Uso dos Dados</h3>
                  <p>
                    As informações coletadas são utilizadas exclusivamente para:
                  </p>
                  <ul className="list-disc pl-6 mt-2 space-y-1">
                    <li>Gerenciar os contatos e relacionamentos com leads e alunos</li>
                    <li>Enviar informações relevantes sobre serviços e treinamentos</li>
                    <li>Melhorar a qualidade dos serviços oferecidos</li>
                    <li>Gerar relatórios e estatísticas internos</li>
                  </ul>
                </div>
                
                <div>
                  <h3 className="text-lg font-medium mb-2">Proteção de Dados</h3>
                  <p>
                    Implementamos diversas medidas de segurança para proteger as informações armazenadas:
                  </p>
                  <ul className="list-disc pl-6 mt-2 space-y-1">
                    <li>Criptografia de dados sensíveis</li>
                    <li>Controle de acesso baseado em funções</li>
                    <li>Auditoria e monitoramento de atividades</li>
                    <li>Backups regulares e proteção contra perda de dados</li>
                    <li>Conexões seguras com o banco de dados</li>
                  </ul>
                </div>
                
                <div>
                  <h3 className="text-lg font-medium mb-2">Compartilhamento</h3>
                  <p>
                    A Favale & Pink não compartilha dados pessoais com terceiros, exceto quando necessário para a prestação dos serviços ou quando exigido por lei.
                  </p>
                </div>
                
                <div>
                  <h3 className="text-lg font-medium mb-2">Direitos dos Usuários</h3>
                  <p>
                    Os titulares dos dados têm direito a:
                  </p>
                  <ul className="list-disc pl-6 mt-2 space-y-1">
                    <li>Acessar seus dados pessoais</li>
                    <li>Solicitar a correção de informações incorretas</li>
                    <li>Solicitar a exclusão de seus dados</li>
                    <li>Revogar o consentimento para tratamento dos dados</li>
                  </ul>
                </div>
              </CardContent>
            </Card>
          </TabsContent>
          
          <TabsContent value="security-settings">
            <Card>
              <CardHeader>
                <CardTitle>Configurações de Segurança</CardTitle>
                <CardDescription>
                  Configurações avançadas de segurança do sistema
                </CardDescription>
              </CardHeader>
              <CardContent>
                <div className="space-y-6">
                  <div>
                    <h3 className="text-lg font-medium mb-2">Informações do Ambiente</h3>
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                      <div className="p-4 rounded-md bg-gray-50 dark:bg-gray-800">
                        <p className="text-sm font-medium mb-1">Ambiente</p>
                        <p className="text-sm">{process.env.NODE_ENV === 'production' ? 'Produção' : 'Desenvolvimento'}</p>
                      </div>
                      <div className="p-4 rounded-md bg-gray-50 dark:bg-gray-800">
                        <p className="text-sm font-medium mb-1">Conexão Segura (HTTPS)</p>
                        <p className="text-sm">{process.env.NODE_ENV === 'production' ? 'Ativada' : 'Desativada em desenvolvimento'}</p>
                      </div>
                    </div>
                  </div>
                  
                  <div>
                    <h3 className="text-lg font-medium mb-2">Políticas de Segurança</h3>
                    <ul className="list-disc pl-6 space-y-2">
                      <li>Senhas devem conter no mínimo 8 caracteres, incluindo letras maiúsculas, minúsculas, números e caracteres especiais</li>
                      <li>Tempo de expiração da sessão: 24 horas</li>
                      <li>Restrição de acesso a áreas administrativas baseada em papéis (RBAC)</li>
                      <li>Auditoria de todas as ações sensíveis realizadas no sistema</li>
                      <li>Proteção contra ataques CSRF através de cookies SameSite</li>
                      <li>Cookies HttpOnly para evitar acesso por JavaScript</li>
                      <li>Validação de entrada em todos os campos do formulário</li>
                    </ul>
                  </div>
                </div>
              </CardContent>
            </Card>
          </TabsContent>
        </Tabs>
      </div>
    </Layout>
  );
}
</file>

<file path="client/src/pages/SessionsPage.tsx">
import { SessionManagement } from '@/components/scheduling/SessionManagement';
import { Card, CardContent } from '@/components/ui/card';

export default function SessionsPage() {
  return (
    <div className="container mx-auto p-2 sm:p-4 lg:p-6">
      <Card className="w-full border-gray-100 dark:border-gray-700 shadow-sm rounded-xl overflow-hidden">
        <CardContent className="p-3 sm:p-6">
          <SessionManagement />
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="client/src/pages/TaskDetailsPage.tsx">
import TaskDetailsPageComponent from "@/components/tasks/TaskDetailsPage";

export default function TaskDetailsPage() {
  return <TaskDetailsPageComponent />;
}
</file>

<file path="client/src/pages/TasksPage.tsx">
import TasksPageComponent from "@/components/tasks/TasksPage";

export default function TasksPage() {
  return <TasksPageComponent />;
}
</file>

<file path="client/src/pages/WhatsappConfigPage.tsx">
import WhatsappConfigForm from "@/components/whatsapp/WhatsappConfigForm";

export default function WhatsappConfigPage() {
  return (
    <div className="container mx-auto p-4">
      <div className="mb-6">
        <h1 className="text-2xl font-bold">Configuração do WhatsApp</h1>
        <p className="text-muted-foreground">
          Configure a integração com a Evolution API para usar o WhatsApp no CRM.
        </p>
      </div>
      <div className="mx-auto max-w-3xl">
        <WhatsappConfigForm />
      </div>
    </div>
  );
}
</file>

<file path="client/src/pages/WhatsappPage.tsx">
import { useState, useEffect, useRef } from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Avatar, AvatarFallback } from "@/components/ui/avatar";
import { Tabs, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Badge } from "@/components/ui/badge";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { useToast } from "@/hooks/use-toast";
import { useQuery, useMutation } from "@tanstack/react-query";
import { queryClient } from "@/lib/queryClient";
import { Lead, WhatsappMessage } from "@shared/schema";
import { useWhatsappContext } from "@/context/WhatsappContext";
import { CheckCircle2, AlertCircle, XCircle, Search, Filter, PlusCircle, MoreVertical, Star, Clock, Inbox, RefreshCw, Paperclip, Send } from "lucide-react";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";
import { format, isToday, isYesterday, isSameWeek } from "date-fns";
import { ptBR } from "date-fns/locale";

export default function WhatsappPage() {
  const [searchQuery, setSearchQuery] = useState("");
  const [selectedTab, setSelectedTab] = useState("all");
  const { openWhatsappChat, connectionStatus, refreshConnectionStatus } = useWhatsappContext();

  // Estado para o lead selecionado na lista
  const [selectedLead, setSelectedLead] = useState<Lead | null>(null);
  const [activeTab, setActiveTab] = useState('all');
  const endOfMessagesRef = useRef<HTMLDivElement>(null);
  const { toast } = useToast();
  
  // Buscar todos os leads
  const { data: leads = [], isLoading } = useQuery<Lead[]>({
    queryKey: ["/api/leads"],
  });
  
  // Mensagem mais recente para exibir na prévia
  const { data: allMessages = {} } = useQuery<{[leadId: string]: any[]}>({ 
    queryKey: ['/api/whatsapp/recent-messages'],
    refetchInterval: 30000, // Atualiza a cada 30 segundos
  });
  
  /*
   * Filtrar leads com base em 3 critérios:
   * 1. Somente mostrar Leonardo Soledade (ID 14776) inicialmente
   * 2. Adicionar outros leads à lista quando eles tiverem mensagens
   * 3. Aplicar os filtros de busca e tab selecionada
   * 
   * Isso reduz o lag inicial ao carregar a página, mostrando apenas
   * as conversas realmente relevantes.
   */
  const filteredLeads = leads.filter((lead: Lead) => {
    // Verifica se é o Leonardo Soledade (ID 14776) ou se tem mensagens enviadas/recebidas
    const isLeonardo = lead.id === 14776;
    const hasMessages = Object.keys(allMessages || {})
      .map(id => parseInt(id))
      .includes(lead.id);
    
    // Se não for o Leonardo e não tiver mensagens, não mostra na lista
    if (!isLeonardo && !hasMessages) return false;
    
    // Aplica o filtro de busca
    const matchesSearch = searchQuery === "" ||
      lead.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
      (lead.phone && lead.phone.includes(searchQuery)) ||
      (lead.email && lead.email.toLowerCase().includes(searchQuery.toLowerCase()));

    if (selectedTab === "all") return matchesSearch;
    return matchesSearch && lead.status.toLowerCase() === selectedTab.toLowerCase();
  });
  
  // Formatar a data para exibição
  const formatMessageDate = (date: Date | string) => {
    const messageDate = new Date(date);
    
    if (isToday(messageDate)) {
      return format(messageDate, "HH:mm", { locale: ptBR });
    } else if (isYesterday(messageDate)) {
      return "Ontem";
    } else if (isSameWeek(messageDate, new Date())) {
      return format(messageDate, "EEEE", { locale: ptBR });
    } else {
      return format(messageDate, "dd/MM/yyyy", { locale: ptBR });
    }
  };
  
  // Buscar mensagens do lead selecionado
  const { data: messages = [] } = useQuery<WhatsappMessage[]>({
    queryKey: selectedLead ? [`/api/whatsapp/lead/${selectedLead.id}`] : ['no-messages'],
    enabled: !!selectedLead,
    refetchInterval: selectedLead ? 10000 : false, // Atualizar a cada 10 segundos se tiver um lead selecionado
  });
  
  const getLastMessage = (leadId: number) => {
    const leadMessages = allMessages[leadId] || [];
    if (leadMessages.length === 0) {
      return 'Nenhuma mensagem ainda...';
    }
    
    const lastMessage = leadMessages[0]; // A primeira mensagem do array será a mais recente
    const prefix = lastMessage.direction === 'outgoing' ? 'Você: ' : '';
    return `${prefix}${lastMessage.content}`;
  };
  
  const getLastMessageTime = (leadId: number) => {
    const leadMessages = allMessages[leadId] || [];
    if (leadMessages.length === 0) {
      return null;
    }
    
    return new Date(leadMessages[0].timestamp);
  };
  
  // Estado para a mensagem a ser enviada
  const [messageText, setMessageText] = useState("");
  
  // Efeito para rolar para o final das mensagens quando novas mensagens chegarem
  useEffect(() => {
    if (endOfMessagesRef.current) {
      endOfMessagesRef.current.scrollIntoView({ behavior: 'smooth' });
    }
  }, [messages]);
  
  // Mutação para enviar mensagem
  const { mutate: sendMessage, isPending: isSending } = useMutation({
    mutationFn: async (content: string) => {
      if (!selectedLead) return null;
      
      return fetch('/api/whatsapp/send', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          leadId: selectedLead.id,
          direction: 'outgoing',
          content,
          status: 'pending',
        }),
      }).then(async res => {
        const responseData = await res.json();
        
        if (!res.ok) {
          // Verificar se o erro é de número não autorizado
          if (responseData.unauthorizedNumber) {
            throw new Error(
              'Número não autorizado: Este número não está na lista de permissões da API do WhatsApp. ' +
              'Em modo de desenvolvimento, você só pode enviar mensagens para números previamente autorizados.'
            );
          }
          throw new Error(responseData.error || 'Falha ao enviar mensagem');
        }
        
        return responseData;
      });
    },
    onSuccess: () => {
      // Limpar o campo de mensagem
      setMessageText('');
      
      // Atualizar a lista de mensagens
      if (selectedLead) {
        // Invalidar tanto a consulta de mensagens específicas quanto a de mensagens recentes
        queryClient.invalidateQueries({ queryKey: [`/api/whatsapp/lead/${selectedLead.id}`] });
        queryClient.invalidateQueries({ queryKey: ['/api/whatsapp/recent-messages'] });
      }
    },
    onError: (error) => {
      console.error('Erro ao enviar mensagem:', error);
      
      // Exibir notificação de erro usando o toast
      toast({
        title: "Erro ao enviar mensagem",
        description: error instanceof Error ? error.message : 'Falha ao enviar mensagem',
        variant: "destructive",
      });
    },
  });
  
  // Função para lidar com o envio de mensagem
  const handleSendMessage = (e: React.FormEvent) => {
    e.preventDefault();
    if (messageText.trim() && !isSending) {
      sendMessage(messageText.trim());
    }
  };
  
  return (
    <div className="flex flex-col h-[calc(100vh-8rem)] w-full bg-background rounded-lg border">
      {/* Status da conexão */}
      <Alert 
        variant={connectionStatus.status === 'connected' ? 'default' : 
                connectionStatus.status === 'checking' ? 'default' : 'destructive'} 
        className="rounded-none border-x-0 border-t-0"
      >
        <div className="flex items-center justify-between">
          <div className="flex items-center">
            {connectionStatus.status === 'connected' ? (
              <CheckCircle2 className="h-4 w-4 mr-2 text-green-500" />
            ) : connectionStatus.status === 'checking' ? (
              <div className="animate-spin rounded-full h-4 w-4 border-2 border-t-primary border-r-transparent border-b-primary border-l-transparent mr-2"></div>
            ) : (
              <XCircle className="h-4 w-4 mr-2" />
            )}
            <span className="text-sm font-medium">
              {connectionStatus.status === 'connected' ? 
                `Conectado ao WhatsApp: ${connectionStatus.details?.name || 'Conta WhatsApp'} (${connectionStatus.details?.phone || 'Não disponível'})` : 
                connectionStatus.status === 'checking' ? 'Verificando conexão...' : 
                connectionStatus.message || 'Falha na conexão com a API do WhatsApp'}
            </span>
          </div>
          <div className="flex items-center gap-2">
            <Button 
              onClick={() => refreshConnectionStatus()} 
              variant="ghost" 
              size="sm"
              className="h-7 px-2"
              disabled={connectionStatus.status === 'checking'}
            >
              <RefreshCw className="h-3.5 w-3.5 mr-1" />
              Verificar
            </Button>
            <Button 
              onClick={() => window.location.href = '/whatsapp/config'} 
              variant="outline" 
              size="sm"
              className="h-7"
            >
              Configurações
            </Button>
          </div>
        </div>
      </Alert>
      
      {/* Interface principal */}
      <div className="flex flex-1 h-full">
        {/* Lista de leads (similar à lista de emails) */}
        <div className="w-1/3 border-r flex flex-col overflow-hidden">
          <div className="p-4 border-b">
            <div className="flex items-center justify-between mb-3">
              <h2 className="text-lg font-semibold">Conversas</h2>
              <TooltipProvider>
                <Tooltip>
                  <TooltipTrigger asChild>
                    <Button variant="ghost" size="icon" className="h-8 w-8">
                      <PlusCircle className="h-5 w-5 text-muted-foreground" />
                    </Button>
                  </TooltipTrigger>
                  <TooltipContent>
                    <p>Nova conversa</p>
                  </TooltipContent>
                </Tooltip>
              </TooltipProvider>
            </div>
            <div className="relative">
              <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground" />
              <Input 
                placeholder="Buscar contatos, mensagens..." 
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                className="pl-9 w-full text-sm"
              />
            </div>
          </div>
          
          <div className="border-b">
            <Tabs value={activeTab} onValueChange={setActiveTab} className="w-full">
              <TabsList className="grid w-full grid-cols-4">
                <TabsTrigger value="all" className="text-xs">
                  <Inbox className="h-3.5 w-3.5 mr-1.5" />
                  Todos
                </TabsTrigger>
                <TabsTrigger value="novo" className="text-xs">
                  <Badge variant="secondary" className="h-4 w-4 p-0 text-[10px] mr-1.5 flex items-center justify-center">3</Badge>
                  Novos
                </TabsTrigger>
                <TabsTrigger value="contatado" className="text-xs">
                  <Clock className="h-3.5 w-3.5 mr-1.5" />
                  Recentes
                </TabsTrigger>
                <TabsTrigger value="qualificado" className="text-xs">
                  <Star className="h-3.5 w-3.5 mr-1.5" />
                  Favoritos
                </TabsTrigger>
              </TabsList>
            </Tabs>
          </div>
          
          <div className="overflow-y-auto flex-1">
            {isLoading ? (
              <div className="flex justify-center items-center h-full">
                <div className="animate-spin rounded-full h-8 w-8 border-2 border-t-primary border-r-transparent border-b-primary border-l-transparent"></div>
              </div>
            ) : filteredLeads.length === 0 ? (
              <div className="flex flex-col items-center justify-center h-full text-center p-4">
                <div className="bg-muted rounded-full p-3 mb-3">
                  <Inbox className="h-5 w-5 text-muted-foreground" />
                </div>
                <h3 className="font-medium mb-1">Nenhuma conversa encontrada</h3>
                <p className="text-sm text-muted-foreground">
                  Não foram encontrados resultados para sua busca.
                </p>
              </div>
            ) : (
              <ul className="divide-y">
                {filteredLeads.map((lead) => (
                  <li 
                    key={lead.id} 
                    className={`hover:bg-muted/50 cursor-pointer transition-colors duration-200 ${selectedLead?.id === lead.id ? 'bg-muted' : ''}`}
                    onClick={() => setSelectedLead(lead)}
                  >
                    <div className="p-3 sm:p-4 flex items-start">
                      <Avatar className="h-10 w-10 mr-3 flex-shrink-0">
                        <AvatarFallback className="bg-primary-light text-white">
                          {lead.name.substring(0, 2).toUpperCase()}
                        </AvatarFallback>
                      </Avatar>
                      <div className="flex-1 min-w-0">
                        <div className="flex items-start justify-between">
                          <h3 className="font-medium text-sm truncate">{lead.name}</h3>
                          <span className="text-xs text-muted-foreground whitespace-nowrap ml-2">
                            {formatMessageDate(lead.updatedAt)}
                          </span>
                        </div>
                        <p className="text-xs text-muted-foreground truncate mt-1">
                          {lead.phone || 'Sem telefone'}
                        </p>
                        <p className="text-xs truncate mt-0.5">
                          {getLastMessage(lead.id)}
                        </p>
                      </div>
                    </div>
                  </li>
                ))}
              </ul>
            )}
          </div>
        </div>
        
        {/* Área de visualização do chat */}
        <div className="flex-1 flex flex-col overflow-hidden">
          {selectedLead ? (
            <>
              {/* Cabeçalho do chat */}
              <div className="p-4 border-b flex items-center justify-between">
                <div className="flex items-center">
                  <Avatar className="h-9 w-9 mr-3">
                    <AvatarFallback className="bg-primary-light text-white">
                      {selectedLead.name.substring(0, 2).toUpperCase()}
                    </AvatarFallback>
                  </Avatar>
                  <div>
                    <h3 className="font-medium text-sm">{selectedLead.name}</h3>
                    <p className="text-xs text-muted-foreground">{selectedLead.phone || 'Sem telefone'}</p>
                  </div>
                </div>
                <div className="flex items-center space-x-1">
                  <TooltipProvider>
                    <Tooltip>
                      <TooltipTrigger asChild>
                        <Button variant="ghost" size="icon" className="h-8 w-8">
                          <MoreVertical className="h-4 w-4 text-muted-foreground" />
                        </Button>
                      </TooltipTrigger>
                      <TooltipContent>
                        <p>Mais opções</p>
                      </TooltipContent>
                    </Tooltip>
                  </TooltipProvider>
                </div>
              </div>
              
              {/* Área de mensagens */}
              <div className="flex-1 overflow-y-auto p-4 space-y-3" style={{ backgroundImage: 'url("data:image/svg+xml,%3Csvg width=\'20\' height=\'20\' viewBox=\'0 0 40 40\' xmlns=\'http://www.w3.org/2000/svg\'%3E%3Cg fill=\'%239C92AC\' fill-opacity=\'0.05\' fill-rule=\'evenodd\'%3E%3Cpath d=\'M0 20L20 0h20L0 40z\'/%3E%3Cpath d=\'M20 40L40 20 40 40z\'/%3E%3C/g%3E%3C/svg%3E")' }}>
                {messages.length === 0 ? (
                  <div className="flex flex-col items-center justify-center h-full text-center">
                    <div className="bg-muted rounded-full p-4 mb-3">
                      <Inbox className="h-6 w-6 text-muted-foreground" />
                    </div>
                    <h3 className="font-medium mb-1">Nenhuma mensagem ainda</h3>
                    <p className="text-sm text-muted-foreground">
                      Envie uma mensagem para iniciar a conversa.
                    </p>
                    <Button className="mt-4" onClick={() => openWhatsappChat(selectedLead)}>
                      <span className="material-icons text-sm mr-2">chat</span>
                      Iniciar Conversa
                    </Button>
                  </div>
                ) : (
                  <>
                    {messages.map((message) => (
                      <div 
                        key={message.id} 
                        className={`flex ${message.direction === 'outgoing' ? 'justify-end' : 'justify-start'}`}
                      >
                        <div 
                          className={`max-w-xs md:max-w-sm rounded-lg p-3 ${message.direction === 'outgoing' 
                            ? 'bg-primary text-primary-foreground rounded-br-none' 
                            : 'bg-card dark:bg-gray-700 rounded-bl-none'}`}
                        >
                          <p className="whitespace-pre-wrap break-words text-sm">{message.content}</p>
                          <div className="text-xs opacity-80 text-right mt-1 flex justify-end items-center">
                            {formatMessageDate(message.timestamp)}
                            {message.direction === 'outgoing' && (
                              <span className="ml-1">
                                {message.status === 'read' ? (
                                  <span className="text-blue-400">✓✓</span>
                                ) : message.status === 'delivered' ? (
                                  <span>✓✓</span>
                                ) : message.status === 'sent' ? (
                                  <span>✓</span>
                                ) : message.status === 'failed' ? (
                                  <span className="text-red-500">⚠</span>
                                ) : (
                                  <span className="opacity-50">⌛</span>
                                )}
                              </span>
                            )}
                          </div>
                        </div>
                      </div>
                    ))}
                    {/* Elemento invisível para o scroll automático */}
                    <div ref={endOfMessagesRef} />
                  </>
                )}
              </div>
              
              {/* Campo de entrada de mensagem */}
              <form onSubmit={handleSendMessage} className="p-3 border-t flex items-end">
                <TooltipProvider>
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <Button type="button" variant="ghost" size="icon" className="h-9 w-9 mr-1">
                        <Paperclip className="h-5 w-5 text-muted-foreground" />
                      </Button>
                    </TooltipTrigger>
                    <TooltipContent>
                      <p>Anexar arquivo</p>
                    </TooltipContent>
                  </Tooltip>
                </TooltipProvider>
                <div className="flex-1 mr-2">
                  <textarea 
                    className="w-full p-2 border rounded-lg focus:outline-none focus:ring-1 focus:ring-primary resize-none min-h-[40px] max-h-32" 
                    placeholder="Digite uma mensagem"
                    rows={1}
                    value={messageText}
                    onChange={(e) => setMessageText(e.target.value)}
                    onKeyDown={(e) => {
                      if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        if (messageText.trim() && !isSending) {
                          sendMessage(messageText.trim());
                        }
                      }
                    }}
                    disabled={isSending || connectionStatus.status !== 'connected'}
                  />
                </div>
                <TooltipProvider>
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <Button 
                        type="submit" 
                        className="h-9 w-9 p-0 rounded-full"
                        disabled={!messageText.trim() || isSending || connectionStatus.status !== 'connected'}
                      >
                        {isSending ? (
                          <div className="h-4 w-4 animate-spin rounded-full border-2 border-t-transparent border-white" />
                        ) : (
                          <Send className="h-4 w-4" />
                        )}
                      </Button>
                    </TooltipTrigger>
                    <TooltipContent>
                      <p>Enviar mensagem</p>
                    </TooltipContent>
                  </Tooltip>
                </TooltipProvider>
              </form>
            </>
          ) : (
            <div className="flex flex-col items-center justify-center h-full text-center p-4">
              <div className="bg-muted rounded-full p-6 mb-4">
                <span className="material-icons text-4xl text-muted-foreground">chat</span>
              </div>
              <h2 className="text-xl font-semibold mb-2">Bem-vindo ao WhatsApp</h2>
              <p className="text-muted-foreground max-w-sm mb-6">
                Selecione um contato para iniciar uma conversa ou ver mensagens anteriores.
              </p>
              <p className="text-xs text-muted-foreground">
                {connectionStatus.status === 'connected' ? 
                  '✓ Conectado à API do WhatsApp.' : 
                  '⚠️ Status do WhatsApp: ' + connectionStatus.status}
              </p>
            </div>
          )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="client/src/services/openai.ts">
import { OPENAI_CONFIG } from '@/config/openai';

interface ChatMessage {
  role: 'user' | 'assistant' | 'system';
  content: string;
}

interface ChatCompletionResponse {
  choices: {
    message: {
      content: string;
      role: string;
    };
  }[];
}

class OpenAIService {
  private apiKey: string;
  private baseUrl: string;

  constructor() {
    // Usa a chave da API configurada no sistema
    this.apiKey = OPENAI_CONFIG.API_KEY;
    this.baseUrl = OPENAI_CONFIG.BASE_URL;
  }

  hasApiKey(): boolean {
    return !!this.apiKey;
  }

  async sendMessage(messages: ChatMessage[]): Promise<string> {
    try {
      // Limita o contexto para evitar exceder o limite de tokens
      const contextMessages = messages.slice(-OPENAI_CONFIG.CONTEXT_WINDOW);
      
      const response = await fetch(`${this.baseUrl}/chat/completions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.apiKey}`,
        },
        body: JSON.stringify({
          model: OPENAI_CONFIG.MODEL,
          messages: [
            {
              role: 'system',
              content: `Você é o FavaleIA, um assistente de IA especializado em CRM e gestão de clientes da Favale Pink Personal Training. 

INSTRUÇÕES DE FORMATAÇÃO (MUITO IMPORTANTE):
- SEMPRE formate suas respostas usando Markdown
- Use **negrito** para destacar informações importantes
- Use bullet points (•) para listas
- Use \`código\` para termos técnicos ou nomes de campos
- Use blocos de código \`\`\`javascript para códigos
- Seja visual e bem estruturado

CONTEXTO E MEMÓRIA:
- Lembre-se das informações compartilhadas durante a conversa
- Faça referência a dados anteriores quando relevante
- Mantenha continuidade nas conversas
- Se o usuário mencionar leads, clientes ou agendamentos, refira-se a eles especificamente

ESPECIALIDADES:
• **Gestão de Leads**: Análise, qualificação e conversão
• **Agendamentos**: Organização de treinos e consultas
• **Análise de Dados**: Relatórios e insights de performance
• **Processos de Vendas**: Otimização e automação
• **Relacionamento**: Estratégias de retenção e fidelização

Seja útil, profissional e forneça respostas claras e acionáveis sempre bem formatadas.`
            },
            ...contextMessages
          ],
          temperature: OPENAI_CONFIG.TEMPERATURE,
          max_tokens: OPENAI_CONFIG.MAX_TOKENS,
        }),
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error?.message || `Erro da API: ${response.status}`);
      }

      const data: ChatCompletionResponse = await response.json();
      return data.choices[0]?.message?.content || 'Desculpe, não consegui gerar uma resposta.';
    } catch (error) {
      console.error('Erro ao chamar OpenAI:', error);
      if (error instanceof Error) {
        throw error;
      }
      throw new Error('Erro desconhecido ao comunicar com a API OpenAI');
    }
  }

}

export const openAIService = new OpenAIService();
export type { ChatMessage };
</file>

<file path="client/src/types/index.ts">
// Interface para professores (baseada nos users com role='professor')
export interface IProfessor {
  id: number;
  username: string;
  role: 'admin' | 'professor';
  name?: string;
  email?: string;
  phone?: string;
  address?: string;
  specialty?: string;
  bio?: string;
  hourlyRate?: number;
  specialties?: string[];
  active: boolean;
  createdAt: string;
  updatedAt: string;
}

// Interface para regras de recorrência
export interface IRegraRecorrencia {
  type: 'daily' | 'weekly' | 'monthly' | 'yearly' | 'custom';
  interval: number; // A cada X dias/semanas/meses
  weekDays?: string[]; // ['monday', 'wednesday', 'friday'] para recorrência semanal
  monthDay?: number; // Dia do mês (1-31) para recorrência mensal
  endType: 'never' | 'date' | 'count';
  endDate?: Date;
  endCount?: number;
}

// Interface para agendamentos recorrentes
export interface IAgendamentoRecorrente {
  id: number;
  professorId: number;
  studentId: number;
  location: string;
  value: number; // Valor em centavos
  service: string;
  notes?: string;
  regras: IRegraRecorrencia;
  startDate: string;
  endDate?: string;
  maxOccurrences?: number;
  active: boolean;
  createdAt: string;
  updatedAt: string;
}

// Interface para informações do aluno no agendamento
export interface IStudent {
  id: number;
  name: string;
  email?: string;
  phone?: string;
  notes?: string;
}

// Interface para aulas individuais (compatível com react-big-calendar)
export interface IAula {
  id: number;
  agendamentoRecorrenteId?: number;
  professorId: number;
  studentId: number;
  startTime: string;
  endTime: string;
  location: string;
  value: number;
  service: string;
  notes?: string;
  status: 'agendado' | 'em_andamento' | 'concluido' | 'cancelado' | 'remarcado';
  isModified: boolean;
  originalStartTime?: string;
  originalEndTime?: string;
  createdAt: string;
  updatedAt: string;
  
  // Campos necessários para react-big-calendar
  title: string; // Será gerado a partir do service e nome do aluno
  start?: Date; // Será convertido de startTime
  end?: Date; // Será convertido de endTime
  resource?: any; // Dados adicionais para o calendário
  
  // Informações relacionadas (vindas das joins)
  professor?: IProfessor;
  student?: IStudent;
}

// Interface para formulário de nova recorrência
export interface INewRecurrenceForm {
  professorId: number;
  studentId: number;
  location: string;
  value: number;
  service: string;
  notes?: string;
  startDate: Date;
  startTime: string;
  endTime: string;
  recurrence: IRegraRecorrencia;
}

// Interface para o contexto de aulas/agendamentos
export interface ISchedulingContext {
  aulas: IAula[];
  agendamentosRecorrentes: IAgendamentoRecorrente[];
  isLoading: boolean;
  error: string | null;
  fetchAulas: (filters?: any) => Promise<void>;
  createRecurrence: (recurrence: INewRecurrenceForm) => Promise<void>;
  updateAula: (id: number, data: Partial<IAula>) => Promise<void>;
  deleteAula: (id: number) => Promise<void>;
  checkConflicts: (professorId: number, studentId: number, startTime: Date, endTime: Date) => Promise<boolean>;
}
</file>

<file path="client/src/utils/formatters.ts">
import { format, parseISO } from "date-fns";
import { ptBR } from "date-fns/locale";

// Format date to Brazilian format (DD/MM/YYYY)
export function formatDate(date: string | Date): string {
  try {
    const parsedDate = typeof date === "string" ? parseISO(date) : date;
    return format(parsedDate, "dd/MM/yyyy", { locale: ptBR });
  } catch (error) {
    console.error("Error formatting date:", error);
    return "Data inválida";
  }
}

// Format currency to Brazilian format (R$ 1.000,00)
export function formatCurrency(value: number): string {
  return new Intl.NumberFormat("pt-BR", {
    style: "currency",
    currency: "BRL"
  }).format(value);
}

// Format percentage
export function formatPercentage(value: number): string {
  return `${value.toFixed(1)}%`;
}

// Format phone number (11) 98765-4321
export function formatPhoneNumber(phone: string): string {
  if (!phone) return "";
  
  // Remove non-numeric characters
  const numericOnly = phone.replace(/\D/g, "");
  
  if (numericOnly.length === 11) {
    // Format as (XX) XXXXX-XXXX (mobile)
    return `(${numericOnly.substring(0, 2)}) ${numericOnly.substring(2, 7)}-${numericOnly.substring(7)}`;
  } else if (numericOnly.length === 10) {
    // Format as (XX) XXXX-XXXX (landline)
    return `(${numericOnly.substring(0, 2)}) ${numericOnly.substring(2, 6)}-${numericOnly.substring(6)}`;
  }
  
  // Return original if not recognized format
  return phone;
}
</file>

<file path="client/src/utils/sessionGrouping.ts">
import { format, isSameDay, differenceInDays, addDays } from 'date-fns';
import { ptBR } from 'date-fns/locale';

type SessionStatus = 'scheduled' | 'completed' | 'cancelled' | 'no-show' | 'agendado' | 'concluído' | 'cancelado';

interface Session {
  id: number;
  startTime: string;
  endTime: string;
  location: string;
  source: 'Favale' | 'Pink' | 'FavalePink';
  notes?: string;
  status: SessionStatus;
  leadId: number;
  trainerId: number;
  value?: number;
  service?: string;
  recurrenceType?: string;
  recurrenceGroupId?: string;
  isRecurrenceParent?: boolean;
  parentSessionId?: number;
}

interface RecurringGroup {
  pattern: string;
  sessions: Session[];
  studentName: string;
  trainerName: string;
  source: 'Favale' | 'Pink' | 'FavalePink';
  location: string;
  timeSlot: string;
  nextSession?: Session;
}

interface GroupedSessions {
  recurring: RecurringGroup[];
  individual: Session[];
}

/**
 * Detecta se um conjunto de sessões forma um padrão recorrente
 */
function detectRecurrencePattern(sessions: Session[]): string | null {
  if (sessions.length < 3) return null;

  const sortedSessions = sessions.sort((a, b) => 
    new Date(a.startTime).getTime() - new Date(b.startTime).getTime()
  );

  // Filtrar apenas sessões recentes (últimos 6 meses) para evitar interferência de dados antigos
  const sixMonthsAgo = new Date();
  sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
  
  const recentSessions = sortedSessions.filter(session => 
    new Date(session.startTime) >= sixMonthsAgo
  );

  if (recentSessions.length < 3) return null;

  // Verificar padrão semanal
  const weeklyIntervals = [];
  for (let i = 1; i < recentSessions.length; i++) {
    const daysDiff = differenceInDays(
      new Date(recentSessions[i].startTime),
      new Date(recentSessions[i - 1].startTime)
    );
    weeklyIntervals.push(daysDiff);
  }

  // Se a maioria dos intervalos são de 7 dias (±2 dias de tolerância)
  const weeklyCount = weeklyIntervals.filter(diff => Math.abs(diff - 7) <= 2).length;
  if (weeklyCount >= weeklyIntervals.length * 0.6) {
    const dayOfWeek = format(new Date(recentSessions[0].startTime), 'EEEE', { locale: ptBR });
    return `Toda ${dayOfWeek}`;
  }

  // Verificar padrão quinzenal
  const biweeklyCount = weeklyIntervals.filter(diff => Math.abs(diff - 14) <= 3).length;
  if (biweeklyCount >= weeklyIntervals.length * 0.6) {
    const dayOfWeek = format(new Date(recentSessions[0].startTime), 'EEEE', { locale: ptBR });
    return `A cada 15 dias (${dayOfWeek})`;
  }

  // Verificar padrão mensal (aproximadamente 30 dias)
  const monthlyCount = weeklyIntervals.filter(diff => Math.abs(diff - 30) <= 7).length;
  if (monthlyCount >= weeklyIntervals.length * 0.6) {
    return 'Mensalmente';
  }

  return null;
}

/**
 * Agrupa sessões similares (mesmo aluno, professor, horário, local)
 */
function groupSimilarSessions(sessions: Session[]): Session[][] {
  const groups: Session[][] = [];

  for (const session of sessions) {
    const timeSlot = `${format(new Date(session.startTime), 'HH:mm')} - ${format(new Date(session.endTime), 'HH:mm')}`;
    
    // Procurar grupo existente com características similares
    const existingGroup = groups.find(group => {
      if (group.length === 0) return false;
      
      const firstSession = group[0];
      const firstTimeSlot = `${format(new Date(firstSession.startTime), 'HH:mm')} - ${format(new Date(firstSession.endTime), 'HH:mm')}`;
      
      return (
        firstSession.leadId === session.leadId &&
        firstSession.trainerId === session.trainerId &&
        firstSession.location === session.location &&
        firstSession.source === session.source &&
        firstTimeSlot === timeSlot
      );
    });

    if (existingGroup) {
      existingGroup.push(session);
    } else {
      groups.push([session]);
    }
  }

  return groups;
}

/**
 * Agrupa sessões em recorrentes e individuais
 */
export function groupSessions(
  sessions: Session[],
  getStudentName: (leadId: number) => string,
  getTrainerName: (trainerId: number) => string
): GroupedSessions {
  const recurring: RecurringGroup[] = [];
  let individualSessions: Session[] = [];

  // Group by recurrenceGroupId
  const recurrenceGroups = new Map<string, Session[]>();
  
  for (const session of sessions) {
    if (session.recurrenceGroupId && session.recurrenceType !== 'none') {
      if (!recurrenceGroups.has(session.recurrenceGroupId)) {
        recurrenceGroups.set(session.recurrenceGroupId, []);
      }
      recurrenceGroups.get(session.recurrenceGroupId)!.push(session);
    } else {
      individualSessions.push(session);
    }
  }

  // Create recurring groups from recurrence groups
  Array.from(recurrenceGroups.entries()).forEach(([groupId, groupSessions]) => {
    if (groupSessions.length > 1) {
      const sortedSessions = groupSessions.sort((a: Session, b: Session) => 
        new Date(a.startTime).getTime() - new Date(b.startTime).getTime()
      );

      const firstSession = sortedSessions[0];
      const timeSlot = `${format(new Date(firstSession.startTime), 'HH:mm')} - ${format(new Date(firstSession.endTime), 'HH:mm')}`;
      
      // Generate pattern based on recurrence type
      let pattern = '';
      switch (firstSession.recurrenceType) {
        case 'daily':
          pattern = 'Diariamente';
          break;
        case 'weekly':
          const dayOfWeek = format(new Date(firstSession.startTime), 'EEEE', { locale: ptBR });
          pattern = `Toda ${dayOfWeek}`;
          break;
        case 'monthly':
          pattern = 'Mensalmente';
          break;
        case 'yearly':
          pattern = 'Anualmente';
          break;
        default:
          pattern = 'Recorrente';
      }
      
      const recurringGroup: RecurringGroup = {
        pattern,
        sessions: sortedSessions,
        studentName: getStudentName(firstSession.leadId),
        trainerName: getTrainerName(firstSession.trainerId),
        source: firstSession.source,
        location: firstSession.location,
        timeSlot,
        nextSession: sortedSessions
          .filter((s: Session) => new Date(s.startTime) > new Date() && s.status === 'scheduled')
          .sort((a: Session, b: Session) => new Date(a.startTime).getTime() - new Date(b.startTime).getTime())[0]
      };

      recurring.push(recurringGroup);
    } else {
      individualSessions.push(...groupSessions);
    }
  });

  // For sessions without recurrence data, try to detect patterns (legacy support)
  const unGroupedSessions = individualSessions.filter(s => !s.recurrenceGroupId);
  const sessionGroups = groupSimilarSessions(unGroupedSessions);
  const finalIndividual = individualSessions.filter(s => s.recurrenceGroupId);

  for (const group of sessionGroups) {
    if (group.length >= 3) {
      const pattern = detectRecurrencePattern(group);
      
      if (pattern) {
        const firstSession = group[0];
        const timeSlot = `${format(new Date(firstSession.startTime), 'HH:mm')} - ${format(new Date(firstSession.endTime), 'HH:mm')}`;
        
        const recurringGroup: RecurringGroup = {
          pattern,
          sessions: group,
          studentName: getStudentName(firstSession.leadId),
          trainerName: getTrainerName(firstSession.trainerId),
          source: firstSession.source,
          location: firstSession.location,
          timeSlot,
          nextSession: group
            .filter(s => new Date(s.startTime) > new Date() && s.status === 'scheduled')
            .sort((a, b) => new Date(a.startTime).getTime() - new Date(b.startTime).getTime())[0]
        };
        
        recurring.push(recurringGroup);
      } else {
        finalIndividual.push(...group);
      }
    } else {
      finalIndividual.push(...group);
    }
  }

  return { recurring, individual: finalIndividual };
}

/**
 * Obtém estatísticas de um grupo recorrente
 */
export function getRecurringGroupStats(group: RecurringGroup) {
  const upcoming = group.sessions.filter(s => 
    new Date(s.startTime) > new Date() && s.status === 'scheduled'
  ).length;

  const completed = group.sessions.filter(s => 
    s.status === 'completed'
  ).length;

  const cancelled = group.sessions.filter(s => 
    s.status === 'cancelled'
  ).length;

  const noShow = group.sessions.filter(s => 
    s.status === 'no-show'
  ).length;

  return {
    total: group.sessions.length,
    upcoming,
    completed,
    cancelled,
    noShow,
    completionRate: group.sessions.length > 0 ? (completed / group.sessions.length) * 100 : 0
  };
}
</file>

<file path="components.json">
{
    "$schema": "https://ui.shadcn.com/schema.json",
    "style": "new-york",
    "rsc": false,
    "tsx": true,
    "tailwind": {
      "config": "tailwind.config.ts",
      "css": "client/src/index.css",
      "baseColor": "neutral",
      "cssVariables": true,
      "prefix": ""
    },
    "aliases": {
      "components": "@/components",
      "utils": "@/lib/utils",
      "ui": "@/components/ui",
      "lib": "@/lib",
      "hooks": "@/hooks"
    }
}
</file>

<file path="create-tables.js">
import pg from 'pg';
import dotenv from 'dotenv';

const { Pool } = pg;
dotenv.config();

async function createTables() {
  const pool = new Pool({
    connectionString: process.env.DATABASE_URL,
  });

  try {
    console.log('Conectando ao banco de dados PostgreSQL...');
    
    console.log('Criando tabelas se elas não existirem...');

    // Usar SQL direto para criar tabelas na ordem correta
    await pool.query(`
      -- Tabela de usuários
      CREATE TABLE IF NOT EXISTS users (
        id SERIAL PRIMARY KEY,
        username TEXT NOT NULL UNIQUE,
        password TEXT NOT NULL,
        role TEXT NOT NULL DEFAULT 'user'
      );

      -- Tabela de leads
      CREATE TABLE IF NOT EXISTS leads (
        id SERIAL PRIMARY KEY,
        entry_date TIMESTAMP NOT NULL DEFAULT NOW(),
        name TEXT NOT NULL,
        email TEXT NOT NULL,
        phone TEXT NOT NULL,
        state TEXT NOT NULL,
        campaign TEXT NOT NULL,
        tags TEXT[] NOT NULL,
        source TEXT NOT NULL,
        status TEXT NOT NULL,
        notes TEXT,
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP NOT NULL DEFAULT NOW()
      );

      -- Tabela de treinadores
      CREATE TABLE IF NOT EXISTS trainers (
        id SERIAL PRIMARY KEY,
        name TEXT NOT NULL,
        email TEXT NOT NULL UNIQUE,
        phone TEXT,
        specialties TEXT[],
        calendar_id TEXT,
        active BOOLEAN NOT NULL DEFAULT TRUE,
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP NOT NULL DEFAULT NOW()
      );

      -- Tabela de alunos
      CREATE TABLE IF NOT EXISTS students (
        id SERIAL PRIMARY KEY,
        lead_id INTEGER REFERENCES leads(id),
        address TEXT,
        preferences TEXT,
        source TEXT NOT NULL,
        active BOOLEAN NOT NULL DEFAULT TRUE,
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP NOT NULL DEFAULT NOW()
      );

      -- Tabela de sessões
      CREATE TABLE IF NOT EXISTS sessions (
        id SERIAL PRIMARY KEY,
        start_time TIMESTAMP NOT NULL,
        end_time TIMESTAMP NOT NULL,
        student_id INTEGER NOT NULL REFERENCES students(id),
        trainer_id INTEGER NOT NULL REFERENCES trainers(id),
        location TEXT NOT NULL,
        notes TEXT,
        status TEXT NOT NULL DEFAULT 'agendado',
        source TEXT NOT NULL,
        google_event_id TEXT,
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP NOT NULL DEFAULT NOW()
      );

      -- Tabela de histórico de sessões
      CREATE TABLE IF NOT EXISTS session_history (
        id SERIAL PRIMARY KEY,
        session_id INTEGER NOT NULL REFERENCES sessions(id),
        changed_at TIMESTAMP NOT NULL DEFAULT NOW(),
        change_type TEXT NOT NULL,
        user_id INTEGER NOT NULL REFERENCES users(id),
        old_value JSONB,
        new_value JSONB
      );

      -- Tabela de mensagens WhatsApp
      CREATE TABLE IF NOT EXISTS whatsapp_messages (
        id SERIAL PRIMARY KEY,
        lead_id INTEGER NOT NULL REFERENCES leads(id),
        direction TEXT NOT NULL,
        content TEXT NOT NULL,
        status TEXT NOT NULL,
        timestamp TIMESTAMP NOT NULL DEFAULT NOW(),
        media_url TEXT,
        media_type TEXT,
        message_id TEXT
      );

      -- Tabela de tarefas
      CREATE TABLE IF NOT EXISTS tasks (
        id SERIAL PRIMARY KEY,
        title TEXT NOT NULL,
        description TEXT,
        assigned_by_id INTEGER NOT NULL REFERENCES users(id),
        assigned_to_id INTEGER NOT NULL REFERENCES users(id),
        due_date TIMESTAMP,
        priority TEXT NOT NULL DEFAULT 'medium',
        status TEXT NOT NULL DEFAULT 'pending',
        related_lead_id INTEGER REFERENCES leads(id),
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP NOT NULL DEFAULT NOW()
      );

      -- Tabela de comentários em tarefas
      CREATE TABLE IF NOT EXISTS task_comments (
        id SERIAL PRIMARY KEY,
        task_id INTEGER NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
        user_id INTEGER NOT NULL REFERENCES users(id),
        content TEXT NOT NULL,
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP NOT NULL DEFAULT NOW()
      );

      -- Tabela de configurações do WhatsApp/Evolution API
      CREATE TABLE IF NOT EXISTS whatsapp_settings (
        id SERIAL PRIMARY KEY,
        api_url TEXT NOT NULL,
        api_token TEXT NOT NULL,
        api_instance TEXT NOT NULL,
        updated_at TIMESTAMP NOT NULL DEFAULT NOW()
      );
    `);

    console.log('Tabelas criadas com sucesso!');

    // Criar um usuário administrador padrão se não existir
    await pool.query(`
      INSERT INTO users (username, password, role)
      SELECT 'admin', '6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b.d16fb36f027d1f03df5b55c19a97f5348270210146e38d0c657a683b3d774732', 'admin'
      WHERE NOT EXISTS (SELECT 1 FROM users WHERE username = 'admin')
    `);

    console.log('Usuário admin criado com sucesso!');
  } catch (error) {
    console.error('Erro ao criar tabelas:', error);
  } finally {
    await pool.end();
  }
}

createTables();
</file>

<file path="drizzle.config.ts">
import { defineConfig } from "drizzle-kit";

if (!process.env.DATABASE_URL) {
  throw new Error("DATABASE_URL, ensure the database is provisioned");
}

export default defineConfig({
  out: "./migrations",
  schema: "./shared/schema.ts",
  dialect: "postgresql",
  dbCredentials: {
    url: process.env.DATABASE_URL,
  },
});
</file>

<file path="GEMINI.MD">
# FavaleTrainerCRM

## Visão Geral do Projeto

O FavaleTrainerCRM é um sistema de CRM (Customer Relationship Management) desenvolvido para auxiliar personal trainers e academias na gestão de seus clientes, agendamentos, leads e outras atividades relacionadas. Ele oferece uma interface de usuário intuitiva construída com React e um backend robusto em Node.js com Express, utilizando PostgreSQL como banco de dados.

## Tecnologias Utilizadas

*   **Frontend:**
    *   React
    *   TypeScript
    *   Vite (para build)
    *   Tailwind CSS (para estilização)
    *   Shadcn/ui (componentes de UI)
    *   React Query (gerenciamento de estado assíncrono)
    *   Wouter (roteamento)
*   **Backend:**
    *   Node.js
    *   Express.js
    *   TypeScript
    *   Drizzle ORM (para interação com o banco de dados)
    *   PostgreSQL (banco de dados, via Supabase)
    *   Passport.js (autenticação)
    *   Google Calendar API (integração de calendário)
    *   SendGrid (serviço de e-mail)
    *   OpenWeather API (serviço de clima)
*   **Outras:**
    *   Drizzle Kit (migrações de banco de dados)
    *   ESBuild (para build do backend)
    *   Cross-env (para variáveis de ambiente)

## Configuração do Ambiente

Antes de iniciar o projeto, você precisará configurar as variáveis de ambiente. Crie um arquivo `.env` na raiz do projeto (na mesma pasta que o `package.json`) e preencha-o com as informações necessárias, baseando-se no arquivo `.env.example`:

```
# Database Configuration (Required)
DATABASE_URL=postgresql://username:password@host:port/database_name

# Server Configuration
NODE_ENV=development
PORT=5000
HOST=0.0.0.0

# CORS Configuration
CORS_ORIGINS=http://localhost:5173,http://127.0.0.1:5173

# Logging Configuration
LOG_LEVEL=info

# Health Check Configuration
HEALTH_CHECK_PATH=/health
SHUTDOWN_TIMEOUT=30000

# WhatsApp Integration (Optional)
EVOLUTION_API_URL=
EVOLUTION_API_TOKEN=
EVOLUTION_API_INSTANCE=

# Email Service (Optional)
SENDGRID_API_KEY=

# Google Calendar Integration (Optional)
GOOGLE_CLIENT_ID=
GOOGLE_CLIENT_SECRET=

# Weather Service (Optional)
OPENWEATHER_API_KEY=

# Session Configuration
SESSION_SECRET=your_secret_key_for_sessions
```

**Observações:**

*   `DATABASE_URL`: Essencial para a conexão com o banco de dados PostgreSQL do Supabase. Certifique-se de que o banco de dados esteja provisionado e acessível.
*   `CORS_ORIGINS`: Se você estiver rodando o frontend em uma porta diferente, adicione a URL aqui. Para desenvolvimento local, `http://localhost:5173` e `http://127.0.0.1:5173` são comuns.
*   As variáveis de integração (WhatsApp, Email, Google Calendar, Weather) são opcionais. Se você não for utilizá-las, pode deixá-las em branco ou removê-las.
*   `SESSION_SECRET`: Uma chave secreta forte é crucial para a segurança das sessões.

## Instalação

Para instalar as dependências do projeto, execute o seguinte comando na raiz do projeto:

```bash
npm install
```

## Banco de Dados

Este projeto utiliza Drizzle ORM para gerenciar o banco de dados PostgreSQL.

### Migrações

Após configurar o `DATABASE_URL` no seu arquivo `.env`, você pode aplicar as migrações do banco de dados com o seguinte comando:

```bash
npm run db:push
```

Este comando sincronizará seu esquema de banco de dados com o definido em `shared/schema.ts`.

## Execução do Projeto

### Modo de Desenvolvimento

Para iniciar o servidor de desenvolvimento (backend e frontend), execute:

```bash
npm run dev
```

Este comando iniciará o servidor backend com `tsx` e o servidor de desenvolvimento do Vite para o frontend. O frontend geralmente estará disponível em `http://localhost:5173` e o backend em `http://localhost:5000` (ou a porta configurada no `.env`).

### Modo de Produção

Para construir e iniciar o projeto em modo de produção:

1.  **Construir o Projeto:**
    ```bash
    npm run build
    ```
    Este comando irá compilar o frontend com Vite e o backend com ESBuild, gerando os arquivos otimizados na pasta `dist`.

2.  **Iniciar o Servidor de Produção:**
    ```bash
    npm run start
    ```
    Este comando iniciará o servidor Node.js a partir dos arquivos compilados na pasta `dist`.

## Estrutura de Pastas

*   `client/`: Contém todo o código-fonte do frontend (aplicação React).
    *   `client/src/components/`: Componentes reutilizáveis do React.
    *   `client/src/pages/`: Páginas principais da aplicação.
    *   `client/src/services/`: Serviços para comunicação com a API.
    *   `client/src/hooks/`: Hooks personalizados do React.
    *   `client/src/context/`: Contextos React para gerenciamento de estado global.
    *   `client/src/lib/`: Utilitários e configurações.
    *   `client/src/assets/`: Ativos estáticos (imagens, etc.).
*   `server/`: Contém todo o código-fonte do backend (aplicação Express).
    *   `server/controllers/`: Lógica de negócio e manipulação de requisições.
    *   `server/routes/`: Definição das rotas da API.
    *   `server/middlewares/`: Middlewares do Express.
    *   `server/utils/`: Funções utilitárias do backend.
    *   `server/migrations/`: Arquivos de migração do Drizzle.
*   `shared/`: Contém código compartilhado entre frontend e backend, como definições de esquema (Drizzle).
*   `drizzle.config.ts`: Configuração do Drizzle ORM.
*   `package.json`: Metadados do projeto e scripts.
*   `tsconfig.json`: Configuração do TypeScript.
*   `vite.config.ts`: Configuração do Vite.
*   `postcss.config.js`, `tailwind.config.ts`: Configurações de estilização.
</file>

<file path="generate-password.js">
import crypto from 'crypto';
import { promisify } from 'util';

const scryptAsync = promisify(crypto.scrypt);

async function hashPassword(password) {
  const salt = crypto.randomBytes(16).toString("hex");
  const buf = await scryptAsync(password, salt, 64);
  return `${buf.toString("hex")}.${salt}`;
}

async function main() {
  const hashedPassword = await hashPassword('password123');
  console.log('Senha criptografada:', hashedPassword);
}

main().catch(console.error);
</file>

<file path="migrate-db.js">
// Script para criar tabelas no banco de dados PostgreSQL
import 'dotenv/config';
import { drizzle } from 'drizzle-orm/postgres-js';
import postgres from 'postgres';

async function main() {
  if (!process.env.DATABASE_URL) {
    throw new Error('DATABASE_URL não foi configurado. Verifique suas variáveis de ambiente.');
  }

  console.log('Conectando ao banco de dados PostgreSQL...');
  const sql = postgres(process.env.DATABASE_URL, { prepare: false });
  const db = drizzle(sql);

  console.log('Criando tabelas se elas não existirem...');

  // Criar tabelas uma por uma
  await sql`
    CREATE TABLE IF NOT EXISTS users (
      id SERIAL PRIMARY KEY,
      username TEXT NOT NULL UNIQUE,
      password TEXT NOT NULL,
      role TEXT NOT NULL DEFAULT 'user'
    )
  `;

  await sql`
    CREATE TABLE IF NOT EXISTS leads (
      id SERIAL PRIMARY KEY,
      entry_date TIMESTAMP NOT NULL DEFAULT NOW(),
      name TEXT NOT NULL,
      email TEXT NOT NULL,
      phone TEXT NOT NULL,
      state TEXT NOT NULL,
      campaign TEXT NOT NULL,
      tags TEXT[] NOT NULL,
      source TEXT NOT NULL,
      status TEXT NOT NULL,
      notes TEXT,
      created_at TIMESTAMP NOT NULL DEFAULT NOW(),
      updated_at TIMESTAMP NOT NULL DEFAULT NOW()
    )
  `;

  await sql`
    CREATE TABLE IF NOT EXISTS trainers (
      id SERIAL PRIMARY KEY,
      name TEXT NOT NULL,
      email TEXT NOT NULL UNIQUE,
      phone TEXT,
      specialties TEXT[],
      calendar_id TEXT,
      active BOOLEAN NOT NULL DEFAULT TRUE,
      created_at TIMESTAMP NOT NULL DEFAULT NOW(),
      updated_at TIMESTAMP NOT NULL DEFAULT NOW()
    )
  `;

  await sql`
    CREATE TABLE IF NOT EXISTS students (
      id SERIAL PRIMARY KEY,
      lead_id INTEGER REFERENCES leads(id),
      address TEXT,
      preferences TEXT,
      source TEXT NOT NULL,
      active BOOLEAN NOT NULL DEFAULT TRUE,
      created_at TIMESTAMP NOT NULL DEFAULT NOW(),
      updated_at TIMESTAMP NOT NULL DEFAULT NOW()
    )
  `;

  await sql`
    CREATE TABLE IF NOT EXISTS sessions (
      id SERIAL PRIMARY KEY,
      start_time TIMESTAMP NOT NULL,
      end_time TIMESTAMP NOT NULL,
      student_id INTEGER NOT NULL REFERENCES students(id),
      trainer_id INTEGER NOT NULL REFERENCES trainers(id),
      location TEXT NOT NULL,
      notes TEXT,
      status TEXT NOT NULL DEFAULT 'agendado',
      source TEXT NOT NULL,
      google_event_id TEXT,
      created_at TIMESTAMP NOT NULL DEFAULT NOW(),
      updated_at TIMESTAMP NOT NULL DEFAULT NOW()
    )
  `;

  await sql`
    CREATE TABLE IF NOT EXISTS session_history (
      id SERIAL PRIMARY KEY,
      session_id INTEGER NOT NULL REFERENCES sessions(id),
      changed_at TIMESTAMP NOT NULL DEFAULT NOW(),
      change_type TEXT NOT NULL,
      user_id INTEGER NOT NULL REFERENCES users(id),
      old_value JSONB,
      new_value JSONB
    )
  `;

  await sql`
    CREATE TABLE IF NOT EXISTS whatsapp_messages (
      id SERIAL PRIMARY KEY,
      lead_id INTEGER NOT NULL REFERENCES leads(id),
      direction TEXT NOT NULL,
      content TEXT NOT NULL,
      status TEXT NOT NULL,
      timestamp TIMESTAMP NOT NULL DEFAULT NOW(),
      media_url TEXT,
      media_type TEXT,
      message_id TEXT
    )
  `;

  await sql`
    CREATE TABLE IF NOT EXISTS tasks (
      id SERIAL PRIMARY KEY,
      title TEXT NOT NULL,
      description TEXT,
      assigned_by_id INTEGER NOT NULL REFERENCES users(id),
      assigned_to_id INTEGER NOT NULL REFERENCES users(id),
      due_date TIMESTAMP,
      priority TEXT NOT NULL DEFAULT 'medium',
      status TEXT NOT NULL DEFAULT 'pending',
      related_lead_id INTEGER REFERENCES leads(id),
      created_at TIMESTAMP NOT NULL DEFAULT NOW(),
      updated_at TIMESTAMP NOT NULL DEFAULT NOW()
    )
  `;

  await sql`
    CREATE TABLE IF NOT EXISTS task_comments (
      id SERIAL PRIMARY KEY,
      task_id INTEGER NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
      user_id INTEGER NOT NULL REFERENCES users(id),
      content TEXT NOT NULL,
      created_at TIMESTAMP NOT NULL DEFAULT NOW(),
      updated_at TIMESTAMP NOT NULL DEFAULT NOW()
    )
  `;

  await sql`
    CREATE TABLE IF NOT EXISTS http_sessions (
      sid TEXT PRIMARY KEY,
      sess JSONB NOT NULL,
      expire TIMESTAMP NOT NULL
    )
  `;

  console.log('Tabelas criadas com sucesso!');

  // Criar usuário Leonardo com senha 123asdfg se não existir
  await sql`
    INSERT INTO users (username, password, role)
    SELECT 'leonardo', 'd8a1ba6da5274e42f686b9ca511599c57f38bbdda19d1e59514bafaaf779e139beb243c2e844e196ba9135c11ec0bfb9162ef7f6470200cb46640f4c2191625c5.b8ea39c3adccd231fecf045cefd1678f0', 'admin'
    WHERE NOT EXISTS (SELECT 1 FROM users WHERE username = 'leonardo')
  `;

  console.log('Usuário Leonardo criado com sucesso!');

  await sql.end();
}

main().catch(error => {
  console.error('Erro ao migrar tabelas:', error);
  process.exit(1);
});
</file>

<file path="package.json">
{
  "name": "rest-express",
  "version": "1.0.0",
  "type": "module",
  "license": "MIT",
  "scripts": {
    "dev": "cross-env NODE_ENV=development tsx server/index.ts",
    "build": "vite build && esbuild server/index.ts --platform=node --packages=external --bundle --format=esm --outdir=dist",
    "start": "cross-env NODE_ENV=production node dist/index.js",
    "check": "tsc",
    "db:push": "drizzle-kit push"
  },
  "dependencies": {
    "@googleapis/calendar": "^9.8.0",
    "@hookform/resolvers": "^3.10.0",
    "@jridgewell/trace-mapping": "^0.3.25",
    "@radix-ui/react-accordion": "^1.2.4",
    "@radix-ui/react-alert-dialog": "^1.1.7",
    "@radix-ui/react-aspect-ratio": "^1.1.3",
    "@radix-ui/react-avatar": "^1.1.4",
    "@radix-ui/react-checkbox": "^1.1.5",
    "@radix-ui/react-collapsible": "^1.1.11",
    "@radix-ui/react-context-menu": "^2.2.7",
    "@radix-ui/react-dialog": "^1.1.7",
    "@radix-ui/react-dropdown-menu": "^2.1.7",
    "@radix-ui/react-hover-card": "^1.1.7",
    "@radix-ui/react-label": "^2.1.3",
    "@radix-ui/react-menubar": "^1.1.7",
    "@radix-ui/react-navigation-menu": "^1.2.6",
    "@radix-ui/react-popover": "^1.1.7",
    "@radix-ui/react-progress": "^1.1.3",
    "@radix-ui/react-radio-group": "^1.2.4",
    "@radix-ui/react-scroll-area": "^1.2.4",
    "@radix-ui/react-select": "^2.1.7",
    "@radix-ui/react-separator": "^1.1.3",
    "@radix-ui/react-slider": "^1.2.4",
    "@radix-ui/react-slot": "^1.2.0",
    "@radix-ui/react-switch": "^1.1.4",
    "@radix-ui/react-tabs": "^1.1.4",
    "@radix-ui/react-toast": "^1.2.7",
    "@radix-ui/react-toggle": "^1.1.3",
    "@radix-ui/react-toggle-group": "^1.1.3",
    "@radix-ui/react-tooltip": "^1.2.0",
    "@sendgrid/mail": "^8.1.5",
    "@supabase/supabase-js": "^2.50.2",
    "@tailwindcss/vite": "^4.1.3",
    "@tanstack/react-query": "^5.60.5",
    "@types/react-big-calendar": "^1.16.2",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.1.1",
    "connect-pg-simple": "^10.0.0",
    "crypto": "^1.0.1",
    "date-fns": "^3.6.0",
    "date-fns-tz": "^3.2.0",
    "dotenv": "^16.5.0",
    "drizzle-orm": "^0.39.1",
    "drizzle-zod": "^0.7.0",
    "embla-carousel-react": "^8.6.0",
    "express": "^4.21.2",
    "express-session": "^1.18.1",
    "framer-motion": "^11.13.1",
    "input-otp": "^1.4.2",
    "lucide-react": "^0.453.0",
    "memorystore": "^1.6.7",
    "next-themes": "^0.4.6",
    "nodemailer": "^7.0.0",
    "passport": "^0.7.0",
    "passport-local": "^1.0.0",
    "postgres": "^3.4.7",
    "react": "^18.3.1",
    "react-beautiful-dnd": "^13.1.1",
    "react-big-calendar": "^1.19.4",
    "react-day-picker": "^8.10.1",
    "react-dom": "^18.3.1",
    "react-hook-form": "^7.56.1",
    "react-icons": "^5.4.0",
    "react-markdown": "^10.1.0",
    "react-resizable-panels": "^2.1.7",
    "recharts": "^2.15.3",
    "rehype-highlight": "^7.0.2",
    "repomix": "^0.3.9",
    "tailwind-merge": "^2.6.0",
    "tailwindcss-animate": "^1.0.7",
    "tw-animate-css": "^1.2.5",
    "vaul": "^1.1.2",
    "wouter": "^3.3.5",
    "ws": "^8.18.0",
    "zod": "^3.24.3",
    "zod-validation-error": "^3.4.0"
  },
  "devDependencies": {
    "@replit/vite-plugin-cartographer": "^0.2.7",
    "@replit/vite-plugin-runtime-error-modal": "^0.0.3",
    "@tailwindcss/typography": "^0.5.15",
    "@types/connect-pg-simple": "^7.0.3",
    "@types/express": "4.17.21",
    "@types/express-session": "^1.18.0",
    "@types/node": "20.16.11",
    "@types/passport": "^1.0.16",
    "@types/passport-local": "^1.0.38",
    "@types/react": "^18.3.11",
    "@types/react-beautiful-dnd": "^13.1.8",
    "@types/react-dom": "^18.3.1",
    "@types/ws": "^8.5.13",
    "@vitejs/plugin-react": "^4.3.2",
    "autoprefixer": "^10.4.20",
    "cross-env": "^7.0.3",
    "drizzle-kit": "^0.30.4",
    "esbuild": "^0.25.0",
    "postcss": "^8.4.47",
    "tailwindcss": "^3.4.17",
    "tsx": "^4.19.1",
    "typescript": "5.6.3",
    "vite": "^5.4.14"
  },
  "optionalDependencies": {
    "bufferutil": "^4.0.8"
  }
}
</file>

<file path="postcss.config.js">
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="seed-trainers.js">
import pkg from 'pg';
const { Pool } = pkg;

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
});

async function seedTrainers() {
  try {
    console.log('🌱 Iniciando seed dos professores...');

    // Professores Favale
    const favaleTrainers = [
      { name: 'André Silva', email: 'andre.silva@favale.com' },
      { name: 'Matheus Barbosa', email: 'matheus.barbosa@favale.com' },
      { name: 'Marcus', email: 'marcus@favale.com' },
      { name: 'Marcos', email: 'marcos@favale.com' },
      { name: 'Marco Soares', email: 'marco.soares@favale.com' },
      { name: 'Marco', email: 'marco@favale.com' },
      { name: 'Lucia Silva', email: 'lucia.silva@favale.com' },
      { name: 'Juliana', email: 'juliana@favale.com' },
      { name: 'Wagner', email: 'wagner@favale.com' },
      { name: 'Gabriel', email: 'gabriel@favale.com' },
      { name: 'Douglas', email: 'douglas@favale.com' },
      { name: 'Caio', email: 'caio@favale.com' }
    ];

    // Professores Pink
    const pinkTrainers = [
      { name: 'Thais', email: 'thais@pink.com' },
      { name: 'Thaina Caputt', email: 'thaina.caputt@pink.com' },
      { name: 'Tayna', email: 'tayna@pink.com' },
      { name: 'Silvia Regina', email: 'silvia.regina@pink.com' },
      { name: 'Samara', email: 'samara@pink.com' },
      { name: 'Alessandra', email: 'alessandra@pink.com' },
      { name: 'Fayola', email: 'fayola@pink.com' },
      { name: 'Erika Pontes', email: 'erika.pontes@pink.com' },
      { name: 'Erika', email: 'erika@pink.com' },
      { name: 'Dart', email: 'dart@pink.com' },
      { name: 'Michelle', email: 'michelle@pink.com' },
      { name: 'Melissa Santana', email: 'melissa.santana@pink.com' },
      { name: 'Cassia', email: 'cassia@pink.com' }
    ];

    // Inserir professores Favale
    for (const trainer of favaleTrainers) {
      const result = await pool.query(
        `INSERT INTO trainers (name, email, source, active, specialties, phone) 
         VALUES ($1, $2, 'Favale', true, ARRAY['Personal Training', 'Musculação'], '+55 11 99999-0000')
         ON CONFLICT (email) DO NOTHING
         RETURNING id`,
        [trainer.name, trainer.email]
      );
      if (result.rows.length > 0) {
        console.log(`✅ Professor Favale criado: ${trainer.name} (ID: ${result.rows[0].id})`);
      } else {
        console.log(`⚠️ Professor Favale já existe: ${trainer.name}`);
      }
    }

    // Inserir professores Pink
    for (const trainer of pinkTrainers) {
      const result = await pool.query(
        `INSERT INTO trainers (name, email, source, active, specialties, phone) 
         VALUES ($1, $2, 'Pink', true, ARRAY['Personal Training', 'Pilates'], '+55 11 99999-0001')
         ON CONFLICT (email) DO NOTHING
         RETURNING id`,
        [trainer.name, trainer.email]
      );
      if (result.rows.length > 0) {
        console.log(`✅ Professor Pink criado: ${trainer.name} (ID: ${result.rows[0].id})`);
      } else {
        console.log(`⚠️ Professor Pink já existe: ${trainer.name}`);
      }
    }

    console.log('🎉 Seed dos professores concluído com sucesso!');
  } catch (error) {
    console.error('❌ Erro no seed dos professores:', error);
    throw error;
  } finally {
    await pool.end();
  }
}

seedTrainers().catch(console.error);
</file>

<file path="seed.js">
import { db } from './server/db.js';
import { leads } from './shared/schema.js';

async function seedDatabase() {
  console.log('Seeding database with test data...');
  
  // Sample leads data
  const testLeads = [
    {
      entryDate: new Date('2023-01-15'),
      name: 'Ana Silva',
      email: 'ana.silva@example.com',
      phone: '(11) 98765-4321',
      state: 'SP',
      campaign: 'Instagram',
      tags: ['Interessado', 'Emagrecimento'],
      source: 'Favale',
      status: 'Lead',
      notes: 'Interessada em perder peso',
      createdAt: new Date(),
      updatedAt: new Date()
    },
    {
      entryDate: new Date('2023-02-10'),
      name: 'Bruno Santos',
      email: 'bruno.santos@example.com',
      phone: '(21) 99876-5432',
      state: 'RJ',
      campaign: 'Facebook',
      tags: ['Hipertrofia', 'Suplementação'],
      source: 'Pink',
      status: 'Lead',
      notes: 'Quer ganhar massa muscular',
      createdAt: new Date(),
      updatedAt: new Date()
    },
    {
      entryDate: new Date('2023-03-05'),
      name: 'Carolina Oliveira',
      email: 'carol.oliveira@example.com',
      phone: '(31) 97654-3210',
      state: 'MG',
      campaign: 'Indicação',
      tags: ['Reabilitação', 'Personalizado'],
      source: 'Favale',
      status: 'Aluno',
      notes: 'Em recuperação de lesão no joelho',
      createdAt: new Date(),
      updatedAt: new Date()
    },
    {
      entryDate: new Date('2023-04-20'),
      name: 'Daniel Lima',
      email: 'daniel.lima@example.com',
      phone: '(41) 98765-1234',
      state: 'PR',
      campaign: 'Site',
      tags: ['Iniciante', 'Emagrecimento'],
      source: 'Pink',
      status: 'Aluno',
      notes: 'Nunca treinou antes',
      createdAt: new Date(),
      updatedAt: new Date()
    },
    {
      entryDate: new Date('2023-05-15'),
      name: 'Fernanda Souza',
      email: 'fernanda.souza@example.com',
      phone: '(51) 99876-5678',
      state: 'RS',
      campaign: 'Email',
      tags: ['Preparação', 'Competição'],
      source: 'Favale',
      status: 'Lead',
      notes: 'Interessada em preparação para competição',
      createdAt: new Date(),
      updatedAt: new Date()
    },
    {
      entryDate: new Date('2023-06-10'),
      name: 'Gabriel Costa',
      email: 'gabriel.costa@example.com',
      phone: '(71) 98765-9876',
      state: 'BA',
      campaign: 'Instagram',
      tags: ['Fitness', 'Nutrição'],
      source: 'Pink',
      status: 'Lead',
      notes: 'Quer melhorar condicionamento físico',
      createdAt: new Date(),
      updatedAt: new Date()
    },
    {
      entryDate: new Date('2023-07-01'),
      name: 'Juliana Martins',
      email: 'juliana.martins@example.com',
      phone: '(81) 99876-4567',
      state: 'PE',
      campaign: 'Facebook',
      tags: ['Hiit', 'Emagrecimento'],
      source: 'Favale',
      status: 'Aluno',
      notes: 'Prefere treinos intensos',
      createdAt: new Date(),
      updatedAt: new Date()
    },
    {
      entryDate: new Date('2023-08-15'),
      name: 'Lucas Pereira',
      email: 'lucas.pereira@example.com',
      phone: '(85) 98765-7654',
      state: 'CE',
      campaign: 'Site',
      tags: ['Musculação', 'Nutrição'],
      source: 'Pink',
      status: 'Lead',
      notes: 'Quer orientação nutricional',
      createdAt: new Date(),
      updatedAt: new Date()
    },
    {
      entryDate: new Date('2023-09-20'),
      name: 'Mariana Castro',
      email: 'mariana.castro@example.com',
      phone: '(91) 99876-3456',
      state: 'PA',
      campaign: 'Email',
      tags: ['Pilates', 'Flexibilidade'],
      source: 'Favale',
      status: 'Aluno',
      notes: 'Focada em melhorar postura',
      createdAt: new Date(),
      updatedAt: new Date()
    },
    {
      entryDate: new Date('2023-10-10'),
      name: 'Rafael Almeida',
      email: 'rafael.almeida@example.com',
      phone: '(62) 98765-8765',
      state: 'GO',
      campaign: 'Indicação',
      tags: ['CrossFit', 'Condicionamento'],
      source: 'Pink',
      status: 'Lead',
      notes: 'Praticante de CrossFit há 2 anos',
      createdAt: new Date(),
      updatedAt: new Date()
    }
  ];

  try {
    // Inserir os leads de teste
    await db.insert(leads).values(testLeads);
    console.log('Database seeded successfully with 10 sample leads');
  } catch (error) {
    console.error('Error seeding database:', error);
  } finally {
    process.exit(0);
  }
}

seedDatabase();
</file>

<file path="server/audit-log.ts">
/**
 * Módulo de registro de auditoria para ações sensíveis
 * 
 * Este módulo fornece funções para registrar ações importantes do usuário
 * para fins de auditoria e segurança.
 */

import fs from 'fs';
import path from 'path';
import { Request } from 'express';

// Diretório para os logs
const LOG_DIR = path.join(process.cwd(), 'logs');
const AUDIT_LOG = path.join(LOG_DIR, 'audit.log');

// Certifique-se de que o diretório de logs existe
try {
  if (!fs.existsSync(LOG_DIR)) {
    fs.mkdirSync(LOG_DIR, { recursive: true });
  }
} catch (error) {
  console.error('Erro ao criar diretório de logs:', error);
}

/**
 * Tipos de eventos de auditoria
 */
export enum AuditEventType {
  LOGIN_SUCCESS = 'login_success',
  LOGIN_FAILURE = 'login_failure',
  LOGOUT = 'logout',
  USER_CREATED = 'user_created',
  USER_DELETED = 'user_deleted',
  PASSWORD_CHANGED = 'password_changed',
  LEAD_CREATED = 'lead_created',
  LEAD_UPDATED = 'lead_updated',
  LEAD_DELETED = 'lead_deleted',
  TASK_CREATED = 'task_created',
  TASK_UPDATED = 'task_updated',
  TASK_DELETED = 'task_deleted',
  SESSION_CREATED = 'session_created',
  SESSION_UPDATED = 'session_updated',
  SESSION_DELETED = 'session_deleted',
  DATA_EXPORT = 'data_export',
  SETTINGS_CHANGED = 'settings_changed',
  WHATSAPP_CONFIG_CHANGED = 'whatsapp_config_changed',
  WHATSAPP_MESSAGE_SENT = 'whatsapp_message_sent',
  OAUTH_INIT = 'oauth_init',
  OAUTH_SUCCESS = 'oauth_success',
  OAUTH_ERROR = 'oauth_error',
  OAUTH_REVOKE = 'oauth_revoke'
}

/**
 * Registra um evento de auditoria
 */
export function logAuditEvent(type: AuditEventType, req: Request, details: any = {}) {
  const timestamp = new Date().toISOString();
  const userId = req.user?.id || 'anonymous';
  const username = req.user?.username || 'anonymous';
  const ip = req.ip || req.socket.remoteAddress || 'unknown';

  // Remover informações sensíveis dos detalhes
  const sanitizedDetails = { ...details };
  if (sanitizedDetails.password) {
    sanitizedDetails.password = '[REDACTED]';
  }

  const logEntry = {
    timestamp,
    type,
    userId,
    username,
    ip,
    details: sanitizedDetails,
  };

  // Escrever no arquivo de log
  try {
    fs.appendFileSync(AUDIT_LOG, JSON.stringify(logEntry) + '\n');
  } catch (error) {
    console.error('Erro ao escrever log de auditoria:', error);
  }

  // Também registrar no console para desenvolvimento
  if (process.env.NODE_ENV !== 'production') {
    console.log(`[AUDIT] ${type} - Usuário: ${username} (${userId}) - IP: ${ip}`);
  }
}

/**
 * Obtém os logs de auditoria mais recentes
 */
export function getRecentAuditLogs(count: number = 100) {
  try {
    if (!fs.existsSync(AUDIT_LOG)) {
      return [];
    }

    const logs = fs.readFileSync(AUDIT_LOG, 'utf8')
      .split('\n')
      .filter(line => line.trim() !== '')
      .map(line => JSON.parse(line))
      .slice(-count); // Pegar apenas os últimos 'count' logs

    return logs;
  } catch (error) {
    console.error('Erro ao ler logs de auditoria:', error);
    return [];
  }
}
</file>

<file path="server/auth.ts">
import passport from "passport";
import { Strategy as LocalStrategy } from "passport-local";
import { Express, Request, Response, NextFunction } from "express";
import session from "express-session";
import { scrypt, randomBytes, timingSafeEqual } from "crypto";
import { promisify } from "util";
import { storage } from "./storage";
import { User as SelectUser } from "@shared/schema";
import { logAuditEvent, AuditEventType } from "./audit-log";

interface AuthInfo {
  message?: string;
}

declare global {
  namespace Express {
    interface User extends SelectUser {}
  }
}

const scryptAsync = promisify(scrypt);

async function hashPassword(password: string) {
  const salt = randomBytes(16).toString("hex");
  const buf = (await scryptAsync(password, salt, 64)) as Buffer;
  return `${buf.toString("hex")}.${salt}`;
}

async function comparePasswords(supplied: string, stored: string) {
  const [hashed, salt] = stored.split(".");
  const hashedBuf = Buffer.from(hashed, "hex");
  const suppliedBuf = (await scryptAsync(supplied, salt, 64)) as Buffer;
  return timingSafeEqual(hashedBuf, suppliedBuf);
}

export function setupAuth(app: Express) {
  if (!process.env.SESSION_SECRET) {
    console.warn('ATENÇÃO: SESSION_SECRET não encontrado no ambiente. Utilizando um valor padrão para desenvolvimento.');
  }
  
  const sessionSettings: session.SessionOptions = {
    secret: process.env.SESSION_SECRET || "favale-pink-secret-key",
    resave: false,
    saveUninitialized: false,
    cookie: {
      secure: process.env.NODE_ENV === "production",
      httpOnly: true, // Previne acesso ao cookie via JavaScript
      sameSite: "strict", // Proteção contra CSRF
      maxAge: 24 * 60 * 60 * 1000 // 24 hours
    },
    store: storage.sessionStore
  };

  app.set("trust proxy", 1);
  app.use(session(sessionSettings));
  app.use(passport.initialize());
  app.use(passport.session());

  passport.use(
    new LocalStrategy(async (username, password, done) => {
      try {
        const user = await storage.getUserByUsername(username);
        if (!user || !(await comparePasswords(password, user.password))) {
          return done(null, false, { message: "Credenciais inválidas" });
        } else {
          return done(null, user);
        }
      } catch (err) {
        return done(err);
      }
    }),
  );

  passport.serializeUser((user, done) => done(null, user.id));
  passport.deserializeUser(async (id: number, done) => {
    try {
      const user = await storage.getUser(id);
      done(null, user);
    } catch (err) {
      done(err);
    }
  });

  app.post("/api/register", async (req, res, next) => {
    try {
      const existingUser = await storage.getUserByUsername(req.body.username);
      if (existingUser) {
        return res.status(400).json({ message: "Usuário já existe" });
      }

      const user = await storage.createUser({
        ...req.body,
        password: await hashPassword(req.body.password),
      });
      
      // Registrar criação de usuário
      logAuditEvent(AuditEventType.USER_CREATED, req, {
        userId: user.id,
        username: user.username,
        role: user.role
      });

      req.login(user, (err: Error | null) => {
        if (err) return next(err);
        
        // Registrar login após registro
        logAuditEvent(AuditEventType.LOGIN_SUCCESS, req, {
          userId: user.id,
          username: user.username,
          registrationLogin: true
        });
        
        return res.status(201).json(user);
      });
    } catch (err) {
      return next(err);
    }
  });

  app.post("/api/login", (req, res, next) => {
    passport.authenticate("local", (err: Error | null, user: SelectUser | false, info: AuthInfo) => {
      if (err) return next(err);
      
      if (!user) {
        // Registra tentativa de login falha
        logAuditEvent(AuditEventType.LOGIN_FAILURE, req, {
          username: req.body.username,
          reason: info?.message || "Credenciais inválidas"
        });
        return res.status(401).json({ message: info?.message || "Credenciais inválidas" });
      }
      
      req.login(user, (err: Error | null) => {
        if (err) return next(err);
        
        // Registra login bem-sucedido
        logAuditEvent(AuditEventType.LOGIN_SUCCESS, req, {
          userId: user.id,
          username: user.username
        });
        
        return res.status(200).json(user);
      });
    })(req, res, next);
  });

  app.post("/api/logout", (req, res, next) => {
    // Capturar informações do usuário antes do logout
    const userId = req.user?.id;
    const username = req.user?.username;
    
    req.logout((err: Error | null) => {
      if (err) return next(err);
      
      // Registrar evento de logout
      if (userId && username) {
        logAuditEvent(AuditEventType.LOGOUT, req, {
          userId,
          username
        });
      }
      
      res.sendStatus(200);
    });
  });

  app.get("/api/user", (req, res) => {
    if (!req.isAuthenticated()) return res.status(401).json({ message: "Não autenticado" });
    res.json(req.user);
  });
}
</file>

<file path="server/controllers/auditLog.controller.ts">
import type { Request, Response } from "express";
import { getRecentAuditLogs } from "../audit-log"; // Adjust path as needed

// Endpoint para obter logs de auditoria
export const getAuditLogs = async (req: Request, res: Response) => {
  try {
    // Default to 100 logs, allow overriding via query param
    const count = parseInt(req.query.count?.toString() || '100'); 
    // Add basic validation for count if needed (e.g., max value, ensure positive)
    const logs = await getRecentAuditLogs(Math.max(1, count)); // Ensure count is at least 1
    res.json(logs);
  } catch (error) {
    console.error('Erro ao buscar logs de auditoria:', error);
    res.status(500).json({ message: "Erro ao buscar logs de auditoria" });
  }
};
</file>

<file path="server/controllers/lead.controller.ts">
import type { Request, Response } from "express";
import { storage } from "../storage";
import { leadValidationSchema } from "@shared/schema";
import { fromZodError } from "zod-validation-error";
import { normalizePhone } from "../utils/lead.utils"; // Import the utility function
import { logAuditEvent, AuditEventType } from "../audit-log";

const BATCH_SIZE = 250; // Define batch size constant

// Importação em lote (batch) de leads
export const importLeadsBatch = async (req: Request, res: Response) => {
  try {
    console.log(`Recebendo solicitação de importação em lote de ${req.body.leads?.length || 0} leads`);
    const { leads } = req.body;
    
    if (!Array.isArray(leads) || leads.length === 0) {
      return res.status(400).json({ message: "Nenhum lead válido fornecido para importação" });
    }
    
    const existingLeads = await storage.getLeads();
    const phoneToLeadMap = new Map();
    
    existingLeads.forEach(lead => {
      if (lead.phone) {
        const normalized = normalizePhone(lead.phone);
        phoneToLeadMap.set(normalized, lead.id);
      }
    });
    
    const results = { 
      success: [] as any[],
      updated: [] as any[],
      errors: [] as any[]
    };
    
    const totalBatches = Math.ceil(leads.length / BATCH_SIZE);
    console.log(`Processando ${leads.length} leads em ${totalBatches} lotes de ${BATCH_SIZE}`);
    
    for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
      console.log(`Enviando lote ${batchIndex + 1}/${totalBatches} (${Math.min(BATCH_SIZE, leads.length - batchIndex * BATCH_SIZE)} leads)`);
      
      const startIdx = batchIndex * BATCH_SIZE;
      const endIdx = Math.min((batchIndex + 1) * BATCH_SIZE, leads.length);
      const currentBatch = leads.slice(startIdx, endIdx);
      
      for (let i = 0; i < currentBatch.length; i++) {
        const globalIndex = startIdx + i;
        try {
          let leadData = currentBatch[i];
          const normalizedCurrentPhone = normalizePhone(leadData.phone);
          
          if (normalizedCurrentPhone && phoneToLeadMap.has(normalizedCurrentPhone)) {
            const existingLeadId = phoneToLeadMap.get(normalizedCurrentPhone);
            const existingLead = existingLeads.find(l => l.id === existingLeadId);
            
            if (existingLead) {
              // Process tags before update check
              if (typeof leadData.tags === 'string') {
                leadData.tags = leadData.tags.split(/[,;]/).map((tag: string) => tag.trim()).filter(Boolean);
              } else if (!Array.isArray(leadData.tags)) {
                leadData.tags = [];
              }
              
              if (existingLead.tags && Array.isArray(existingLead.tags) && existingLead.tags.length > 0) {
                const combinedTags = Array.from(new Set([...existingLead.tags, ...leadData.tags]));
                leadData.tags = combinedTags.filter(tag => tag && tag.trim() !== '');
              }
              
              // Perform update
              console.log(`Atualizando lead ID ${existingLeadId} com novos dados`);
              await storage.updateLead(existingLeadId, leadData); // Use await here
              results.updated.push({
                index: globalIndex,
                id: existingLeadId,
                action: "atualizado",
                phone: leadData.phone
              });
              continue; // Move to next lead in batch
            } else {
               throw new Error(`Telefone ${leadData.phone} já existe, mas o lead correspondente (ID: ${existingLeadId}) não foi encontrado.`);
            }
          }
          
          // Process tags for new lead
          if (typeof leadData.tags === 'string') {
            leadData.tags = leadData.tags.split(/[,;]/).map((tag: string) => tag.trim()).filter(Boolean);
          } else if (!Array.isArray(leadData.tags)) {
            leadData.tags = [];
          }

          const validationResult = leadValidationSchema.safeParse(leadData);
          
          if (!validationResult.success) {
            const validationError = fromZodError(validationResult.error);
            throw new Error(`Erro de validação: ${validationError.message}`);
          }
          
          let validatedLead = validationResult.data;
          
          // Convert entryDate string to Date
          if (validatedLead.entryDate) {
             try {
                if (typeof validatedLead.entryDate === 'string') {
                  if (/^\d{2}\/\d{2}\/\d{4}$/.test(validatedLead.entryDate)) {
                    const [day, month, year] = validatedLead.entryDate.split('/');
                    validatedLead.entryDate = new Date(`${year}-${month}-${day}`);
                  } else {
                    validatedLead.entryDate = new Date(validatedLead.entryDate);
                  }
                  if (isNaN(validatedLead.entryDate.getTime())) {
                    console.warn(`Data inválida: ${validatedLead.entryDate}, usando data atual`);
                    validatedLead.entryDate = new Date(); 
                  }
                } else if (!(validatedLead.entryDate instanceof Date)) {
                  validatedLead.entryDate = new Date();
                }
              } catch (e) {
                console.error(`Erro ao converter data: ${validatedLead.entryDate}`, e);
                validatedLead.entryDate = new Date();
              }
          } else {
             validatedLead.entryDate = new Date();
          }

          const newLead = await storage.createLead(validatedLead);
          
          if (newLead.phone) {
            const normalizedNewPhone = normalizePhone(newLead.phone);
            phoneToLeadMap.set(normalizedNewPhone, newLead.id);
          }
          
          results.success.push({
            index: globalIndex,
            id: newLead.id,
            email: newLead.email
          });
        } catch (error) {
          console.error(`Erro ao processar lead #${globalIndex}:`, error);
          results.errors.push({
            index: globalIndex,
            error: error instanceof Error ? error.message : 'Erro desconhecido',
            data: currentBatch[i]
          });
        }
      }
    }
    
    logAuditEvent(AuditEventType.LEAD_BATCH_IMPORT, req, { 
      totalCount: leads.length,
      successCount: results.success.length,
      updatedCount: results.updated.length,
      errorCount: results.errors.length
    });
    
    console.log(`Importação em lote concluída: ${results.success.length} novos, ${results.updated.length} atualizados, ${results.errors.length} erros`);
    res.status(200).json({
      message: `Importação concluída. ${results.success.length} leads importados e ${results.updated.length} atualizados com sucesso. ${results.errors.length} erros.`, // Added error count to message
      totalProcessed: leads.length,
      successCount: results.success.length,
      updatedCount: results.updated.length,
      errorCount: results.errors.length,
      results
    });
  } catch (error) {
    console.error('Erro na importação em lote:', error);
    res.status(500).json({ message: "Falha na importação em lote", details: String(error) });
  }
};

// Atualização em lote de leads
export const updateLeadsBatch = async (req: Request, res: Response) => {
  try {
    const { ids, updates } = req.body;
    console.log('Atualizando leads em lote:', { ids, updates });
    
    if (!Array.isArray(ids) || ids.length === 0) {
      return res.status(400).json({ message: "IDs de leads são obrigatórios" });
    }
    
    const validationResult = leadValidationSchema.partial().safeParse(updates);
    
    if (!validationResult.success) {
      const validationError = fromZodError(validationResult.error);
      console.error('Erro de validação na atualização em lote:', validationError.message);
      return res.status(400).json({ message: validationError.message });
    }
    
    let dataToUpdate = validationResult.data;
    
    if (dataToUpdate.entryDate && typeof dataToUpdate.entryDate === 'string') {
      try {
        dataToUpdate = {
          ...dataToUpdate,
          entryDate: new Date(dataToUpdate.entryDate)
        };
      } catch (e) {
        console.error('Erro ao converter data:', e);
        return res.status(400).json({ message: "Formato de data inválido" });
      }
    }
    
    console.log('Dados para atualização em lote:', dataToUpdate);
    const count = await storage.updateLeadsInBatch(ids, dataToUpdate);
    
    logAuditEvent(AuditEventType.LEAD_BATCH_UPDATE, req, {
      leadIds: ids,
      updatedFields: Object.keys(dataToUpdate),
      updateCount: count,
      statusChange: dataToUpdate.status ? `Para ${dataToUpdate.status}` : undefined
    });
    
    res.json({ updatedCount: count });
  } catch (error) {
    console.error('Erro ao atualizar leads em lote:', error);
    res.status(500).json({ message: "Erro ao atualizar leads em lote", details: String(error) });
  }
};

// Exclusão em lote de leads
export const deleteLeadsBatch = async (req: Request, res: Response) => {
  try {
    const { ids } = req.body;
    
    if (!Array.isArray(ids) || ids.length === 0) {
      return res.status(400).json({ message: "IDs de leads são obrigatórios" });
    }
    
    const leadsInfo = await Promise.all(
      ids.map(async (id) => {
        try {
          return await storage.getLead(id);
        } catch (e) {
          return null;
        }
      })
    );
    
    const count = await storage.deleteLeadsInBatch(ids);
    
    logAuditEvent(AuditEventType.LEAD_BATCH_DELETE, req, {
      leadIds: ids,
      deleteCount: count,
      leadNames: leadsInfo.filter(Boolean).map(lead => lead?.name).join(', ')
    });
    
    res.json({ deletedCount: count });
  } catch (error) {
    console.error('Erro ao excluir leads em lote:', error);
    res.status(500).json({ message: "Erro ao excluir leads em lote" });
  }
};

// Obter todos os leads
export const getAllLeads = async (req: Request, res: Response) => {
  try {
    const leads = await storage.getLeads();
    res.json(leads);
  } catch (error) {
    console.error('Erro ao buscar leads:', error); // Added console log
    res.status(500).json({ message: "Erro ao buscar leads" });
  }
};

// Obter lead por ID
export const getLeadById = async (req: Request, res: Response) => {
  try {
    const leadId = parseInt(req.params.id);
    if (isNaN(leadId)) { // Validate ID is a number
       return res.status(400).json({ message: "ID do lead inválido" });
    }
    const lead = await storage.getLead(leadId);
    
    if (!lead) {
      return res.status(404).json({ message: "Lead não encontrado" });
    }
    
    res.json(lead);
  } catch (error) {
    console.error(`Erro ao buscar lead ${req.params.id}:`, error); // Added console log
    res.status(500).json({ message: "Erro ao buscar lead" });
  }
};

// Criar novo lead
export const createLead = async (req: Request, res: Response) => {
  try {
    console.log('Recebendo dados para criar lead:', req.body);
    const validationResult = leadValidationSchema.safeParse(req.body);
    
    if (!validationResult.success) {
      const validationError = fromZodError(validationResult.error);
      console.error('Erro de validação:', validationError.message);
      return res.status(400).json({ message: validationError.message });
    }
    
    console.log('Dados validados:', validationResult.data);
    
    let leadToInsert = {
      ...validationResult.data,
      entryDate: validationResult.data.entryDate instanceof Date 
        ? validationResult.data.entryDate 
        : new Date(validationResult.data.entryDate) // Ensure Date object
    };

    // Handle potential invalid date after conversion
    if (isNaN(leadToInsert.entryDate.getTime())) {
       console.warn('Data de entrada inválida, usando data atual:', req.body.entryDate);
       leadToInsert.entryDate = new Date();
    }
    
    console.log('Dados convertidos para inserção:', leadToInsert);
    const newLead = await storage.createLead(leadToInsert);
    
    logAuditEvent(AuditEventType.LEAD_CREATED, req, {
      leadId: newLead.id,
      name: newLead.name,
      source: newLead.source,
      status: newLead.status
    });
    
    res.status(201).json(newLead);
  } catch (error) {
    console.error('Erro ao criar lead:', error);
    res.status(500).json({ message: "Erro ao criar lead", details: String(error) });
  }
};

// Atualizar lead
export const updateLead = async (req: Request, res: Response) => {
  try {
    const leadId = parseInt(req.params.id);
     if (isNaN(leadId)) { // Validate ID
       return res.status(400).json({ message: "ID do lead inválido" });
    }
    console.log('Atualizando lead:', req.body);
    
    const validationResult = leadValidationSchema.partial().safeParse(req.body);
    
    if (!validationResult.success) {
      const validationError = fromZodError(validationResult.error);
      console.error('Erro de validação na atualização:', validationError.message);
      return res.status(400).json({ message: validationError.message });
    }
    
    let dataToUpdate = validationResult.data;
    
    if (dataToUpdate.entryDate && typeof dataToUpdate.entryDate === 'string') {
      try {
         const parsedDate = new Date(dataToUpdate.entryDate);
         if (isNaN(parsedDate.getTime())) {
            throw new Error('Invalid date format');
         }
        dataToUpdate = {
          ...dataToUpdate,
          entryDate: parsedDate
        };
      } catch (e) {
        console.error('Erro ao converter data:', e);
        return res.status(400).json({ message: "Formato de data inválido" });
      }
    }
    
    console.log('Dados para atualização:', dataToUpdate);
    const updatedLead = await storage.updateLead(leadId, dataToUpdate);
    
    if (!updatedLead) {
      return res.status(404).json({ message: "Lead não encontrado" });
    }
    
    // Get original lead data for status change logging
    const originalLead = await storage.getLead(leadId); // Assuming updateLead doesn't return the original

    logAuditEvent(AuditEventType.LEAD_UPDATED, req, {
      leadId: updatedLead.id,
      name: updatedLead.name,
      updatedFields: Object.keys(dataToUpdate),
      // Check if status was part of the update and if it changed
      statusChange: (dataToUpdate.status && originalLead && originalLead.status !== dataToUpdate.status) 
                     ? `De ${originalLead.status} para ${dataToUpdate.status}` 
                     : undefined
    });
    
    res.json(updatedLead);
  } catch (error) {
    console.error('Erro ao atualizar lead:', error);
    res.status(500).json({ message: "Erro ao atualizar lead", details: String(error) });
  }
};

// Excluir lead
export const deleteLead = async (req: Request, res: Response) => {
  try {
    const leadId = parseInt(req.params.id);
     if (isNaN(leadId)) { // Validate ID
       return res.status(400).json({ message: "ID do lead inválido" });
    }
    
    const leadToDelete = await storage.getLead(leadId);
    
    if (!leadToDelete) {
      return res.status(404).json({ message: "Lead não encontrado" });
    }
    
    const success = await storage.deleteLead(leadId);
    
    // Log before checking success, as we have the lead info here
     logAuditEvent(AuditEventType.LEAD_DELETED, req, {
        leadId: leadId,
        name: leadToDelete.name,
        email: leadToDelete.email,
        source: leadToDelete.source,
        status: leadToDelete.status
      });

    if (!success) {
      // This case might be redundant if getLead already threw an error, 
      // but kept for safety in case deleteLead fails for other reasons.
      return res.status(404).json({ message: "Falha ao excluir lead, pode já ter sido excluído" }); 
    }
    
    res.status(204).send();
  } catch (error) {
    console.error('Erro ao deletar lead:', error);
    res.status(500).json({ message: "Erro ao deletar lead" });
  }
};
</file>

<file path="server/controllers/newScheduling.controller.ts">
import type { Request, Response } from "express";
import { storage } from "../storage";
import { agendamentoRecorrenteValidationSchema, aulaValidationSchema } from "../../shared/schema";
import { ZodError } from "zod";

// MÉTODOS PARA AGENDAMENTOS RECORRENTES

/**
 * Criar um novo agendamento recorrente
 * Gera automaticamente as instâncias de aula para os próximos 6 meses
 */
export const createRecurrentScheduling = async (req: Request, res: Response) => {
  try {
    // Validar dados de entrada
    const validatedData = agendamentoRecorrenteValidationSchema.parse(req.body);

    // Verificar se professor existe
    const professor = await storage.getUserById(validatedData.professorId);
    if (!professor || professor.role !== 'professor') {
      return res.status(400).json({ message: "Professor não encontrado" });
    }

    // Verificar se aluno (lead) existe
    const student = await storage.getLeadById(validatedData.studentId);
    if (!student) {
      return res.status(400).json({ message: "Aluno não encontrado" });
    }

    // Criar o agendamento recorrente
    const agendamento = await storage.createAgendamentoRecorrente(validatedData);

    // Gerar instâncias de aulas para os próximos 6 meses
    const aulas = await generateRecurrentClasses(agendamento);

    // Validar conflitos para cada aula
    const conflicts = [];
    for (const aula of aulas) {
      const hasConflict = await storage.checkSchedulingConflicts(
        aula.professorId,
        aula.studentId,
        new Date(aula.startTime),
        new Date(aula.endTime)
      );
      
      if (hasConflict) {
        conflicts.push({
          date: aula.startTime,
          conflict: hasConflict
        });
      }
    }

    // Se há conflitos, retornar erro 409
    if (conflicts.length > 0) {
      return res.status(409).json({
        message: "Conflito de horário detectado",
        conflicts: conflicts
      });
    }

    // Criar todas as aulas
    const createdAulas = await storage.createMultipleAulas(aulas);

    res.status(201).json({
      agendamento,
      aulas: createdAulas
    });
  } catch (error) {
    if (error instanceof ZodError) {
      return res.status(400).json({
        message: "Dados inválidos",
        errors: error.errors.map(err => ({
          field: err.path.join("."),
          message: err.message
        }))
      });
    }
    console.error("Erro ao criar agendamento recorrente:", error);
    res.status(500).json({ message: "Erro ao criar agendamento recorrente" });
  }
};

/**
 * Buscar todas as aulas (instâncias individuais)
 */
export const getClasses = async (req: Request, res: Response) => {
  try {
    const { start, end, professorId, studentId, status } = req.query;

    const filters: any = {};
    
    if (start) filters.startDate = new Date(start as string);
    if (end) filters.endDate = new Date(end as string);
    if (professorId) filters.professorId = parseInt(professorId as string);
    if (studentId) filters.studentId = parseInt(studentId as string);
    if (status) filters.status = status as string;

    const aulas = await storage.getAulas(filters);

    // Transformar dados para compatibilidade com react-big-calendar
    const calendarEvents = await Promise.all(
      aulas.map(async (aula) => {
        const professor = await storage.getUserById(aula.professorId);
        const student = await storage.getLeadById(aula.studentId);

        return {
          ...aula,
          title: `${aula.service} - ${student?.name || 'Aluno'}`,
          start: new Date(aula.startTime),
          end: new Date(aula.endTime),
          resource: {
            professor: professor ? { id: professor.id, name: professor.name } : null,
            student: student ? { id: student.id, name: student.name } : null,
            originalData: aula
          }
        };
      })
    );

    res.json(calendarEvents);
  } catch (error) {
    console.error("Erro ao buscar aulas:", error);
    res.status(500).json({ message: "Erro ao buscar aulas" });
  }
};

/**
 * Atualizar uma aula específica
 */
export const updateClass = async (req: Request, res: Response) => {
  try {
    const aulaId = parseInt(req.params.id);
    if (isNaN(aulaId)) {
      return res.status(400).json({ message: "ID da aula inválido" });
    }

    // Validar dados (schema parcial)
    const updateSchema = aulaValidationSchema.partial();
    const validatedData = updateSchema.parse(req.body);

    // Verificar se a aula existe
    const existingAula = await storage.getAulaById(aulaId);
    if (!existingAula) {
      return res.status(404).json({ message: "Aula não encontrada" });
    }

    // Se horário está sendo alterado, verificar conflitos
    if (validatedData.startTime || validatedData.endTime) {
      const startTime = validatedData.startTime ? new Date(validatedData.startTime as any) : new Date(existingAula.startTime);
      const endTime = validatedData.endTime ? new Date(validatedData.endTime as any) : new Date(existingAula.endTime);
      const professorId = validatedData.professorId || existingAula.professorId;
      const studentId = validatedData.studentId || existingAula.studentId;

      const hasConflict = await storage.checkSchedulingConflicts(
        professorId,
        studentId,
        startTime,
        endTime,
        aulaId // Excluir a própria aula da verificação
      );

      if (hasConflict) {
        return res.status(409).json({
          message: "Conflito de horário detectado",
          conflict: hasConflict
        });
      }

      // Marcar como modificada se horário mudou
      if (validatedData.startTime || validatedData.endTime) {
        validatedData.isModified = true;
        if (!existingAula.originalStartTime) {
          validatedData.originalStartTime = existingAula.startTime;
          validatedData.originalEndTime = existingAula.endTime;
        }
      }
    }

    const updatedAula = await storage.updateAula(aulaId, validatedData);
    res.json(updatedAula);
  } catch (error) {
    if (error instanceof ZodError) {
      return res.status(400).json({
        message: "Dados inválidos",
        errors: error.errors.map(err => ({
          field: err.path.join("."),
          message: err.message
        }))
      });
    }
    console.error("Erro ao atualizar aula:", error);
    res.status(500).json({ message: "Erro ao atualizar aula" });
  }
};

/**
 * Verificar conflitos de horário
 */
export const checkConflicts = async (req: Request, res: Response) => {
  try {
    const { professorId, studentId, startTime, endTime, excludeAulaId } = req.body;

    if (!professorId || !studentId || !startTime || !endTime) {
      return res.status(400).json({ message: "Dados obrigatórios não fornecidos" });
    }

    const hasConflict = await storage.checkSchedulingConflicts(
      parseInt(professorId),
      parseInt(studentId),
      new Date(startTime),
      new Date(endTime),
      excludeAulaId ? parseInt(excludeAulaId) : undefined
    );

    res.json({
      hasConflict: !!hasConflict,
      conflict: hasConflict
    });
  } catch (error) {
    console.error("Erro ao verificar conflitos:", error);
    res.status(500).json({ message: "Erro ao verificar conflitos" });
  }
};

/**
 * Função auxiliar para gerar aulas recorrentes
 */
async function generateRecurrentClasses(agendamento: any): Promise<any[]> {
  const aulas = [];
  const { regras } = agendamento;
  const startDate = new Date(agendamento.startDate);
  const endDate = agendamento.endDate ? new Date(agendamento.endDate) : null;
  const maxDate = new Date();
  maxDate.setMonth(maxDate.getMonth() + 6); // 6 meses à frente

  let currentDate = new Date(startDate);
  let occurrenceCount = 0;

  while (currentDate <= maxDate) {
    // Verificar se atingiu limite de ocorrências
    if (agendamento.maxOccurrences && occurrenceCount >= agendamento.maxOccurrences) {
      break;
    }

    // Verificar se atingiu data limite
    if (endDate && currentDate > endDate) {
      break;
    }

    // Verificar se o dia da semana está nas regras (para recorrência semanal)
    if (regras.type === 'weekly' && regras.weekDays) {
      const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
      const currentDayName = dayNames[currentDate.getDay()];
      if (!regras.weekDays.includes(currentDayName)) {
        currentDate.setDate(currentDate.getDate() + 1);
        continue;
      }
    }

    // Criar aula para esta data
    const startTime = new Date(currentDate);
    const endTime = new Date(currentDate);
    
    // Definir horários baseados na primeira aula
    const originalStartTime = new Date(startDate);
    const originalEndTime = new Date(startDate);
    originalEndTime.setHours(originalStartTime.getHours() + 1); // Duração padrão de 1 hora

    startTime.setHours(originalStartTime.getHours(), originalStartTime.getMinutes());
    endTime.setHours(originalEndTime.getHours(), originalEndTime.getMinutes());

    aulas.push({
      agendamentoRecorrenteId: agendamento.id,
      professorId: agendamento.professorId,
      studentId: agendamento.studentId,
      startTime: startTime.toISOString(),
      endTime: endTime.toISOString(),
      location: agendamento.location,
      value: agendamento.value,
      service: agendamento.service,
      notes: agendamento.notes,
      status: "agendado" as const,
      isModified: false
    });

    occurrenceCount++;

    // Avançar para próxima ocorrência baseado no tipo de recorrência
    switch (regras.type) {
      case 'daily':
        currentDate.setDate(currentDate.getDate() + regras.interval);
        break;
      case 'weekly':
        currentDate.setDate(currentDate.getDate() + (7 * regras.interval));
        break;
      case 'monthly':
        currentDate.setMonth(currentDate.getMonth() + regras.interval);
        break;
      case 'yearly':
        currentDate.setFullYear(currentDate.getFullYear() + regras.interval);
        break;
      default:
        currentDate.setDate(currentDate.getDate() + 1);
    }
  }

  return aulas;
}
</file>

<file path="server/controllers/oauth.controller.ts">
import { Request, Response } from 'express';
import { storage } from '../storage';
import { getAuthUrl, getTokensFromCode, setCredentials } from '../google-calendar';
import { logAuditEvent, AuditEventType } from '../audit-log';

export async function getGoogleAuthUrl(req: Request, res: Response) {
  try {
    const authUrl = getAuthUrl();
    
    logAuditEvent(AuditEventType.OAUTH_INIT, req, {
      userId: req.user?.id,
      provider: 'google'
    });
    
    res.json({ authUrl });
  } catch (error) {
    console.error('Erro ao gerar URL de autorização:', error);
    res.status(500).json({ 
      message: 'Erro ao gerar URL de autorização',
      error: error instanceof Error ? error.message : 'Erro desconhecido'
    });
  }
}

export async function handleGoogleCallback(req: Request, res: Response) {
  try {
    const { code, error } = req.query;
    
    if (error) {
      logAuditEvent(AuditEventType.OAUTH_ERROR, req, {
        userId: req.user?.id,
        provider: 'google',
        error: String(error)
      });
      
      return res.status(400).json({ 
        message: 'Autorização negada pelo usuário',
        error: String(error)
      });
    }
    
    if (!code || typeof code !== 'string') {
      return res.status(400).json({ 
        message: 'Código de autorização não fornecido' 
      });
    }
    
    // Trocar código por tokens
    const tokens = await getTokensFromCode(code);
    
    // Salvar tokens no banco de dados
    await storage.saveGoogleTokens(req.user!.id, tokens);
    
    // Configurar credenciais para uso imediato
    setCredentials(tokens);
    
    logAuditEvent(AuditEventType.OAUTH_SUCCESS, req, {
      userId: req.user?.id,
      provider: 'google',
      hasRefreshToken: !!tokens.refresh_token
    });
    
    res.json({ 
      message: 'Autorização concedida com sucesso',
      hasRefreshToken: !!tokens.refresh_token
    });
  } catch (error) {
    console.error('Erro no callback OAuth2:', error);
    
    logAuditEvent(AuditEventType.OAUTH_ERROR, req, {
      userId: req.user?.id,
      provider: 'google',
      error: error instanceof Error ? error.message : 'Erro desconhecido'
    });
    
    res.status(500).json({ 
      message: 'Erro ao processar autorização',
      error: error instanceof Error ? error.message : 'Erro desconhecido'
    });
  }
}

export async function getTokenStatus(req: Request, res: Response) {
  try {
    const tokens = await storage.getGoogleTokens(req.user!.id);
    
    if (!tokens) {
      return res.json({ 
        authorized: false,
        message: 'Nenhuma autorização encontrada'
      });
    }
    
    const now = Date.now();
    const isExpired = tokens.expiry_date <= now;
    
    res.json({
      authorized: true,
      isExpired,
      hasRefreshToken: !!tokens.refresh_token,
      expiryDate: new Date(tokens.expiry_date).toISOString()
    });
  } catch (error) {
    console.error('Erro ao verificar status dos tokens:', error);
    res.status(500).json({ 
      message: 'Erro ao verificar status da autorização',
      error: error instanceof Error ? error.message : 'Erro desconhecido'
    });
  }
}

export async function revokeGoogleAccess(req: Request, res: Response) {
  try {
    await storage.deleteGoogleTokens(req.user!.id);
    
    logAuditEvent(AuditEventType.OAUTH_REVOKE, req, {
      userId: req.user?.id,
      provider: 'google'
    });
    
    res.json({ message: 'Acesso revogado com sucesso' });
  } catch (error) {
    console.error('Erro ao revogar acesso:', error);
    res.status(500).json({ 
      message: 'Erro ao revogar acesso',
      error: error instanceof Error ? error.message : 'Erro desconhecido'
    });
  }
}
</file>

<file path="server/controllers/scheduling.controller.ts">
import type { Request, Response } from "express";
import { storage } from "../storage"; // Adjust path as needed
import { leads } from "@shared/schema"; // Import leads schema if needed for filtering
import type { Session, Student } from "@shared/schema"; // Assuming Session and Student types are in schema

// Placeholder for actual database interactions or more complex logic
// For now, we'll move the existing mocked/simple logic here.

// --- SESSIONS ---
export const getSessions = async (req: Request, res: Response) => {
  try {
    // First try to get sessions from the database
    // Note: storage.getSessions() likely needs implementation/schema alignment too
    const dbSessions = await storage.getSessions();
    return res.json(dbSessions);
  } catch (dbError) {
    console.log('Sessions table not found or error, using simulated data:', dbError);
    // If it fails (table doesn't exist or other DB error), create simulated data
    try {
        const allLeads = await storage.getLeads();
        const alunoLeads = allLeads.filter(lead => lead.status === "Aluno");

        const sessions: Session[] = [];
        const now = new Date();
        const trainerIds = [1, 2, 3, 4]; // Mock trainer IDs

        for (const lead of alunoLeads) {
            const sessionCount = Math.floor(Math.random() * 5) + 1;
            for (let i = 0; i < sessionCount; i++) {
                const startDate = new Date(now);
                startDate.setDate(now.getDate() - Math.floor(Math.random() * 60));
                const durationMinutes = 45 + Math.floor(Math.random() * 46);
                const endDate = new Date(startDate);
                endDate.setMinutes(startDate.getMinutes() + durationMinutes);
                const statuses = ["Agendado", "Concluído", "Cancelado", "Remarcado"];
                const status = statuses[Math.floor(Math.random() * statuses.length)];
                const isPresencial = Math.random() < 0.3;
                const location = isPresencial ? ['Studio Favale', 'Academia Pink', 'Centro Esportivo'][Math.floor(Math.random() * 3)] : 'Online';

                sessions.push({
                    id: sessions.length + 1, // Simple incrementing ID for mock
                    studentId: lead.id,
                    trainerId: trainerIds[Math.floor(Math.random() * trainerIds.length)], // Assign random mock trainer ID
                    source: lead.source, // Assuming lead source is relevant
                    startTime: startDate, // Use Date object
                    endTime: endDate, // Use Date object
                    status: status,
                    location: location,
                    notes: null,
                    googleEventId: null, // Mock googleEventId
                    createdAt: new Date(lead.entryDate), // Use Date object
                    updatedAt: new Date() // Use Date object
                });
            }
        }
        return res.json(sessions);
    } catch (simError) {
        console.error('Error generating simulated session data:', simError);
        res.status(500).json({ message: "Erro ao buscar sessões, e falha ao simular dados." });
    }
  }
};

export const getSessionDetails = async (req: Request, res: Response) => {
  try {
    // We'll replicate generating mock data with details.
    // In a real scenario, this would fetch from DB and join with trainer/location data.
    const allLeads = await storage.getLeads();
    const alunoLeads = allLeads.filter(lead => lead.status === "Aluno");

    const sessions: Session[] = [];
    const now = new Date();
    const trainerIds = [1, 2, 3, 4]; // Mock trainer IDs
    const trainersMock = [
      { id: 1, name: "Amanda Silva" },
      { id: 2, name: "Ricardo Costa" },
      { id: 3, name: "Juliana Oliveira" },
      { id: 4, name: "Marcos Santos" }
    ];

    for (const lead of alunoLeads) {
        const sessionCount = Math.floor(Math.random() * 5) + 1;
        for (let i = 0; i < sessionCount; i++) {
            const startDate = new Date(now);
            startDate.setDate(now.getDate() - Math.floor(Math.random() * 60));
            const durationMinutes = 45 + Math.floor(Math.random() * 46);
            const endDate = new Date(startDate);
            endDate.setMinutes(startDate.getMinutes() + durationMinutes);
            const statuses = ["Agendado", "Concluído", "Cancelado", "Remarcado"];
            const status = statuses[Math.floor(Math.random() * statuses.length)];
            const isPresencial = Math.random() < 0.3;
            const location = isPresencial ? ['Studio Favale', 'Academia Pink', 'Centro Esportivo'][Math.floor(Math.random() * 3)] : 'Online';

            sessions.push({
                id: sessions.length + 1,
                studentId: lead.id,
                trainerId: trainerIds[Math.floor(Math.random() * trainerIds.length)],
                source: lead.source,
                startTime: startDate,
                endTime: endDate,
                status: status,
                location: location,
                notes: null,
                googleEventId: null,
                createdAt: new Date(lead.entryDate),
                updatedAt: new Date()
            });
        }
    }

    // Add extra details not present in Session schema (like trainerName, studentName)
    const sessionsWithDetails = sessions.map((session: Session) => {
      const student = alunoLeads.find(l => l.id === session.studentId);
      const trainer = trainersMock.find(t => t.id === session.trainerId);
      return {
          ...session,
          // Convert Dates back to ISO strings for JSON compatibility if needed by frontend
          startTime: session.startTime.toISOString(),
          endTime: session.endTime.toISOString(),
          createdAt: session.createdAt.toISOString(),
          updatedAt: session.updatedAt.toISOString(),
          // Add names and feedback for detailed view
          studentName: student ? student.name : 'Desconhecido',
          trainerName: trainer ? trainer.name : 'Desconhecido',
          feedback: session.status === 'Concluído' ? ['Excelente progresso', 'Bom desempenho', 'Precisa melhorar', 'Superou expectativas'][Math.floor(Math.random() * 4)] : null
      };
    });

    res.json(sessionsWithDetails);
  } catch (error) {
    console.error('Erro ao buscar detalhes das sessões:', error);
    res.status(500).json({ message: "Erro ao buscar detalhes das sessões" });
  }
};

export const getSessionsByDateRange = async (req: Request, res: Response) => {
  try {
    const startDateQuery = req.query.start ? new Date(req.query.start as string) : new Date(new Date().setDate(new Date().getDate() - 30));
    const endDateQuery = req.query.end ? new Date(req.query.end as string) : new Date(new Date().setDate(new Date().getDate() + 30));

    // Replicating the logic of fetching all (mocked) sessions then filtering.
    const allLeads = await storage.getLeads();
    const alunoLeads = allLeads.filter(lead => lead.status === "Aluno");

    const allSessions: Session[] = [];
    const now = new Date();
    const trainerIds = [1, 2, 3, 4]; // Mock trainer IDs

    for (const lead of alunoLeads) {
        const sessionCount = Math.floor(Math.random() * 5) + 1;
        for (let i = 0; i < sessionCount; i++) {
            const sessionStartDate = new Date(now);
            sessionStartDate.setDate(now.getDate() - Math.floor(Math.random() * 60));
            const durationMinutes = 45 + Math.floor(Math.random() * 46);
            const sessionEndDate = new Date(sessionStartDate);
            sessionEndDate.setMinutes(sessionStartDate.getMinutes() + durationMinutes);
            const statuses = ["Agendado", "Concluído", "Cancelado", "Remarcado"];
            const status = statuses[Math.floor(Math.random() * statuses.length)];
            const isPresencial = Math.random() < 0.3;
            const location = isPresencial ? ['Studio Favale', 'Academia Pink', 'Centro Esportivo'][Math.floor(Math.random() * 3)] : 'Online';

            allSessions.push({
                id: allSessions.length + 1,
                studentId: lead.id,
                trainerId: trainerIds[Math.floor(Math.random() * trainerIds.length)],
                source: lead.source,
                startTime: sessionStartDate,
                endTime: sessionEndDate,
                status: status,
                location: location,
                notes: null,
                googleEventId: null,
                createdAt: new Date(lead.entryDate),
                updatedAt: new Date()
            });
        }
    }

    const filteredSessions = allSessions.filter((session: Session) => {
      // Compare Date objects directly
      return session.startTime >= startDateQuery && session.startTime <= endDateQuery;
    });

    // Convert dates back to ISO strings for JSON response consistency
    const responseSessions = filteredSessions.map(s => ({
        ...s,
        startTime: s.startTime.toISOString(),
        endTime: s.endTime.toISOString(),
        createdAt: s.createdAt.toISOString(),
        updatedAt: s.updatedAt.toISOString(),
    }));

    res.json(responseSessions);
  } catch (error) {
    console.error('Erro ao buscar sessões por data:', error);
    res.status(500).json({ message: "Erro ao buscar sessões por data" });
  }
};

// --- TRAINERS ---
export const getTrainers = async (req: Request, res: Response) => {
  try {
    // Mocked data as in the original routes.ts
    // TODO: Replace with actual DB query for trainers
    const trainers = [
      { id: 1, name: "Amanda Silva", specialty: "Musculação", email: "amanda.silva@favalepink.com", phone: "+5511987654321", active: true, bio: "Especialista em musculação e condicionamento físico", imageUrl: null, createdAt: new Date().toISOString(), updatedAt: new Date().toISOString() },
      { id: 2, name: "Ricardo Costa", specialty: "Funcional", email: "ricardo.costa@favalepink.com", phone: "+5511976543210", active: true, bio: "Especialista em treinamento funcional e crossfit", imageUrl: null, createdAt: new Date().toISOString(), updatedAt: new Date().toISOString() },
      { id: 3, name: "Juliana Oliveira", specialty: "Pilates", email: "juliana.oliveira@favalepink.com", phone: "+5511965432109", active: true, bio: "Especialista em pilates e alongamento", imageUrl: null, createdAt: new Date().toISOString(), updatedAt: new Date().toISOString() },
      { id: 4, name: "Marcos Santos", specialty: "Nutrição Esportiva", email: "marcos.santos@favalepink.com", phone: "+5511954321098", active: true, bio: "Nutricionista esportivo com foco em emagrecimento e hipertrofia", imageUrl: null, createdAt: new Date().toISOString(), updatedAt: new Date().toISOString() },
      { id: 5, name: "Carolina Mendes", specialty: "Yoga", email: "carolina.mendes@favalepink.com", phone: "+5511943210987", active: false, bio: "Instrutora de yoga e meditação", imageUrl: null, createdAt: new Date().toISOString(), updatedAt: new Date().toISOString() }
    ];
    res.json(trainers);
  } catch (error) {
    console.error('Erro ao buscar treinadores:', error);
    res.status(500).json({ message: "Erro ao buscar treinadores" });
  }
};

export const getActiveTrainers = async (req: Request, res: Response) => {
  try {
    // Replicating the logic of fetching all (mocked) trainers then filtering.
    // TODO: Replace with actual DB query filtering active trainers
    const trainers = [
        { id: 1, name: "Amanda Silva", specialty: "Musculação", email: "amanda.silva@favalepink.com", phone: "+5511987654321", active: true, bio: "Especialista em musculação e condicionamento físico", imageUrl: null, createdAt: new Date().toISOString(), updatedAt: new Date().toISOString() },
        { id: 2, name: "Ricardo Costa", specialty: "Funcional", email: "ricardo.costa@favalepink.com", phone: "+5511976543210", active: true, bio: "Especialista em treinamento funcional e crossfit", imageUrl: null, createdAt: new Date().toISOString(), updatedAt: new Date().toISOString() },
        { id: 3, name: "Juliana Oliveira", specialty: "Pilates", email: "juliana.oliveira@favalepink.com", phone: "+5511965432109", active: true, bio: "Especialista em pilates e alongamento", imageUrl: null, createdAt: new Date().toISOString(), updatedAt: new Date().toISOString() },
        { id: 4, name: "Marcos Santos", specialty: "Nutrição Esportiva", email: "marcos.santos@favalepink.com", phone: "+5511954321098", active: true, bio: "Nutricionista esportivo com foco em emagrecimento e hipertrofia", imageUrl: null, createdAt: new Date().toISOString(), updatedAt: new Date().toISOString() },
        { id: 5, name: "Carolina Mendes", specialty: "Yoga", email: "carolina.mendes@favalepink.com", phone: "+5511943210987", active: false, bio: "Instrutora de yoga e meditação", imageUrl: null, createdAt: new Date().toISOString(), updatedAt: new Date().toISOString() }
      ];
    const activeTrainers = trainers.filter((trainer: any) => trainer.active);
    res.json(activeTrainers);
  } catch (error) {
    console.error('Erro ao buscar treinadores ativos:', error);
    res.status(500).json({ message: "Erro ao buscar treinadores ativos" });
  }
};

// --- STUDENTS ---
export const getStudents = async (req: Request, res: Response) => {
  try {
    // Mocked data based on leads, as in original routes.ts
    // TODO: Replace with actual DB query for students
    const allLeads = await storage.getLeads();
    const alunoLeads = allLeads.filter(lead => lead.status === "Aluno");

    const students: Student[] = alunoLeads.map(lead => ({
      id: lead.id, // Assuming student ID is same as lead ID for this mock
      leadId: lead.id,
      // name, email, phone are not in Student schema, they are in Lead schema
      source: lead.source || 'Não definido',
      address: `${lead.state || 'SP'}, Brasil`, // Mock address
      preferences: `Interesse em ${['Perda de peso', 'Musculação', 'Saúde geral', 'Condicionamento físico'][Math.floor(Math.random() * 4)]}`, // Mock preferences
      active: true, // Mock active status
      createdAt: new Date(lead.entryDate), // Use Date object
      updatedAt: new Date() // Use Date object
    }));

    // Convert dates back to ISO strings for JSON response consistency
    const responseStudents = students.map(s => ({
        ...s,
        createdAt: s.createdAt.toISOString(),
        updatedAt: s.updatedAt.toISOString(),
    }));

    res.json(responseStudents);
  } catch (error) {
    console.error('Erro ao buscar estudantes:', error);
    res.status(500).json({ message: "Erro ao buscar estudantes" });
  }
};

export const getStudentsWithLeads = async (req: Request, res: Response) => {
  try {
    // Replicating the logic of fetching all (mocked) students then combining with leads.
    // TODO: Replace with actual DB query joining students and leads
    const allLeads = await storage.getLeads();
    const alunoLeads = allLeads.filter(lead => lead.status === "Aluno");

    const students: Student[] = alunoLeads.map(lead => ({
      id: lead.id,
      leadId: lead.id,
      source: lead.source || 'Não definido',
      address: `${lead.state || 'SP'}, Brasil`,
      preferences: `Interesse em ${['Perda de peso', 'Musculação', 'Saúde geral', 'Condicionamento físico'][Math.floor(Math.random() * 4)]}`,
      active: true,
      createdAt: new Date(lead.entryDate),
      updatedAt: new Date()
    }));

    const studentsWithLeads = students.map((student: Student) => {
      const lead = allLeads.find(l => l.id === student.leadId);
      return {
        ...student,
        // Convert dates back to ISO strings for JSON response consistency
        createdAt: student.createdAt.toISOString(),
        updatedAt: student.updatedAt.toISOString(),
        // Add lead details (including name, email, phone)
        lead: lead ? {
            ...lead,
            entryDate: new Date(lead.entryDate).toISOString(), // Ensure lead dates are also ISO strings
            updatedAt: lead.updatedAt ? new Date(lead.updatedAt).toISOString() : new Date().toISOString() 
        } : null
      };
    });

    res.json(studentsWithLeads);
  } catch (error) {
    console.error('Erro ao buscar estudantes com info de leads:', error);
    res.status(500).json({ message: "Erro ao buscar estudantes com info de leads" });
  }
};

export const deleteAppointment = async (req: Request, res: Response) => {
  try {
    const { id } = req.params;

    // Delete the appointment
    // await db.delete(aulas).where(eq(aulas.id, parseInt(id)));

    res.json({ success: true, message: 'Agendamento excluído com sucesso' });
  } catch (error) {
    console.error('Erro ao excluir agendamento:', error);
    res.status(500).json({ error: 'Erro interno do servidor' });
  }
};

export const updateAppointmentStatus = async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const { status } = req.body;

    // Validate status
    const validStatuses = [
      'SCHEDULED', 'DESM_DIA', 'DESM_ANTEC', 'DESM_MANUF', 
      'REP', 'REP_DESM_DIA', 'AULA_ADIC', 'COMPLETED', 'CANCELLED'
    ];

    if (!validStatuses.includes(status)) {
      return res.status(400).json({ error: 'Status inválido' });
    }

    // Update the appointment status
    // const [updatedAppointment] = await db
    //   .update(aulas)
    //   .set({ status })
    //   .where(eq(aulas.id, parseInt(id)))
    //   .returning();

    const updatedAppointment = {id: id, status: status};

    if (!updatedAppointment) {
      return res.status(404).json({ error: 'Agendamento não encontrado' });
    }

    res.json({ 
      success: true, 
      message: 'Status atualizado com sucesso',
      appointment: updatedAppointment
    });
  } catch (error) {
    console.error('Erro ao atualizar status do agendamento:', error);
    res.status(500).json({ error: 'Erro interno do servidor' });
  }
};

export const deleteRecurringGroup = async (req: Request, res: Response) => {
  try {
    const { groupId } = req.params;

    if (!groupId) {
      return res.status(400).json({ error: 'ID do grupo de recorrência é obrigatório' });
    }

    // Delete all appointments in the recurring group
    // const deletedAppointments = await db
    //   .delete(aulas)
    //   .where(eq(aulas.recurrenceGroupId, groupId))
    //   .returning();
    const deletedAppointments = [];

    if (deletedAppointments.length === 0) {
      return res.status(404).json({ error: 'Grupo de recorrência não encontrado' });
    }

    res.json({ 
      success: true, 
      message: `${deletedAppointments.length} agendamentos da recorrência excluídos com sucesso`,
      deletedCount: deletedAppointments.length
    });
  } catch (error) {
    console.error('Erro ao excluir grupo de recorrência:', error);
    res.status(500).json({ error: 'Erro interno do servidor' });
  }
};

// Aliases for route compatibility
export const getAppointments = getSessions;
export const createAppointment = async (req: Request, res: Response) => {
  try {
    // For now, return a simple response - this can be implemented based on requirements
    res.json({ success: true, message: 'Appointment creation endpoint - needs implementation' });
  } catch (error) {
    console.error('Erro ao criar agendamento:', error);
    res.status(500).json({ error: 'Erro interno do servidor' });
  }
};

export const updateAppointment = async (req: Request, res: Response) => {
  try {
    // For now, return a simple response - this can be implemented based on requirements
    res.json({ success: true, message: 'Appointment update endpoint - needs implementation' });
  } catch (error) {
    console.error('Erro ao atualizar agendamento:', error);
    res.status(500).json({ error: 'Erro interno do servidor' });
  }
};

export const createRecurringAppointments = async (req: Request, res: Response) => {
  try {
    // For now, return a simple response - this can be implemented based on requirements
    res.json({ success: true, message: 'Recurring appointments creation endpoint - needs implementation' });
  } catch (error) {
    console.error('Erro ao criar agendamentos recorrentes:', error);
    res.status(500).json({ error: 'Erro interno do servidor' });
  }
};
</file>

<file path="server/controllers/stats.controller.ts">
import type { Request, Response } from "express";
import { storage } from "../storage"; // Adjust path as needed
import { sql } from 'drizzle-orm';

export const getStats = async (req: Request, res: Response) => {
  try {
    // Buscar todos os leads e alunos
    const allLeadsPromise = storage.getLeads();
    // Assuming getStudents() exists and returns Student data (or similar)
    // If `getStudents` isn't implemented in storage, we might need to fetch leads with status 'Aluno'
    const studentsPromise = storage.getStudents ? storage.getStudents() : storage.getLeads().then(leads => leads.filter(l => l.status === 'Aluno'));

    const [allLeads, alunos] = await Promise.all([allLeadsPromise, studentsPromise]);

    // Calcular taxa de conversão (Alunos / Leads Totais)
    const conversionRate = allLeads.length > 0 ? (alunos.length / allLeads.length) * 100 : 0;

    // Calcular crescimento mensal (simulado)
    // Ideally, this would query leads based on creation date
    const oneMonthAgo = new Date();
    oneMonthAgo.setMonth(oneMonthAgo.getMonth() - 1);
    const leadsLastMonth = allLeads.filter(lead => new Date(lead.entryDate) >= oneMonthAgo).length;
    const leadsBeforeLastMonth = allLeads.length - leadsLastMonth;
    const monthlyGrowth = leadsBeforeLastMonth > 0 ? ((leadsLastMonth - leadsBeforeLastMonth) / leadsBeforeLastMonth) * 100 : (leadsLastMonth > 0 ? 100 : 0);

    // Agrupar leads por origem, estado e campanha (se disponíveis)
    const leadsBySource = allLeads.reduce((acc, lead) => {
      const source = lead.source || 'Desconhecido';
      acc[source] = (acc[source] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    const leadsByState = allLeads.reduce((acc, lead) => {
      const state = lead.state || 'Desconhecido';
      acc[state] = (acc[state] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    // Example assuming campaign is stored directly on lead; adjust if needed
    const leadsByCampaign = allLeads.reduce((acc, lead) => {
      const campaign = lead.campaign || 'Nenhuma';
      acc[campaign] = (acc[campaign] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    // Calcular estatísticas gerais
    const stats = {
      totalLeads: allLeads.length,
      totalStudents: alunos.length,
      // Mock session counts based on student numbers - replace with real data when available
      totalActiveSessions: Math.round(alunos.length * 1.6),
      totalCompletedSessions: Math.round(alunos.length * 3.8),
      sessionsPerStudent: alunos.length > 0 ? ((Math.round(alunos.length * 1.6) + Math.round(alunos.length * 3.8)) / alunos.length).toFixed(1) : "0.0", // Approximate
      conversionRate: conversionRate.toFixed(1),
      monthlyGrowth: monthlyGrowth.toFixed(1),
      leadsBySource,
      leadsByState,
      leadsByCampaign,
      totalLeadsByCampaign: Object.values(leadsByCampaign).reduce((a, b) => a + b, 0)
    };
    
    res.json(stats);
  } catch (error) {
    console.error('Erro ao buscar estatísticas:', error);
    res.status(500).json({ message: "Erro ao buscar estatísticas" });
  }
};
</file>

<file path="server/controllers/task.controller.ts">
import type { Request, Response } from "express";
import { storage } from "../storage";
import { taskValidationSchema, taskCommentValidationSchema } from "@shared/schema";
import { addUserNamesToTasks } from "../utils/task.utils"; // Utility to add user names

// Listar todas as tarefas
export const getAllTasks = async (req: Request, res: Response) => {
  try {
    const tasks = await storage.getTasks();
    const tasksWithUserNames = await addUserNamesToTasks(tasks, storage);
    res.json(tasksWithUserNames);
  } catch (error) {
    console.error('Erro ao buscar tarefas:', error);
    res.status(500).json({ message: 'Erro ao buscar tarefas' });
  }
};

// Buscar tarefa pelo ID
export const getTaskById = async (req: Request, res: Response) => {
  const id = parseInt(req.params.id);
  if (isNaN(id)) {
    return res.status(400).json({ message: 'ID inválido' });
  }
  try {
    const task = await storage.getTask(id);
    if (!task) {
      return res.status(404).json({ message: 'Tarefa não encontrada' });
    }
    const assignedTo = await storage.getUser(task.assignedToId);
    const assignedBy = await storage.getUser(task.assignedById);
    const comments = await storage.getTaskCommentsByTaskId(id);
    const commentsWithUserInfo = await Promise.all(comments.map(async comment => {
      if (comment.userId) {
        const commentUser = await storage.getUser(comment.userId);
        return {
          ...comment,
          userName: commentUser?.username || 'Usuário não encontrado'
        };
      }
      return comment;
    }));
    res.json({
      ...task,
      assignedToName: assignedTo?.username || 'Usuário não encontrado',
      assignedByName: assignedBy?.username || 'Usuário não encontrado',
      comments: commentsWithUserInfo
    });
  } catch (error) {
    console.error(`Erro ao buscar tarefa ${id}:`, error);
    res.status(500).json({ message: 'Erro ao buscar detalhes da tarefa' });
  }
};

// Criar nova tarefa
export const createTask = async (req: Request, res: Response) => {
  try {
    const validatedData = taskValidationSchema.parse(req.body);
    if (validatedData.dueDate && !(validatedData.dueDate instanceof Date)) {
      validatedData.dueDate = new Date(validatedData.dueDate);
    }
    const newTask = await storage.createTask(validatedData);
    res.status(201).json(newTask);
  } catch (error: any) {
    if (error.name === 'ZodError') {
      return res.status(400).json({ 
        message: 'Dados inválidos', 
        details: error.errors 
      });
    }
    console.error('Erro ao criar tarefa:', error);
    res.status(500).json({ message: 'Erro ao criar tarefa' });
  }
};

// Atualizar tarefa existente
export const updateTask = async (req: Request, res: Response) => {
  const id = parseInt(req.params.id);
  if (isNaN(id)) {
    return res.status(400).json({ message: 'ID inválido' });
  }
  try {
    const existingTask = await storage.getTask(id);
    if (!existingTask) {
      return res.status(404).json({ message: 'Tarefa não encontrada' });
    }
    const validatedData = taskValidationSchema.partial().parse(req.body);
     if (validatedData.dueDate && typeof validatedData.dueDate === 'string') {
      validatedData.dueDate = new Date(validatedData.dueDate);
    }
    const updatedTask = await storage.updateTask(id, validatedData);
    res.json(updatedTask);
  } catch (error: any) {
    if (error.name === 'ZodError') {
      return res.status(400).json({ 
        message: 'Dados inválidos', 
        details: error.errors 
      });
    }
    console.error(`Erro ao atualizar tarefa ${id}:`, error);
    res.status(500).json({ message: 'Erro ao atualizar tarefa' });
  }
};

// Excluir tarefa
export const deleteTask = async (req: Request, res: Response) => {
  const id = parseInt(req.params.id);
  if (isNaN(id)) {
    return res.status(400).json({ message: 'ID inválido' });
  }
  try {
    const existingTask = await storage.getTask(id);
    if (!existingTask) {
      return res.status(404).json({ message: 'Tarefa não encontrada' });
    }
    const deleted = await storage.deleteTask(id);
    if (deleted) {
      res.status(204).end();
    } else {
      res.status(500).json({ message: 'Erro ao excluir tarefa' });
    }
  } catch (error) {
    console.error(`Erro ao excluir tarefa ${id}:`, error);
    res.status(500).json({ message: 'Erro ao excluir tarefa' });
  }
};

// Buscar tarefas por usuário designado
export const getTasksByAssignedTo = async (req: Request, res: Response) => {
  const userId = parseInt(req.params.userId);
  if (isNaN(userId)) {
    return res.status(400).json({ message: 'ID de usuário inválido' });
  }
  try {
    const tasks = await storage.getTasksByAssignedToId(userId);
    const tasksWithUserNames = await addUserNamesToTasks(tasks, storage);
    res.json(tasksWithUserNames);
  } catch (error) {
    console.error(`Erro ao buscar tarefas atribuídas ao usuário ${userId}:`, error);
    res.status(500).json({ message: 'Erro ao buscar tarefas' });
  }
};

// Buscar tarefas por status
export const getTasksByStatus = async (req: Request, res: Response) => {
  const { status } = req.params;
  if (!['backlog', 'pending', 'in_progress', 'completed', 'cancelled'].includes(status)) {
    return res.status(400).json({ message: 'Status inválido' });
  }
  try {
    const tasks = await storage.getTasksByStatus(status);
    const tasksWithUserNames = await addUserNamesToTasks(tasks, storage);
    res.json(tasksWithUserNames);
  } catch (error) {
    console.error(`Erro ao buscar tarefas com status ${status}:`, error);
    res.status(500).json({ message: 'Erro ao buscar tarefas' });
  }
};

// Adicionar comentário a uma tarefa
export const addTaskComment = async (req: Request, res: Response) => {
  const taskId = parseInt(req.params.id);
  if (isNaN(taskId)) {
    return res.status(400).json({ message: 'ID de tarefa inválido' });
  }
  try {
    const existingTask = await storage.getTask(taskId);
    if (!existingTask) {
      return res.status(404).json({ message: 'Tarefa não encontrada' });
    }
    const validatedData = taskCommentValidationSchema.parse({
      ...req.body,
      taskId // Ensure taskId from param is used
    });
    const newComment = await storage.createTaskComment(validatedData);
     // Fetch user info for the new comment to return it with userName
    let commentWithUser = { ...newComment, userName: 'Usuário não encontrado' };
    if (newComment.userId) {
        const commentUser = await storage.getUser(newComment.userId);
        if (commentUser) {
            commentWithUser.userName = commentUser.username;
        }
    }
    res.status(201).json(commentWithUser);
  } catch (error: any) {
    if (error.name === 'ZodError') {
      return res.status(400).json({ 
        message: 'Dados inválidos', 
        details: error.errors 
      });
    }
    console.error(`Erro ao adicionar comentário à tarefa ${taskId}:`, error);
    res.status(500).json({ message: 'Erro ao adicionar comentário' });
  }
};

// Excluir comentário
export const deleteTaskComment = async (req: Request, res: Response) => {
  const id = parseInt(req.params.id);
  if (isNaN(id)) {
    return res.status(400).json({ message: 'ID inválido' });
  }
  try {
    // Optionally, verify if comment exists before deleting or if user has permission
    const deleted = await storage.deleteTaskComment(id);
    if (deleted) {
      res.status(204).end();
    } else {
      // This case could mean comment not found or other DB error
      res.status(404).json({ message: 'Comentário não encontrado ou erro ao excluir' });
    }
  } catch (error) {
    console.error(`Erro ao excluir comentário ${id}:`, error);
    res.status(500).json({ message: 'Erro ao excluir comentário' });
  }
};
</file>

<file path="server/controllers/user.controller.ts">
import type { Request, Response } from "express";
import { storage } from "../storage"; // Adjust path as needed
import { hashPassword } from "../utils/auth.utils"; // Import the moved function
import { professorValidationSchema } from "../../shared/schema";
import { ZodError } from "zod";

// Lista de usuários
export const getAllUsers = async (_req: Request, res: Response) => {
  try {
    const users = await storage.getAllUsers();
    // Remove password hash before sending to client
    const safeUsers = users.map(({ password, ...user }) => user);
    res.json(safeUsers);
  } catch (error) {
    console.error("Erro ao buscar usuários:", error);
    res.status(500).json({ message: "Erro ao buscar usuários" });
  }
};

// Excluir usuário
export const deleteUser = async (req: Request, res: Response) => {
  try {
    const userId = parseInt(req.params.id);

    // Prevent self-deletion
    if (userId === req.user?.id) {
      return res.status(400).json({ message: "Não é possível excluir o próprio usuário" });
    }

    const success = await storage.deleteUser(userId);
    if (success) {
      res.status(200).json({ message: "Usuário excluído com sucesso" });
    } else {
      res.status(404).json({ message: "Usuário não encontrado" });
    }
  } catch (error) {
    console.error("Erro ao excluir usuário:", error);
    res.status(500).json({ message: "Erro ao excluir usuário" });
  }
};

// Criar novo usuário
export const createUser = async (req: Request, res: Response) => {
  try {
    const { username, password, role } = req.body;

    if (!username || !password || !role) {
      return res.status(400).json({ message: "Nome de usuário, senha e perfil são obrigatórios" });
    }

    const existingUser = await storage.getUserByUsername(username);
    if (existingUser) {
      return res.status(400).json({ message: "Nome de usuário já existe" });
    }

    const validRoles = ["admin", "marketing", "comercial", "trainer"];
    if (!validRoles.includes(role)) {
      return res.status(400).json({ message: "Perfil inválido" });
    }

    const hashedPassword = await hashPassword(password);
    const user = await storage.createUser({
      username,
      password: hashedPassword,
      role
    });

    // Return user without password
    const { password: _, ...userWithoutPassword } = user;
    res.status(201).json(userWithoutPassword);
  } catch (error) {
    console.error("Erro ao criar usuário:", error);
    res.status(500).json({ message: "Erro ao criar usuário" });
  }
};

// NOVOS MÉTODOS PARA GESTÃO DE PROFESSORES

// Listar todos os professores
export const getAllProfessors = async (_req: Request, res: Response) => {
  try {
    const professors = await storage.getAllProfessors();
    // Remove password hash before sending to client
    const safeProfessors = professors.map(({ password, ...professor }) => professor);
    res.json(safeProfessors);
  } catch (error) {
    console.error("Erro ao buscar professores:", error);
    res.status(500).json({ message: "Erro ao buscar professores" });
  }
};

// Criar novo professor
export const createProfessor = async (req: Request, res: Response) => {
  try {
    // Validar dados com Zod
    const validatedData = professorValidationSchema.parse(req.body);

    // Verificar se username já existe
    const existingUser = await storage.getUserByUsername(validatedData.username);
    if (existingUser) {
      return res.status(400).json({ message: "Nome de usuário já existe" });
    }

    // Verificar se email já existe (se fornecido)
    if (validatedData.email) {
      const existingEmail = await storage.getUserByEmail(validatedData.email);
      if (existingEmail) {
        return res.status(400).json({ message: "E-mail já existe" });
      }
    }

    // Hash da senha
    const hashedPassword = await hashPassword(validatedData.password);
    
    // Criar professor
    const professor = await storage.createProfessor({
      ...validatedData,
      password: hashedPassword,
      role: "professor" as const,
    });

    // Retornar professor sem senha
    const { password: _, ...professorWithoutPassword } = professor;
    res.status(201).json(professorWithoutPassword);
  } catch (error) {
    if (error instanceof ZodError) {
      return res.status(400).json({
        message: "Dados inválidos",
        errors: error.errors.map(err => ({
          field: err.path.join("."),
          message: err.message
        }))
      });
    }
    console.error("Erro ao criar professor:", error);
    res.status(500).json({ message: "Erro ao criar professor" });
  }
};

// Atualizar professor
export const updateProfessor = async (req: Request, res: Response) => {
  try {
    const professorId = parseInt(req.params.id);
    if (isNaN(professorId)) {
      return res.status(400).json({ message: "ID do professor inválido" });
    }

    // Validar dados (sem senha obrigatória)
    const updateSchema = professorValidationSchema.partial().omit({ password: true });
    const validatedData = updateSchema.parse(req.body);

    // Se senha foi fornecida, hash-la
    if (req.body.password) {
      const hashedPassword = await hashPassword(req.body.password);
      (validatedData as any).password = hashedPassword;
    }

    // Verificar se username já existe (se está sendo alterado)
    if (validatedData.username) {
      const existingUser = await storage.getUserByUsername(validatedData.username);
      if (existingUser && existingUser.id !== professorId) {
        return res.status(400).json({ message: "Nome de usuário já existe" });
      }
    }

    // Verificar se email já existe (se está sendo alterado)
    if (validatedData.email) {
      const existingEmail = await storage.getUserByEmail(validatedData.email);
      if (existingEmail && existingEmail.id !== professorId) {
        return res.status(400).json({ message: "E-mail já existe" });
      }
    }

    const updatedProfessor = await storage.updateProfessor(professorId, validatedData);
    if (!updatedProfessor) {
      return res.status(404).json({ message: "Professor não encontrado" });
    }

    // Retornar professor sem senha
    const { password: _, ...professorWithoutPassword } = updatedProfessor;
    res.json(professorWithoutPassword);
  } catch (error) {
    if (error instanceof ZodError) {
      return res.status(400).json({
        message: "Dados inválidos",
        errors: error.errors.map(err => ({
          field: err.path.join("."),
          message: err.message
        }))
      });
    }
    console.error("Erro ao atualizar professor:", error);
    res.status(500).json({ message: "Erro ao atualizar professor" });
  }
};

// Excluir professor
export const deleteProfessor = async (req: Request, res: Response) => {
  try {
    const professorId = parseInt(req.params.id);
    if (isNaN(professorId)) {
      return res.status(400).json({ message: "ID do professor inválido" });
    }

    // Prevenir auto-exclusão
    if (professorId === req.user?.id) {
      return res.status(400).json({ message: "Não é possível excluir o próprio usuário" });
    }

    // Verificar se professor tem aulas agendadas
    const hasScheduledClasses = await storage.hasScheduledClasses(professorId);
    if (hasScheduledClasses) {
      return res.status(400).json({ 
        message: "Não é possível excluir professor com aulas agendadas. Cancele ou reagende as aulas primeiro." 
      });
    }

    const success = await storage.deleteProfessor(professorId);
    if (success) {
      res.status(200).json({ message: "Professor excluído com sucesso" });
    } else {
      res.status(404).json({ message: "Professor não encontrado" });
    }
  } catch (error) {
    console.error("Erro ao excluir professor:", error);
    res.status(500).json({ message: "Erro ao excluir professor" });
  }
};
</file>

<file path="server/controllers/weather.controller.ts">
import type { Request, Response } from "express";
import { checkWeatherService, getWeatherByCity } from "../weather-service"; // Adjust path as needed

// API de clima - Verificar status do serviço
export const checkStatus = async (req: Request, res: Response) => {
  try {
    const statusResult = await checkWeatherService();
    if (statusResult.status === 'connected') {
      res.json(statusResult);
    } else {
       // Service unavailable or error during check
       console.warn(`Weather service status check failed: ${statusResult.message}`);
      res.status(503).json(statusResult); // Use 503 Service Unavailable
    }
  } catch (error: any) {
    console.error("Erro ao verificar serviço de clima:", error);
    res.status(500).json({ 
      status: 'error', 
      message: `Erro interno ao verificar serviço de clima: ${error.message}` 
    });
  }
};
  
// API de clima - Buscar clima por cidade
export const getWeather = async (req: Request, res: Response) => {
  try {
    const city = req.params.city;
    if (!city) {
      return res.status(400).json({ message: "Nome da cidade é obrigatório" });
    }
    
    const weatherData = await getWeatherByCity(city);
    
    // Handle errors returned from the weather service itself
    if (weatherData.error) {
        console.warn(`Erro da API de clima para ${city}: ${weatherData.error.message} (Code: ${weatherData.error.code})`);
        // If the service indicates an error (like city not found), use 404 or 400.
        // We can't be certain of a specific 'CITY_NOT_FOUND' code string without more info on weather-service.
        const statusCode = weatherData.error.code ? 400 : 404; // Default to 400 if code exists, else 404. More specific handling can be added if error codes are known.
        return res.status(statusCode).json({ 
            message: weatherData.error.message,
            code: weatherData.error.code
        });
    }
      
    res.json(weatherData);
  } catch (error: any) {
    // Handle internal server errors during the process
    console.error(`Erro ao obter dados de clima para ${req.params.city}:`, error);
    res.status(500).json({ 
      message: `Erro interno ao obter dados de clima: ${error.message}` 
    });
  }
};
</file>

<file path="server/controllers/whatsapp.controller.ts">
import type { Request, Response } from "express";
import { db } from "../db";
import { storage } from "../storage";
import { leads, whatsappMessages, type WhatsappMessage } from "@shared/schema"; // Ensure whatsappMessages table schema is imported if needed for raw query
import { sql } from 'drizzle-orm';
import { normalizePhone } from "../utils/lead.utils"; // Import normalizePhone
import { 
  sendWhatsAppMessage, 
  sendWhatsAppTemplate, 
  checkWhatsAppConnection, 
  formatPhoneNumber, 
  sendWhatsAppImage,
  getWhatsAppQRCode,
  checkMessageStatus,
  saveConfigSettings,
  getConfigSettings,
  sendWhatsAppDocument,
  sendWhatsAppAudio,
  sendWhatsAppVideo,
  getWhatsAppGroups,
  createWhatsAppGroup,
  getWhatsAppContacts
} from "../whatsapp-service"; // Adjust path if needed

// Helper to get lead or return 404
const findLeadOr404 = async (leadId: number, res: Response) => {
  if (isNaN(leadId)) {
    res.status(400).json({ message: "ID do lead inválido" });
    return null;
  }
  const lead = await storage.getLead(leadId);
  if (!lead) {
    res.status(404).json({ message: "Lead não encontrado" });
    return null;
  }
  return lead;
};

// Obter todas as mensagens de um lead específico
export const getLeadMessages = async (req: Request, res: Response) => {
  try {
    const leadId = parseInt(req.params.leadId || req.params.id); // Handle potential differences in param name initially
    const lead = await findLeadOr404(leadId, res);
    if (!lead) return;

    const messages = await storage.getWhatsappMessages(leadId);
    // Sort chronologically for display
    messages.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());
    res.json(messages);
  } catch (error) {
    console.error('Erro ao buscar mensagens de WhatsApp do lead:', error);
    res.status(500).json({ message: "Erro ao buscar mensagens de WhatsApp" });
  }
};

// Atualizar status de uma mensagem específica
export const updateMessageStatus = async (req: Request, res: Response) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
       return res.status(400).json({ message: "ID da mensagem inválido" });
    }
    const { status } = req.body;
    if (!status || !['sent', 'delivered', 'read', 'failed', 'received', 'pending'].includes(status)) { // Added 'received', 'pending'
      return res.status(400).json({ message: "Status inválido" });
    }
    const updatedMessage = await storage.updateWhatsappMessageStatus(id, status);
    if (!updatedMessage) {
      return res.status(404).json({ message: "Mensagem não encontrada" });
    }
    res.json(updatedMessage);
  } catch (error) {
    console.error('Erro ao atualizar status da mensagem:', error);
    res.status(500).json({ message: "Erro ao atualizar status da mensagem" });
  }
};

// Excluir uma mensagem específica
export const deleteMessage = async (req: Request, res: Response) => {
  try {
    const id = parseInt(req.params.id);
     if (isNaN(id)) {
       return res.status(400).json({ message: "ID da mensagem inválido" });
    }
    const success = await storage.deleteWhatsappMessage(id);
    if (!success) {
      return res.status(404).json({ message: "Mensagem não encontrada" });
    }
    res.status(204).send();
  } catch (error) {
    console.error('Erro ao excluir mensagem:', error);
    res.status(500).json({ message: "Erro ao excluir mensagem" });
  }
};

// Obter as mensagens mais recentes para cada lead
export const getRecentMessagesPerLead = async (req: Request, res: Response) => {
  try {
    // Using raw query as storage.getRecentWhatsappMessagesPerLead doesn't exist
    const query = sql`
      SELECT DISTINCT ON (lead_id) *
      FROM ${whatsappMessages}
      ORDER BY lead_id, timestamp DESC
    `;
    
    // Use 'any' or a more specific type based on your DB driver's return for raw queries
    const result: any = await db.execute(query); 
    
    const messagesByLead: Record<number, WhatsappMessage> = {};

    // Check if the result has a 'rows' property (common pattern)
    const rows = result?.rows || result; // Adjust based on driver

    if (Array.isArray(rows)) {
         rows.forEach((message: WhatsappMessage) => { // Assume rows are WhatsappMessage objects
             if (message && typeof message.leadId === 'number') { // Basic validation
                 messagesByLead[message.leadId] = message;
             }
         });
    } else {
         console.error("Unexpected result structure from DB query for recent messages:", result);
    }
    res.json(messagesByLead);

  } catch (error) {
    console.error('Erro ao buscar mensagens recentes:', error);
    res.status(500).json({ message: "Erro ao buscar mensagens recentes" });
  }
};


// Verificar conexão com a API do WhatsApp
export const getWhatsappStatus = async (req: Request, res: Response) => {
  try {
    const connectionStatus = await checkWhatsAppConnection();
    if (connectionStatus.success) {
      res.json({ 
        status: 'connected', 
        message: 'Conexão com a API do WhatsApp está funcionando corretamente',
        details: connectionStatus.details || {}
      });
    } else {
      console.warn(`Falha na verificação da conexão WhatsApp: ${connectionStatus.error}`);
      res.status(503).json({ 
        status: 'disconnected', 
        message: connectionStatus.error || 'Falha na conexão com a API do WhatsApp',
        details: connectionStatus.details || {}
      });
    }
  } catch (error: any) {
    console.error(`Erro ao verificar status da API: ${error.message}`, error);
    res.status(500).json({ status: 'error', message: 'Erro ao verificar conexão com a API do WhatsApp' });
  }
};

// Obter configuração da API do WhatsApp
export const getWhatsappConfig = async (req: Request, res: Response) => {
  try {
    const configSettings = await getConfigSettings();
    res.json(configSettings);
  } catch (error: any) {
    console.error('Erro ao obter configurações do WhatsApp:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Erro ao obter configurações do WhatsApp',
      error: error.message || String(error)
    });
  }
};

// Salvar configuração da API do WhatsApp
export const saveWhatsappConfig = async (req: Request, res: Response) => {
  try {
    const { apiUrl, apiToken, apiInstance } = req.body;
    if (!apiUrl) { // Basic validation
      return res.status(400).json({ success: false, message: 'URL da API é obrigatória' });
    }
    const result = await saveConfigSettings(apiUrl, apiToken, apiInstance);
    if (result.success) {
      res.json({ success: true, message: 'Configurações salvas com sucesso', details: result.details });
    } else {
      res.status(400).json({ success: false, message: result.error || 'Falha ao salvar configurações', details: result.details });
    }
  } catch (error: any) {
    console.error('Erro ao salvar configurações do WhatsApp:', error);
    res.status(500).json({ success: false, message: 'Erro interno ao salvar configurações', error: error.message || String(error) });
  }
};

// Obter QR Code para conexão
export const getQRCode = async (req: Request, res: Response) => {
  try {
    const qrCodeResult = await getWhatsAppQRCode();
    if (qrCodeResult.success) {
      res.json({ success: true, details: qrCodeResult.details });
    } else {
      console.warn(`Falha ao obter QR code: ${qrCodeResult.error}`);
      res.status(400).json({ success: false, message: qrCodeResult.error || 'Falha ao obter QR code', details: qrCodeResult.details });
    }
  } catch (error: any) {
    console.error('Erro ao gerar QR code:', error);
    res.status(500).json({ success: false, message: 'Erro interno ao gerar QR code', error: error.message || String(error) });
  }
};

// Verificar status de uma mensagem enviada via API
export const checkApiMessageStatus = async (req: Request, res: Response) => {
  try {
    const { messageId } = req.params;
    if (!messageId) {
      return res.status(400).json({ success: false, message: 'ID da mensagem é obrigatório' });
    }
    
    const message = await storage.getWhatsappMessageByApiId(messageId);
    const statusResult = await checkMessageStatus(messageId);
    
    let updated = false;
    let previousStatus = message?.status;

    if (statusResult.success && message && statusResult.details?.status) {
      const newStatus = statusResult.details.status;
      if (message.status !== newStatus) {
        await storage.updateWhatsappMessageStatus(message.id, newStatus);
        updated = true;
      }
    }

    if (statusResult.success) {
       res.json({ 
          success: true, 
          status: statusResult.details?.status || 'sent', // Default to 'sent' if API doesn't return status?
          originalStatus: statusResult.details?.originalStatus,
          timestamp: statusResult.details?.timestamp,
          message: message ? { // Include info about the message in our DB
            id: message.id,
            leadId: message.leadId,
            previousStatus: previousStatus, // Status before this check
            updated: updated // Did the status change in our DB?
          } : null
        });
    } else {
      console.warn(`Falha ao verificar status da mensagem API ${messageId}: ${statusResult.error}`);
      res.status(400).json({ 
        success: false, 
        message: statusResult.error || 'Falha ao verificar status da mensagem',
        details: statusResult.details || {},
        messageId: messageId
      });
    }
  } catch (error: any) {
    console.error('Erro ao verificar status da mensagem API:', error);
    res.status(500).json({ success: false, message: 'Erro interno ao verificar status da mensagem API', error: error.message || String(error) });
  }
};

// Enviar mensagem de texto
export const sendTextMessage = async (req: Request, res: Response) => {
  try {
    const { leadId, content, direction, status } = req.body;
    if (!leadId || !content) {
      return res.status(400).json({ message: "ID do lead e conteúdo são obrigatórios" });
    }

    const lead = await findLeadOr404(leadId, res);
    if (!lead) return;

    const formattedPhone = formatPhoneNumber(lead.phone);
    if (!formattedPhone) {
      return res.status(400).json({ message: "Número de telefone inválido ou não encontrado para o lead" });
    }

    const messageData: Omit<WhatsappMessage, 'id' | 'timestamp'> = { // Type for insertion
      leadId,
      direction: direction === 'incoming' ? 'incoming' : 'outgoing',
      content,
      status: direction === 'incoming' ? (status || 'received') : 'pending', // Default incoming to received, outgoing to pending
      mediaUrl: null,
      mediaType: null,
      messageId: null // API message ID will be updated later
    };

    const message = await storage.createWhatsappMessage(messageData);

    if (messageData.direction === 'outgoing') {
      const result = await sendWhatsAppMessage(lead, content);
      if (result.success) {
        const finalStatus = 'sent';
        await storage.updateWhatsappMessageStatus(message.id, finalStatus);
        if (result.messageId) {
          await storage.updateWhatsappMessageId(message.id, result.messageId);
        }
        res.status(201).json({ ...message, status: finalStatus, messageId: result.messageId, success: true });
      } else {
        const finalStatus = 'failed';
        await storage.updateWhatsappMessageStatus(message.id, finalStatus);
        const errorMessage = result.error || 'Erro desconhecido';
        const isNotAuthorizedNumber = errorMessage.includes('not in allowed list');
        res.status(400).json({ ...message, status: finalStatus, error: errorMessage, unauthorizedNumber: isNotAuthorizedNumber, success: false });
      }
    } else {
      // If direction was explicitly 'incoming', just confirm it was saved
      res.status(201).json({ ...message, success: true });
    }
  } catch (error: any) {
    console.error('Erro ao enviar mensagem WhatsApp:', error);
    res.status(500).json({ message: "Erro ao enviar mensagem", error: error.message || String(error) });
  }
};

// Enviar imagem
export const sendImageMessage = async (req: Request, res: Response) => {
  try {
    const { leadId, imageUrl, caption } = req.body;
    if (!leadId || !imageUrl) {
      return res.status(400).json({ message: "ID do lead e URL da imagem são obrigatórios" });
    }

    const lead = await findLeadOr404(leadId, res);
    if (!lead) return;

    const formattedPhone = formatPhoneNumber(lead.phone);
    if (!formattedPhone) {
      return res.status(400).json({ message: "Número de telefone inválido ou não encontrado para o lead" });
    }

    const messageData: Omit<WhatsappMessage, 'id' | 'timestamp'> = {
      leadId,
      direction: 'outgoing',
      content: caption || '[Imagem enviada]',
      status: 'pending',
      mediaUrl: imageUrl,
      mediaType: 'image',
      messageId: null
    };

    const message = await storage.createWhatsappMessage(messageData);
    const result = await sendWhatsAppImage(lead, imageUrl, caption || '');

    if (result.success) {
      const finalStatus = 'sent';
      await storage.updateWhatsappMessageStatus(message.id, finalStatus);
      if (result.messageId) {
        await storage.updateWhatsappMessageId(message.id, result.messageId);
      }
      res.status(201).json({ ...message, status: finalStatus, messageId: result.messageId, success: true });
    } else {
      const finalStatus = 'failed';
      await storage.updateWhatsappMessageStatus(message.id, finalStatus);
      const errorMessage = result.error || 'Erro desconhecido';
      const isNotAuthorizedNumber = errorMessage.includes('not in allowed list');
      console.error(`Falha ao enviar imagem WhatsApp: ${errorMessage}`);
      res.status(400).json({ ...message, status: finalStatus, error: errorMessage, unauthorizedNumber: isNotAuthorizedNumber, success: false });
    }
  } catch (error: any) {
    console.error('Erro ao enviar imagem WhatsApp:', error);
    res.status(500).json({ message: "Erro ao enviar imagem", error: error.message || String(error) });
  }
};

// Enviar template
export const sendTemplateMessage = async (req: Request, res: Response) => {
  try {
    const { leadId, templateName, language } = req.body;
    if (!leadId || !templateName) {
      return res.status(400).json({ message: "ID do lead e nome do template são obrigatórios" });
    }

    const lead = await findLeadOr404(leadId, res);
    if (!lead) return;

    const messageData: Omit<WhatsappMessage, 'id' | 'timestamp'> = {
      leadId,
      direction: 'outgoing',
      content: `Template: ${templateName}`, // Store template name as content for reference
      status: 'pending',
      mediaUrl: null,
      mediaType: 'template', // Add a type for templates?
      messageId: null
    };

    const message = await storage.createWhatsappMessage(messageData);
    const result = await sendWhatsAppTemplate(lead, templateName, language || 'pt_BR');

    if (result.success) {
       const finalStatus = 'sent';
      await storage.updateWhatsappMessageStatus(message.id, finalStatus);
      if (result.messageId) {
        await storage.updateWhatsappMessageId(message.id, result.messageId);
      }
       res.status(201).json({ ...message, status: finalStatus, messageId: result.messageId, success: true }); // Return full message object
    } else {
       const finalStatus = 'failed';
      await storage.updateWhatsappMessageStatus(message.id, finalStatus);
      console.error(`Falha ao enviar template WhatsApp: ${result.error}`); // Log error
      res.status(400).json({ ...message, status: finalStatus, error: result.error || 'Erro ao enviar template', success: false }); // Return full message object
    }
  } catch (error: any) {
    console.error('Erro ao enviar template WhatsApp:', error);
    res.status(500).json({ message: "Erro ao enviar template WhatsApp", error: error.message || String(error) });
  }
};

// Manipulador de Webhook (POST) - Tenta lidar com Meta e Evolution API
export const handleWebhook = async (req: Request, res: Response) => {
  try {
    const data = req.body;
    console.log('Webhook POST recebido:', JSON.stringify(data, null, 2));

    // --- Tentativa de Processamento - Formato Meta ---
    if (data?.object === 'whatsapp_business_account' && data?.entry && Array.isArray(data.entry)) {
      console.log("Detectado formato de webhook Meta");
      for (const entry of data.entry) {
        if (!entry.changes || !Array.isArray(entry.changes)) continue;
        for (const change of entry.changes) {
          if (change.field !== 'messages') continue;
          const value = change.value;

          // Processar mensagens recebidas
          if (value?.messages && Array.isArray(value.messages)) {
            for (const message of value.messages) {
              // Só processar mensagens de texto recebidas (ignorar enviadas pelo sistema/echo)
              if (message.from && message.id && message.type === 'text') { // Basic check for incoming text
                const phoneNumber = message.from;
                const messageContent = message.text?.body || '';
                const messageId = message.id;

                const cleanPhone = normalizePhone(phoneNumber); // Use imported utility function
                const leadsFound = await storage.getLeadsByPhone(cleanPhone); // Assumes storage has this method
                
                if (!leadsFound || leadsFound.length === 0) {
                  console.warn(`[Meta Webhook] Mensagem recebida de número não cadastrado: ${phoneNumber}`);
                  continue; // Skip if lead not found
                }
                const lead = leadsFound[0]; // Use the first match

                await storage.createWhatsappMessage({
                  leadId: lead.id,
                  direction: 'incoming',
                  content: messageContent,
                  status: 'received', // Or 'read' if applicable? Check Meta docs
                  messageId: messageId, // Store Meta's message ID
                  mediaUrl: null,
                  mediaType: message.type, // Store 'text'
                });
                console.log(`[Meta Webhook] Mensagem recebida de ${lead.name} (${phoneNumber}) salva.`);
              } else {
                 console.log(`[Meta Webhook] Ignorando mensagem não-texto ou sem remetente: ${message.id}`);
              }
            }
          }

           // Processar atualizações de status de mensagens enviadas
          if (value?.statuses && Array.isArray(value.statuses)) {
             for (const statusUpdate of value.statuses) {
                 if (statusUpdate.id && statusUpdate.status) { // Check if we have API message ID and new status
                    const apiMessageId = statusUpdate.id;
                    const newStatus = statusUpdate.status; // e.g., 'sent', 'delivered', 'read', 'failed'

                    const message = await storage.getWhatsappMessageByApiId(apiMessageId);
                    if (message) {
                       if (message.status !== newStatus) {
                           console.log(`[Meta Webhook] Atualizando status da mensagem ID ${message.id} (API ID: ${apiMessageId}) de ${message.status} para ${newStatus}`);
                           await storage.updateWhatsappMessageStatus(message.id, newStatus);
                       }
                    } else {
                       console.warn(`[Meta Webhook] Recebido status para mensagem API desconhecida: ${apiMessageId}`);
                    }
                 }
             }
          }
        }
      }
      return res.status(200).send('EVENT_RECEIVED'); // Specific response for Meta
    }

    // --- Tentativa de Processamento - Formato Evolution API ---
    // Example check - adjust based on actual Evolution API webhook structure
    if (data?.event === 'messages.upsert' || data?.event === 'messages.update' || data?.appId) { 
      console.log("Detectado formato de webhook Evolution API (ou similar)");
      const event = data.event;
      const messageData = data.data || data.message; // Structure might vary

       // Mensagem Recebida (Evolution Example)
      if ((event === 'messages.upsert' || data.type === 'message') && messageData) {
        const from = messageData?.key?.remoteJid || messageData?.sender || data.from; // Adjust based on actual payload
        const content = messageData?.message?.conversation || messageData?.message?.extendedTextMessage?.text || messageData?.body || messageData?.caption || '[Mensagem sem texto]';
        const messageId = messageData?.key?.id || data.messageId || `incoming_${Date.now()}`; // Adjust based on actual payload
        const mediaUrl = messageData?.mediaUrl || messageData?.url; // Adjust
        const mediaType = messageData?.mediaType || (mediaUrl ? 'image' : null); // Adjust

        if (!from) {
          console.warn('[Evolution Webhook] Número de origem não encontrado');
          return res.status(400).json({ success: false, message: 'Número de origem não encontrado' });
        }
        
        // Find lead by phone number (use normalizePhone and potentially more robust matching)
        const cleanPhone = normalizePhone(from); // Use imported utility function
        const leadsFound = await storage.getLeadsByPhone(cleanPhone); // Assumes storage has this method
        
        if (!leadsFound || leadsFound.length === 0) {
           console.warn(`[Evolution Webhook] Mensagem recebida de número não cadastrado: ${from} (Normalizado: ${cleanPhone})`);
           // Optionally create a new lead here? Or just ignore.
           return res.status(404).json({ success: false, message: 'Lead não encontrado' }); 
        }

        const lead = leadsFound[0]; // Use first match
        await storage.createWhatsappMessage({
          leadId: lead.id,
          direction: 'incoming',
          content,
          status: 'received', 
          messageId, // Store Evolution API's message ID if available
          mediaUrl: mediaUrl || null,
          mediaType: mediaType || null
        });
        console.log(`[Evolution Webhook] Mensagem recebida de ${lead.name} (${from}) salva.`);
        return res.status(201).json({ success: true, message: 'Mensagem recebida salva', leadId: lead.id });
      }
      
      // Atualização de Status (Evolution Example)
      else if (event === 'messages.update' || data.type === 'status') {
          const apiMessageId = data.messageId || data.id; // Adjust field names
          const status = data.status?.status || data.status || data.update?.status || 'unknown'; // Adjust field names
          const validStatuses = ['sent', 'delivered', 'read', 'failed', 'pending', 'received']; // Add Evolution statuses

          if (!apiMessageId) {
              console.warn('[Evolution Webhook] ID da mensagem não encontrado na atualização de status');
              return res.status(400).json({ success: false, message: 'ID da mensagem não encontrado' });
          }

          const message = await storage.getWhatsappMessageByApiId(apiMessageId);
          if (!message) {
              console.warn(`[Evolution Webhook] Recebido status para mensagem API desconhecida: ${apiMessageId}`);
              return res.status(404).json({ success: false, message: 'Mensagem não encontrada' });
          }

          if (validStatuses.includes(status) && message.status !== status) {
               console.log(`[Evolution Webhook] Atualizando status da mensagem ID ${message.id} (API ID: ${apiMessageId}) de ${message.status} para ${status}`);
              await storage.updateWhatsappMessageStatus(message.id, status);
              return res.json({ success: true, message: 'Status atualizado', previousStatus: message.status, newStatus: status });
          } else {
               console.log(`[Evolution Webhook] Status ${status} inválido ou inalterado para mensagem API ${apiMessageId}`);
               return res.json({ success: false, message: 'Status inválido ou inalterado' }); // Or 200 OK?
          }
      }
      
      // Fallback for other Evolution events
      else {
         console.log(`[Evolution Webhook] Evento recebido: ${event || 'Tipo desconhecido'}`);
          return res.json({ success: true, message: 'Evento Evolution recebido', eventType: event || data.type });
      }
    }

    // --- Nenhum formato conhecido ---
    console.warn('Webhook POST recebido com formato não reconhecido:', JSON.stringify(data));
    res.status(400).json({ message: 'Formato de webhook não reconhecido' });

  } catch (error: any) {
    console.error('Erro ao processar webhook WhatsApp POST:', error);
    res.status(500).json({ success: false, message: 'Erro interno ao processar webhook', error: error.message || String(error) });
  }
};

// Manipulador de Verificação de Webhook (GET) - Específico para Meta
export const verifyWebhook = (req: Request, res: Response) => {
  console.log('Webhook GET recebido para verificação:', req.query);
  const mode = req.query['hub.mode'];
  const token = req.query['hub.verify_token'];
  const challenge = req.query['hub.challenge'];

  // Use o token do .env ou um valor padrão seguro
  const verifyToken = process.env.WHATSAPP_WEBHOOK_VERIFY_TOKEN || 'DEFINE_YOUR_SECURE_TOKEN_IN_ENV'; 

  if (mode === 'subscribe' && token === verifyToken) {
    console.log('Webhook Meta verificado com sucesso!');
    res.status(200).send(challenge);
  } else {
    console.warn('Falha na verificação do webhook Meta - Token inválido ou modo incorreto.');
    res.sendStatus(403); // Forbidden
  }
};

// Enviar documento via WhatsApp
export const sendDocumentMessage = async (req: Request, res: Response) => {
  try {
    const { leadId, documentUrl, fileName, caption } = req.body;
    if (!documentUrl || !fileName) {
      return res.status(400).json({ 
        success: false, 
        message: 'URL do documento e nome do arquivo são obrigatórios' 
      });
    }

    const lead = await findLeadOr404(parseInt(leadId), res);
    if (!lead) return;

    const result = await sendWhatsAppDocument(lead, documentUrl, fileName, caption || '');
    
    if (result.success) {
      // Salvar a mensagem no banco de dados
      const message = await storage.createWhatsappMessage({
        leadId: lead.id,
        direction: 'outgoing',
        content: caption || fileName,
        status: 'sent',
        mediaUrl: documentUrl,
        mediaType: 'document',
        messageId: result.messageId
      });
      
      res.status(201).json({
        success: true,
        message: 'Documento enviado com sucesso',
        details: message
      });
    } else {
      res.status(400).json({
        success: false,
        message: result.error || 'Falha ao enviar documento',
        details: result.details
      });
    }
  } catch (error: any) {
    console.error('Erro ao enviar documento via WhatsApp:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Erro interno ao enviar documento'
    });
  }
};

// Enviar áudio via WhatsApp
export const sendAudioMessage = async (req: Request, res: Response) => {
  try {
    const { leadId, audioUrl } = req.body;
    if (!audioUrl) {
      return res.status(400).json({ 
        success: false, 
        message: 'URL do áudio é obrigatória' 
      });
    }

    const lead = await findLeadOr404(parseInt(leadId), res);
    if (!lead) return;

    const result = await sendWhatsAppAudio(lead, audioUrl);
    
    if (result.success) {
      // Salvar a mensagem no banco de dados
      const message = await storage.createWhatsappMessage({
        leadId: lead.id,
        direction: 'outgoing',
        content: 'Áudio',
        status: 'sent',
        mediaUrl: audioUrl,
        mediaType: 'audio',
        messageId: result.messageId
      });
      
      res.status(201).json({
        success: true,
        message: 'Áudio enviado com sucesso',
        details: message
      });
    } else {
      res.status(400).json({
        success: false,
        message: result.error || 'Falha ao enviar áudio',
        details: result.details
      });
    }
  } catch (error: any) {
    console.error('Erro ao enviar áudio via WhatsApp:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Erro interno ao enviar áudio'
    });
  }
};

// Enviar vídeo via WhatsApp
export const sendVideoMessage = async (req: Request, res: Response) => {
  try {
    const { leadId, videoUrl, caption } = req.body;
    if (!videoUrl) {
      return res.status(400).json({ 
        success: false, 
        message: 'URL do vídeo é obrigatória' 
      });
    }

    const lead = await findLeadOr404(parseInt(leadId), res);
    if (!lead) return;

    const result = await sendWhatsAppVideo(lead, videoUrl, caption || '');
    
    if (result.success) {
      // Salvar a mensagem no banco de dados
      const message = await storage.createWhatsappMessage({
        leadId: lead.id,
        direction: 'outgoing',
        content: caption || 'Vídeo',
        status: 'sent',
        mediaUrl: videoUrl,
        mediaType: 'video',
        messageId: result.messageId
      });
      
      res.status(201).json({
        success: true,
        message: 'Vídeo enviado com sucesso',
        details: message
      });
    } else {
      res.status(400).json({
        success: false,
        message: result.error || 'Falha ao enviar vídeo',
        details: result.details
      });
    }
  } catch (error: any) {
    console.error('Erro ao enviar vídeo via WhatsApp:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Erro interno ao enviar vídeo'
    });
  }
};

// Obter grupos do WhatsApp
export const getWhatsappGroups = async (req: Request, res: Response) => {
  try {
    const result = await getWhatsAppGroups();
    
    if (result.success) {
      res.json({
        success: true,
        groups: result.details?.groups || []
      });
    } else {
      res.status(400).json({
        success: false,
        message: result.error || 'Falha ao obter grupos',
        details: result.details
      });
    }
  } catch (error: any) {
    console.error('Erro ao obter grupos de WhatsApp:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Erro interno ao obter grupos'
    });
  }
};

// Criar um grupo de WhatsApp
export const createWhatsappGroup = async (req: Request, res: Response) => {
  try {
    const { name, participants } = req.body;
    
    if (!name || !participants || !Array.isArray(participants) || participants.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'Nome e pelo menos um participante são obrigatórios'
      });
    }
    
    const result = await createWhatsAppGroup(name, participants);
    
    if (result.success) {
      res.status(201).json({
        success: true,
        message: 'Grupo criado com sucesso',
        details: result.details
      });
    } else {
      res.status(400).json({
        success: false,
        message: result.error || 'Falha ao criar grupo',
        details: result.details
      });
    }
  } catch (error: any) {
    console.error('Erro ao criar grupo de WhatsApp:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Erro interno ao criar grupo'
    });
  }
};

// Obter contatos do WhatsApp
export const getWhatsappContacts = async (req: Request, res: Response) => {
  try {
    const result = await getWhatsAppContacts();
    
    if (result.success) {
      res.json({
        success: true,
        contacts: result.details?.contacts || []
      });
    } else {
      res.status(400).json({
        success: false,
        message: result.error || 'Falha ao obter contatos',
        details: result.details
      });
    }
  } catch (error: any) {
    console.error('Erro ao obter contatos de WhatsApp:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Erro interno ao obter contatos'
    });
  }
};
</file>

<file path="server/db.ts">
import { drizzle } from 'drizzle-orm/postgres-js';
import postgres from 'postgres';
import * as schema from "@shared/schema";

if (!process.env.DATABASE_URL) {
  throw new Error(
    "DATABASE_URL must be set. Did you forget to provision a database?",
  );
}

// Configuração para Supabase
const connectionString = process.env.DATABASE_URL;
export const sql = postgres(connectionString, { prepare: false });
export const db = drizzle(sql, { schema });
</file>

<file path="server/email-service.ts">
import { Session, Trainer } from '@shared/schema';
import { formatInTimeZone } from 'date-fns-tz';

// TODO: Implementar configuração de e-mail quando as credenciais estiverem disponíveis
// import nodemailer from 'nodemailer';
// const transporter = nodemailer.createTransport({
//   service: 'gmail',
//   auth: {
//     user: process.env.EMAIL_USER,
//     pass: process.env.EMAIL_PASSWORD,
//   },
// });

// Função de log para usar durante o desenvolvimento
function logEmailContent(subject: string, recipient: string, content: string) {
  console.log(`---------- E-MAIL SIMULADO ----------`);
  console.log(`Para: ${recipient}`);
  console.log(`Assunto: ${subject}`);
  console.log(`Conteúdo: ${content.substring(0, 100)}...`);
  console.log(`------------------------------------`);
}

/**
 * Envia e-mail de confirmação de agendamento para o aluno e professor
 */
export async function sendSessionConfirmationEmail(
  session: Session,
  trainerName: string,
  trainerEmail: string,
  studentName: string,
  studentEmail: string
): Promise<boolean> {
  try {
    const startTime = formatInTimeZone(
      session.startTime instanceof Date ? session.startTime : new Date(session.startTime),
      'America/Sao_Paulo',
      "dd/MM/yyyy 'às' HH:mm"
    );

    const endTime = formatInTimeZone(
      session.endTime instanceof Date ? session.endTime : new Date(session.endTime),
      'America/Sao_Paulo',
      "HH:mm"
    );

    // TODO: Implementar envio real de e-mails quando as credenciais estiverem disponíveis
    // Email para o aluno
    const studentEmailContent = `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; border: 1px solid ${session.source === 'Favale' ? '#0057b7' : '#FF69B4'}; border-radius: 5px;">
        <h2 style="color: ${session.source === 'Favale' ? '#0057b7' : '#FF69B4'}; text-align: center;">${session.source} Personal Training</h2>
        <h3>Confirmação de Agendamento</h3>
        <p>Olá, <strong>${studentName}</strong>!</p>
        <p>Seu treino foi agendado com sucesso.</p>
        <div style="background-color: #f9f9f9; padding: 15px; border-radius: 5px; margin: 15px 0;">
          <p><strong>Data e Hora:</strong> ${startTime} até ${endTime}</p>
          <p><strong>Local:</strong> ${session.location}</p>
          <p><strong>Professor:</strong> ${trainerName}</p>
          ${session.notes ? `<p><strong>Observações:</strong> ${session.notes}</p>` : ''}
        </div>
        <p>Por favor, chegue com alguns minutos de antecedência.</p>
        <p>Em caso de imprevistos ou necessidade de cancelamento, por favor entre em contato com no mínimo 24 horas de antecedência.</p>
        <p>Atenciosamente,<br>Equipe ${session.source} Personal Training</p>
      </div>
    `;
    
    logEmailContent(
      `Confirmação de Agendamento - ${session.source} Personal Training`,
      studentEmail,
      studentEmailContent
    );

    // Email para o professor
    const trainerEmailContent = `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; border: 1px solid ${session.source === 'Favale' ? '#0057b7' : '#FF69B4'}; border-radius: 5px;">
        <h2 style="color: ${session.source === 'Favale' ? '#0057b7' : '#FF69B4'}; text-align: center;">${session.source} Personal Training</h2>
        <h3>Novo Agendamento</h3>
        <p>Olá, <strong>${trainerName}</strong>!</p>
        <p>Uma nova sessão de treino foi agendada para você.</p>
        <div style="background-color: #f9f9f9; padding: 15px; border-radius: 5px; margin: 15px 0;">
          <p><strong>Aluno:</strong> ${studentName}</p>
          <p><strong>Data e Hora:</strong> ${startTime} até ${endTime}</p>
          <p><strong>Local:</strong> ${session.location}</p>
          ${session.notes ? `<p><strong>Observações:</strong> ${session.notes}</p>` : ''}
        </div>
        <p>Este agendamento já foi adicionado ao seu calendário do Google.</p>
        <p>Atenciosamente,<br>Equipe ${session.source} Personal Training</p>
      </div>
    `;
    
    logEmailContent(
      `Novo Agendamento - ${studentName}`,
      trainerEmail,
      trainerEmailContent
    );

    return true;
  } catch (error) {
    console.error('Erro ao enviar email de confirmação:', error);
    return false;
  }
}

/**
 * Envia e-mail de cancelamento de sessão
 */
export async function sendSessionCancellationEmail(
  session: Session,
  trainerName: string,
  trainerEmail: string,
  studentName: string,
  studentEmail: string,
  cancellationReason?: string
): Promise<boolean> {
  try {
    const startTime = formatInTimeZone(
      session.startTime instanceof Date ? session.startTime : new Date(session.startTime),
      'America/Sao_Paulo',
      "dd/MM/yyyy 'às' HH:mm"
    );

    // TODO: Implementar envio real de e-mails quando as credenciais estiverem disponíveis
    // Email para o aluno
    const studentEmailContent = `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; border: 1px solid ${session.source === 'Favale' ? '#0057b7' : '#FF69B4'}; border-radius: 5px;">
        <h2 style="color: ${session.source === 'Favale' ? '#0057b7' : '#FF69B4'}; text-align: center;">${session.source} Personal Training</h2>
        <h3>Cancelamento de Agendamento</h3>
        <p>Olá, <strong>${studentName}</strong>!</p>
        <p>Informamos que sua sessão de treinamento foi <strong>cancelada</strong>.</p>
        <div style="background-color: #f9f9f9; padding: 15px; border-radius: 5px; margin: 15px 0;">
          <p><strong>Data e Hora:</strong> ${startTime}</p>
          <p><strong>Local:</strong> ${session.location}</p>
          <p><strong>Professor:</strong> ${trainerName}</p>
          ${cancellationReason ? `<p><strong>Motivo do cancelamento:</strong> ${cancellationReason}</p>` : ''}
        </div>
        <p>Entre em contato conosco para reagendar sua sessão.</p>
        <p>Atenciosamente,<br>Equipe ${session.source} Personal Training</p>
      </div>
    `;
    
    logEmailContent(
      `Cancelamento de Agendamento - ${session.source} Personal Training`,
      studentEmail,
      studentEmailContent
    );

    // Email para o professor
    const trainerEmailContent = `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; border: 1px solid ${session.source === 'Favale' ? '#0057b7' : '#FF69B4'}; border-radius: 5px;">
        <h2 style="color: ${session.source === 'Favale' ? '#0057b7' : '#FF69B4'}; text-align: center;">${session.source} Personal Training</h2>
        <h3>Sessão Cancelada</h3>
        <p>Olá, <strong>${trainerName}</strong>!</p>
        <p>Informamos que a seguinte sessão de treinamento foi <strong>cancelada</strong>:</p>
        <div style="background-color: #f9f9f9; padding: 15px; border-radius: 5px; margin: 15px 0;">
          <p><strong>Aluno:</strong> ${studentName}</p>
          <p><strong>Data e Hora:</strong> ${startTime}</p>
          <p><strong>Local:</strong> ${session.location}</p>
          ${cancellationReason ? `<p><strong>Motivo do cancelamento:</strong> ${cancellationReason}</p>` : ''}
        </div>
        <p>Este cancelamento já foi atualizado em seu calendário do Google.</p>
        <p>Atenciosamente,<br>Equipe ${session.source} Personal Training</p>
      </div>
    `;
    
    logEmailContent(
      `Sessão Cancelada - ${studentName}`,
      trainerEmail,
      trainerEmailContent
    );

    return true;
  } catch (error) {
    console.error('Erro ao enviar email de cancelamento:', error);
    return false;
  }
}

/**
 * Envia e-mail de lembrete para sessão agendada
 */
export async function sendSessionReminderEmail(
  session: Session,
  trainerName: string,
  studentName: string,
  studentEmail: string
): Promise<boolean> {
  try {
    const startTime = formatInTimeZone(
      session.startTime instanceof Date ? session.startTime : new Date(session.startTime),
      'America/Sao_Paulo',
      "dd/MM/yyyy 'às' HH:mm"
    );

    const endTime = formatInTimeZone(
      session.endTime instanceof Date ? session.endTime : new Date(session.endTime),
      'America/Sao_Paulo',
      "HH:mm"
    );

    // TODO: Implementar envio real de e-mails quando as credenciais estiverem disponíveis
    // Email de lembrete para o aluno
    const reminderEmailContent = `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; border: 1px solid ${session.source === 'Favale' ? '#0057b7' : '#FF69B4'}; border-radius: 5px;">
        <h2 style="color: ${session.source === 'Favale' ? '#0057b7' : '#FF69B4'}; text-align: center;">${session.source} Personal Training</h2>
        <h3>Lembrete de Treino</h3>
        <p>Olá, <strong>${studentName}</strong>!</p>
        <p>Este é um lembrete para o seu treino amanhã:</p>
        <div style="background-color: #f9f9f9; padding: 15px; border-radius: 5px; margin: 15px 0;">
          <p><strong>Data e Hora:</strong> ${startTime} até ${endTime}</p>
          <p><strong>Local:</strong> ${session.location}</p>
          <p><strong>Professor:</strong> ${trainerName}</p>
          ${session.notes ? `<p><strong>Observações:</strong> ${session.notes}</p>` : ''}
        </div>
        <p>Por favor, chegue com alguns minutos de antecedência.</p>
        <p>Em caso de imprevistos ou necessidade de cancelamento, por favor entre em contato com urgência.</p>
        <p>Atenciosamente,<br>Equipe ${session.source} Personal Training</p>
      </div>
    `;
    
    logEmailContent(
      `Lembrete: Seu treino amanhã - ${session.source} Personal Training`,
      studentEmail,
      reminderEmailContent
    );

    return true;
  } catch (error) {
    console.error('Erro ao enviar email de lembrete:', error);
    return false;
  }
}

/**
 * Envia e-mail de notificação de reagendamento
 */
export async function sendSessionRescheduledEmail(
  oldSession: Session,
  newSession: Session,
  trainerName: string,
  trainerEmail: string,
  studentName: string,
  studentEmail: string
): Promise<boolean> {
  try {
    const oldStartTime = formatInTimeZone(
      oldSession.startTime instanceof Date ? oldSession.startTime : new Date(oldSession.startTime),
      'America/Sao_Paulo',
      "dd/MM/yyyy 'às' HH:mm"
    );

    const newStartTime = formatInTimeZone(
      newSession.startTime instanceof Date ? newSession.startTime : new Date(newSession.startTime),
      'America/Sao_Paulo',
      "dd/MM/yyyy 'às' HH:mm"
    );

    const newEndTime = formatInTimeZone(
      newSession.endTime instanceof Date ? newSession.endTime : new Date(newSession.endTime),
      'America/Sao_Paulo',
      "HH:mm"
    );

    // TODO: Implementar envio real de e-mails quando as credenciais estiverem disponíveis
    // Email para o aluno
    const studentEmailContent = `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; border: 1px solid ${newSession.source === 'Favale' ? '#0057b7' : '#FF69B4'}; border-radius: 5px;">
        <h2 style="color: ${newSession.source === 'Favale' ? '#0057b7' : '#FF69B4'}; text-align: center;">${newSession.source} Personal Training</h2>
        <h3>Sessão Reagendada</h3>
        <p>Olá, <strong>${studentName}</strong>!</p>
        <p>Sua sessão de treinamento foi <strong>reagendada</strong>:</p>
        <div style="background-color: #f9f9f9; padding: 15px; border-radius: 5px; margin: 15px 0;">
          <p><strong>Data e Hora Original:</strong> ${oldStartTime}</p>
          <p><strong>Nova Data e Hora:</strong> ${newStartTime} até ${newEndTime}</p>
          <p><strong>Local:</strong> ${newSession.location}</p>
          <p><strong>Professor:</strong> ${trainerName}</p>
          ${newSession.notes ? `<p><strong>Observações:</strong> ${newSession.notes}</p>` : ''}
        </div>
        <p>Por favor, confirme se o novo horário funciona para você. Caso contrário, entre em contato conosco.</p>
        <p>Atenciosamente,<br>Equipe ${newSession.source} Personal Training</p>
      </div>
    `;
    
    logEmailContent(
      `Sessão Reagendada - ${newSession.source} Personal Training`,
      studentEmail,
      studentEmailContent
    );

    // Email para o professor
    const trainerEmailContent = `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; border: 1px solid ${newSession.source === 'Favale' ? '#0057b7' : '#FF69B4'}; border-radius: 5px;">
        <h2 style="color: ${newSession.source === 'Favale' ? '#0057b7' : '#FF69B4'}; text-align: center;">${newSession.source} Personal Training</h2>
        <h3>Sessão Reagendada</h3>
        <p>Olá, <strong>${trainerName}</strong>!</p>
        <p>Uma sessão de treinamento foi <strong>reagendada</strong>:</p>
        <div style="background-color: #f9f9f9; padding: 15px; border-radius: 5px; margin: 15px 0;">
          <p><strong>Aluno:</strong> ${studentName}</p>
          <p><strong>Data e Hora Original:</strong> ${oldStartTime}</p>
          <p><strong>Nova Data e Hora:</strong> ${newStartTime} até ${newEndTime}</p>
          <p><strong>Local:</strong> ${newSession.location}</p>
          ${newSession.notes ? `<p><strong>Observações:</strong> ${newSession.notes}</p>` : ''}
        </div>
        <p>Esta alteração já foi atualizada em seu calendário do Google.</p>
        <p>Atenciosamente,<br>Equipe ${newSession.source} Personal Training</p>
      </div>
    `;
    
    logEmailContent(
      `Sessão Reagendada - ${studentName}`,
      trainerEmail,
      trainerEmailContent
    );

    return true;
  } catch (error) {
    console.error('Erro ao enviar email de reagendamento:', error);
    return false;
  }
}
</file>

<file path="server/google-calendar.ts">
import { calendar as googleCalendar, auth as googleAuth } from '@googleapis/calendar';
import { storage } from './storage';
import { Trainer, Session } from '@shared/schema';
import { formatInTimeZone } from 'date-fns-tz';

// Configuração do OAuth2
const oauth2Client = new googleAuth.OAuth2(
  process.env.GOOGLE_CLIENT_ID,
  process.env.GOOGLE_CLIENT_SECRET,
  process.env.GOOGLE_REDIRECT_URI || `${process.env.REPL_URL || 'http://localhost:5000'}/api/oauth/google/callback`
);

// Criar uma instância da API do Calendar
const calendar = googleCalendar({ version: 'v3', auth: oauth2Client });

// TODO: Implementar modo de teste para desenvolvimento sem API keys
const isTestMode = !process.env.GOOGLE_CLIENT_ID || !process.env.GOOGLE_CLIENT_SECRET;

// Função para simular requisições do calendar em modo de teste
function simulateCalendarOperation(operation: string, data: any = {}): any {
  console.log(`[SIMULAÇÃO GOOGLE CALENDAR] ${operation}`, data);
  
  // Simular dados de resposta com base na operação
  if (operation === 'insert') {
    return { data: { id: `fake-event-${Date.now()}` } };
  } else if (operation === 'update' || operation === 'delete') {
    return { data: { updated: true } };
  } else if (operation === 'list') {
    return { data: { items: [] } };
  }
  
  return { data: {} };
}

// Escopos necessários para acessar o calendar
const SCOPES = [
  'https://www.googleapis.com/auth/calendar',
  'https://www.googleapis.com/auth/calendar.events'
];

/**
 * Gera a URL de autorização para o Google
 */
export function getAuthUrl(): string {
  if (isTestMode) {
    console.log(`[SIMULAÇÃO GOOGLE CALENDAR] getAuthUrl`);
    return 'https://teste-oauth-url.example.com/authorize';
  }
  
  return oauth2Client.generateAuthUrl({
    access_type: 'offline',
    scope: SCOPES,
    prompt: 'consent'
  });
}

/**
 * Troca o código de autorização por tokens de acesso e atualização
 */
export async function getTokensFromCode(code: string): Promise<{
  access_token: string;
  refresh_token?: string;
  expiry_date: number;
}> {
  if (isTestMode) {
    console.log(`[SIMULAÇÃO GOOGLE CALENDAR] getTokensFromCode ${code}`);
    return {
      access_token: 'fake-access-token',
      refresh_token: 'fake-refresh-token',
      expiry_date: Date.now() + 3600000, // 1 hora a partir de agora
    };
  }
  
  const { tokens } = await oauth2Client.getToken(code);
  return {
    access_token: tokens.access_token!,
    refresh_token: tokens.refresh_token,
    expiry_date: tokens.expiry_date!,
  };
}

/**
 * Define as credenciais para o cliente OAuth2
 */
export function setCredentials(tokens: {
  access_token: string;
  refresh_token?: string;
  expiry_date: number;
}): void {
  if (isTestMode) {
    console.log(`[SIMULAÇÃO GOOGLE CALENDAR] setCredentials`, tokens);
    return;
  }
  
  oauth2Client.setCredentials({
    access_token: tokens.access_token,
    refresh_token: tokens.refresh_token,
    expiry_date: tokens.expiry_date
  });
}

/**
 * Carrega tokens de um usuário e configura as credenciais
 */
export async function loadUserCredentials(userId: number): Promise<boolean> {
  if (isTestMode) {
    console.log(`[SIMULAÇÃO GOOGLE CALENDAR] loadUserCredentials for user ${userId}`);
    return true;
  }
  
  try {
    const tokens = await storage.getGoogleTokens(userId);
    if (!tokens) {
      return false;
    }
    
    setCredentials(tokens);
    
    // Verificar se o token precisa ser renovado
    const now = Date.now();
    if (tokens.expiry_date <= now + 300000) { // Renovar se expira em 5 minutos
      await refreshTokenIfNeeded(userId);
    }
    
    return true;
  } catch (error) {
    console.error('Erro ao carregar credenciais do usuário:', error);
    return false;
  }
}

/**
 * Renova o token de acesso se necessário
 */
async function refreshTokenIfNeeded(userId: number): Promise<void> {
  try {
    const tokens = await storage.getGoogleTokens(userId);
    if (!tokens?.refresh_token) {
      throw new Error('Refresh token não disponível');
    }
    
    oauth2Client.setCredentials({
      refresh_token: tokens.refresh_token
    });
    
    const { credentials } = await oauth2Client.refreshAccessToken();
    
    if (credentials.access_token && credentials.expiry_date) {
      const newTokens = {
        access_token: credentials.access_token,
        refresh_token: credentials.refresh_token || tokens.refresh_token,
        expiry_date: credentials.expiry_date
      };
      
      await storage.saveGoogleTokens(userId, newTokens);
      setCredentials(newTokens);
    }
  } catch (error) {
    console.error('Erro ao renovar token:', error);
    throw error;
  }
}

/**
 * Cria um evento no Google Calendar
 */
export async function createCalendarEvent(session: Session, trainer: Trainer, studentName: string): Promise<string | null> {
  try {
    // Formatar as datas para ISO
    const startTimeISO = session.startTime instanceof Date ? 
      formatInTimeZone(session.startTime, 'America/Sao_Paulo', "yyyy-MM-dd'T'HH:mm:ss.SSSxxx") : 
      formatInTimeZone(new Date(session.startTime), 'America/Sao_Paulo', "yyyy-MM-dd'T'HH:mm:ss.SSSxxx");
    
    const endTimeISO = session.endTime instanceof Date ? 
      formatInTimeZone(session.endTime, 'America/Sao_Paulo', "yyyy-MM-dd'T'HH:mm:ss.SSSxxx") : 
      formatInTimeZone(new Date(session.endTime), 'America/Sao_Paulo', "yyyy-MM-dd'T'HH:mm:ss.SSSxxx");

    // Cor do evento baseada na fonte (Favale = azul, Pink = rosa)
    const colorId = session.source === 'Favale' ? '1' : '3'; // 1=azul, 3=roxo/rosa
    
    // Criar o evento
    const event = {
      summary: `Treino ${session.source}: ${studentName}`,
      location: session.location,
      description: session.notes || `Sessão de treinamento para ${studentName}`,
      start: {
        dateTime: startTimeISO,
        timeZone: 'America/Sao_Paulo',
      },
      end: {
        dateTime: endTimeISO,
        timeZone: 'America/Sao_Paulo',
      },
      colorId: colorId,
      attendees: [
        { email: trainer.email, responseStatus: 'accepted' },
      ],
      reminders: {
        useDefault: false,
        overrides: [
          { method: 'email', minutes: 24 * 60 }, // 1 dia antes
          { method: 'popup', minutes: 60 } // 1 hora antes
        ],
      },
    };

    // ID do calendário do professor ou o calendário primário se não especificado
    const calendarId = trainer.calendarId || 'primary';

    // Modo de teste ou produção
    let response;
    if (isTestMode) {
      // Simular operação do Google Calendar em modo de teste
      response = simulateCalendarOperation('insert', {
        calendarId,
        event,
        studentName,
        trainerEmail: trainer.email
      });
    } else {
      // Fazer requisição real ao Google Calendar
      response = await calendar.events.insert({
        calendarId: calendarId,
        requestBody: event,
        sendNotifications: true,
      });
    }

    return response.data.id || null;
  } catch (error) {
    console.error('Erro ao criar evento no Google Calendar:', error);
    return null;
  }
}

/**
 * Atualiza um evento no Google Calendar
 */
export async function updateCalendarEvent(
  session: Session, 
  trainer: Trainer, 
  studentName: string, 
  eventId: string
): Promise<boolean> {
  try {
    // Formatar as datas para ISO
    const startTimeISO = session.startTime instanceof Date ? 
      formatInTimeZone(session.startTime, 'America/Sao_Paulo', "yyyy-MM-dd'T'HH:mm:ss.SSSxxx") : 
      formatInTimeZone(new Date(session.startTime), 'America/Sao_Paulo', "yyyy-MM-dd'T'HH:mm:ss.SSSxxx");
    
    const endTimeISO = session.endTime instanceof Date ? 
      formatInTimeZone(session.endTime, 'America/Sao_Paulo', "yyyy-MM-dd'T'HH:mm:ss.SSSxxx") : 
      formatInTimeZone(new Date(session.endTime), 'America/Sao_Paulo', "yyyy-MM-dd'T'HH:mm:ss.SSSxxx");

    // Cor do evento baseada na fonte (Favale = azul, Pink = rosa)
    const colorId = session.source === 'Favale' ? '1' : '3'; // 1=azul, 3=roxo/rosa

    // Dados atualizados do evento
    const event = {
      summary: `Treino ${session.source}: ${studentName}`,
      location: session.location,
      description: session.notes || `Sessão de treinamento para ${studentName}`,
      start: {
        dateTime: startTimeISO,
        timeZone: 'America/Sao_Paulo',
      },
      end: {
        dateTime: endTimeISO,
        timeZone: 'America/Sao_Paulo',
      },
      colorId: colorId,
      attendees: [
        { email: trainer.email, responseStatus: 'accepted' },
      ],
      reminders: {
        useDefault: false,
        overrides: [
          { method: 'email', minutes: 24 * 60 }, // 1 dia antes
          { method: 'popup', minutes: 60 } // 1 hora antes
        ],
      },
    };
    
    // ID do calendário do professor ou o calendário primário se não especificado
    const calendarId = trainer.calendarId || 'primary';
    
    // Modo de teste ou produção
    if (isTestMode) {
      // Simular operação do Google Calendar em modo de teste
      simulateCalendarOperation('update', {
        calendarId,
        eventId,
        event,
        studentName,
        trainerEmail: trainer.email
      });
    } else {
      // Fazer requisição real ao Google Calendar
      await calendar.events.update({
        calendarId: calendarId,
        eventId: eventId,
        requestBody: event,
        sendNotifications: true,
      });
    }
    
    return true;
  } catch (error) {
    console.error('Erro ao atualizar evento no Google Calendar:', error);
    return false;
  }
}

/**
 * Cancela (exclui) um evento no Google Calendar
 */
export async function deleteCalendarEvent(trainer: Trainer, eventId: string): Promise<boolean> {
  try {
    // ID do calendário do professor ou o calendário primário se não especificado
    const calendarId = trainer.calendarId || 'primary';
    
    // Modo de teste ou produção
    if (isTestMode) {
      // Simular operação do Google Calendar em modo de teste
      simulateCalendarOperation('delete', {
        calendarId,
        eventId,
        trainerEmail: trainer.email
      });
    } else {
      // Fazer requisição real ao Google Calendar
      await calendar.events.delete({
        calendarId: calendarId,
        eventId: eventId,
        sendNotifications: true,
      });
    }
    
    return true;
  } catch (error) {
    console.error('Erro ao excluir evento no Google Calendar:', error);
    return false;
  }
}

/**
 * Verifica disponibilidade do professor em um período específico
 */
export async function checkTrainerAvailability(
  trainer: Trainer, 
  startTime: Date, 
  endTime: Date
): Promise<boolean> {
  try {
    // ID do calendário do professor ou o calendário primário se não especificado
    const calendarId = trainer.calendarId || 'primary';
    
    // Formatar as datas para ISO
    const startTimeISO = formatInTimeZone(startTime, 'America/Sao_Paulo', "yyyy-MM-dd'T'HH:mm:ss.SSSxxx");
    const endTimeISO = formatInTimeZone(endTime, 'America/Sao_Paulo', "yyyy-MM-dd'T'HH:mm:ss.SSSxxx");
    
    // Modo de teste ou produção
    let response;
    if (isTestMode) {
      // Simular operação do Google Calendar em modo de teste
      response = simulateCalendarOperation('list', {
        calendarId,
        timeMin: startTimeISO,
        timeMax: endTimeISO,
        trainerEmail: trainer.email
      });
      // Em modo de teste, sempre retornar disponível
      return true;
    } else {
      // Fazer requisição real ao Google Calendar
      response = await calendar.events.list({
        calendarId: calendarId,
        timeMin: startTimeISO,
        timeMax: endTimeISO,
        singleEvents: true,
        orderBy: 'startTime',
      });
      
      // Se não há eventos no período, o professor está disponível
      return response.data.items && response.data.items.length === 0;
    }
  } catch (error) {
    console.error('Erro ao verificar disponibilidade do professor:', error);
    return false;
  }
}

/**
 * Obtém todos os eventos do calendário de um professor em um período
 */
export async function getTrainerEvents(
  trainer: Trainer, 
  startDate: Date, 
  endDate: Date
): Promise<any[]> {
  try {
    // ID do calendário do professor ou o calendário primário se não especificado
    const calendarId = trainer.calendarId || 'primary';
    
    // Formatar as datas para ISO
    const startTimeISO = formatInTimeZone(startDate, 'America/Sao_Paulo', "yyyy-MM-dd'T'HH:mm:ss.SSSxxx");
    const endTimeISO = formatInTimeZone(endDate, 'America/Sao_Paulo', "yyyy-MM-dd'T'HH:mm:ss.SSSxxx");
    
    // Modo de teste ou produção
    let response;
    if (isTestMode) {
      // Simular operação do Google Calendar em modo de teste
      response = simulateCalendarOperation('list', {
        calendarId,
        timeMin: startTimeISO,
        timeMax: endTimeISO,
        trainerEmail: trainer.email
      });
      // Em modo de teste, retornar um array vazio
      return [];
    } else {
      // Fazer requisição real ao Google Calendar
      response = await calendar.events.list({
        calendarId: calendarId,
        timeMin: startTimeISO,
        timeMax: endTimeISO,
        singleEvents: true,
        orderBy: 'startTime',
      });
      
      return response.data.items || [];
    }
  } catch (error) {
    console.error('Erro ao obter eventos do professor:', error);
    return [];
  }
}
</file>

<file path="server/index.ts">
// Carregar variáveis de ambiente no início da aplicação
import 'dotenv/config';

import express, { type Request, Response, NextFunction } from "express";
import { registerRoutes } from "./routes";
import { setupVite, serveStatic, log } from "./vite";
import { validateProductionEnvironment, setupSecurityHeaders, setupHealthCheck, getProductionConfig } from "./production-config";
import type { Server } from "http";

// Production environment check
const isProduction = process.env.NODE_ENV === 'production';
const isDevelopment = process.env.NODE_ENV === 'development';

if (isProduction) {
  log('Starting application in production mode', 'startup');
  validateProductionEnvironment();
} else {
  log('Starting application in development mode', 'startup');
  // Basic environment validation for development
  const requiredEnvVars = ['DATABASE_URL'];
  const missingEnvVars = requiredEnvVars.filter(envVar => !process.env[envVar]);

  if (missingEnvVars.length > 0) {
    console.error(`Missing required environment variables: ${missingEnvVars.join(', ')}`);
    process.exit(1);
  }
}

const app = express();

// Setup production security headers and CORS
if (isProduction) {
  setupSecurityHeaders(app);
}

// Aumentar o limite de tamanho para processamento de dados grandes (50MB)
app.use(express.json({ limit: '50mb' }));
app.use(express.urlencoded({ extended: false, limit: '50mb' }));

app.use((req, res, next) => {
  const start = Date.now();
  const path = req.path;
  let capturedJsonResponse: Record<string, any> | undefined = undefined;

  const originalResJson = res.json;
  res.json = function (bodyJson, ...args) {
    capturedJsonResponse = bodyJson;
    return originalResJson.apply(res, [bodyJson, ...args]);
  };

  res.on("finish", () => {
    const duration = Date.now() - start;
    if (path.startsWith("/api")) {
      let logLine = `${req.method} ${path} ${res.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }

      if (logLine.length > 80) {
        logLine = logLine.slice(0, 79) + "…";
      }

      log(logLine);
    }
  });

  next();
});

// Global error handlers for uncaught exceptions
process.on('uncaughtException', (error) => {
  console.error('Uncaught Exception:', error);
  process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('Unhandled Rejection at:', promise, 'reason:', reason);
  process.exit(1);
});

let server: Server;

// Graceful shutdown handler
const gracefulShutdown = (signal: string) => {
  log(`Received ${signal}, shutting down gracefully...`, 'shutdown');
  
  if (server) {
    server.close(() => {
      log('HTTP server closed', 'shutdown');
      process.exit(0);
    });

    // Force shutdown after 30 seconds
    setTimeout(() => {
      log('Forcing shutdown after timeout', 'shutdown');
      process.exit(1);
    }, 30000);
  } else {
    process.exit(0);
  }
};

// Register shutdown handlers
process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
process.on('SIGINT', () => gracefulShutdown('SIGINT'));

(async () => {
  try {
    server = await registerRoutes(app);

    // Enhanced error handling middleware
    app.use((err: any, _req: Request, res: Response, _next: NextFunction) => {
      const status = err.status || err.statusCode || 500;
      const message = err.message || "Internal Server Error";

      // Log error details in production
      if (isProduction) {
        console.error('Server Error:', {
          status,
          message,
          stack: err.stack,
          url: _req.url,
          method: _req.method,
          timestamp: new Date().toISOString()
        });
      }

      res.status(status).json({ 
        message: isProduction ? "Internal Server Error" : message,
        ...(isDevelopment && { stack: err.stack })
      });
    });

    // Setup Vite in development or serve static files in production
    if (isDevelopment || app.get("env") === "development") {
      await setupVite(app, server);
    } else {
      serveStatic(app);
    }

    // Setup health check endpoints before starting server
    setupHealthCheck(app);

    // Port configuration with Cloud Run compatibility
    const config = isProduction ? getProductionConfig() : { port: 5000, host: "127.0.0.1" };
    const port = config.port;
    const host = config.host;

    // Only use reusePort if not on Windows
    const isWindows = process.platform === 'win32';
    const listenOptions: any = { port: Number(port), host };
    if (!isProduction && !isWindows) {
      listenOptions.reusePort = true;
    }

    server.listen(listenOptions, () => {
      log(`Server running on ${host}:${port} in ${process.env.NODE_ENV || 'development'} mode`, 'startup');
      
      if (isProduction) {
        log('Production mode active - Security headers enabled', 'startup');
        log('Health check endpoints: /health, /ready, /live', 'startup');
      }
    });

  } catch (error) {
    console.error('Failed to start server:', error);
    process.exit(1);
  }
})();
</file>

<file path="server/middlewares/auth.middleware.ts">
import type { Request, Response, NextFunction } from "express";

// Middleware para checar autenticação sem exigir admin
export function isAuthenticated(req: Request, res: Response, next: NextFunction) {
  if (!req.isAuthenticated()) {
    return res.status(401).json({ message: "Não autenticado" });
  }
  next();
}

// Middleware para checar se é administrador
export function isAdmin(req: Request, res: Response, next: NextFunction) {
  if (!req.isAuthenticated()) {
    // Check authentication first, as isAdmin implies isAuthenticated
    return res.status(401).json({ message: "Não autenticado" });
  }
  if (req.user?.role !== "admin") {
    return res.status(403).json({ message: "Acesso negado" });
  }
  next();
}
</file>

<file path="server/middlewares/error.middleware.ts">
import { Request, Response, NextFunction } from 'express';

export interface AppError extends Error {
  statusCode?: number;
  isOperational?: boolean;
}

export const createError = (message: string, statusCode: number = 500): AppError => {
  const error: AppError = new Error(message);
  error.statusCode = statusCode;
  error.isOperational = true;
  return error;
};

export const errorHandler = (
  error: AppError,
  req: Request,
  res: Response,
  next: NextFunction
) => {
  const statusCode = error.statusCode || 500;
  const message = error.message || 'Erro interno do servidor';

  // Log do erro para debugging
  console.error(`[${new Date().toISOString()}] ${statusCode} - ${message}`, {
    url: req.url,
    method: req.method,
    ip: req.ip,
    userAgent: req.get('User-Agent'),
    stack: error.stack
  });

  // Resposta de erro padronizada
  res.status(statusCode).json({
    success: false,
    message,
    timestamp: new Date().toISOString(),
    path: req.url,
    ...(process.env.NODE_ENV === 'development' && { stack: error.stack })
  });
};

export const notFoundHandler = (req: Request, res: Response) => {
  res.status(404).json({
    success: false,
    message: `Rota ${req.method} ${req.url} não encontrada`,
    timestamp: new Date().toISOString(),
    path: req.url
  });
};

export const asyncHandler = (fn: Function) => {
  return (req: Request, res: Response, next: NextFunction) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
};
</file>

<file path="server/migrations/create-google-tokens-table.js">
import pkg from 'pg';
const { Pool } = pkg;
import dotenv from 'dotenv';

dotenv.config();

async function createGoogleTokensTable() {
  const pool = new Pool({
    connectionString: process.env.DATABASE_URL,
  });

  try {
    // Criar tabela para tokens do Google OAuth2
    await pool.query(`
      CREATE TABLE IF NOT EXISTS google_tokens (
        id SERIAL PRIMARY KEY,
        userId INTEGER NOT NULL,
        accessToken TEXT NOT NULL,
        refreshToken TEXT,
        expiryDate BIGINT NOT NULL,
        updatedAt TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(userId)
      )
    `);

    console.log('✅ Tabela google_tokens criada com sucesso');
  } catch (error) {
    console.error('❌ Erro ao criar tabela google_tokens:', error);
    throw error;
  } finally {
    await pool.end();
  }
}

// Executar se for chamado diretamente
if (import.meta.url === `file://${process.argv[1]}`) {
  createGoogleTokensTable();
}

export { createGoogleTokensTable };
</file>

<file path="server/production-config.ts">
/**
 * Production-specific configuration and utilities
 */

import { log } from "./vite";

export interface ProductionConfig {
  port: number;
  host: string;
  corsOrigins: string[];
  logLevel: 'error' | 'warn' | 'info' | 'debug';
  healthCheckPath: string;
  shutdownTimeout: number;
}

/**
 * Get production configuration with environment variable validation
 */
export function getProductionConfig(): ProductionConfig {
  const config: ProductionConfig = {
    port: parseInt(process.env.PORT || '5000'),
    host: process.env.HOST || '0.0.0.0',
    corsOrigins: process.env.CORS_ORIGINS ? process.env.CORS_ORIGINS.split(',') : ['*'],
    logLevel: (process.env.LOG_LEVEL as ProductionConfig['logLevel']) || 'info',
    healthCheckPath: process.env.HEALTH_CHECK_PATH || '/health',
    shutdownTimeout: parseInt(process.env.SHUTDOWN_TIMEOUT || '30000'),
  };

  // Validate port range
  if (config.port < 1 || config.port > 65535) {
    throw new Error(`Invalid port number: ${config.port}. Must be between 1 and 65535.`);
  }

  log(`Production config loaded - Port: ${config.port}, Host: ${config.host}`, 'production');
  
  return config;
}

/**
 * Validate required environment variables for production
 */
export function validateProductionEnvironment(): void {
  const requiredVars = [
    'DATABASE_URL',
    // Add other required production environment variables here
  ];

  const optionalVars = [
    'EVOLUTION_API_URL',
    'EVOLUTION_API_TOKEN',
    'OPENWEATHER_API_KEY',
    'SENDGRID_API_KEY',
    'GOOGLE_CLIENT_ID',
    'GOOGLE_CLIENT_SECRET',
  ];

  const missing = requiredVars.filter(varName => !process.env[varName]);
  
  if (missing.length > 0) {
    console.error('❌ Missing required environment variables:', missing.join(', '));
    throw new Error(`Missing required environment variables: ${missing.join(', ')}`);
  }

  const missingOptional = optionalVars.filter(varName => !process.env[varName]);
  if (missingOptional.length > 0) {
    console.warn('⚠️  Missing optional environment variables (some features may be disabled):', missingOptional.join(', '));
  }

  console.log('✅ Environment validation passed');
}

/**
 * Setup production security headers
 */
export function setupSecurityHeaders(app: any): void {
  // Security middleware
  app.use((req: any, res: any, next: any) => {
    // Security headers
    res.setHeader('X-Content-Type-Options', 'nosniff');
    res.setHeader('X-Frame-Options', 'DENY');
    res.setHeader('X-XSS-Protection', '1; mode=block');
    res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');
    
    // CORS handling
    const corsOrigins = process.env.CORS_ORIGINS?.split(',') || ['*'];
    const origin = req.headers.origin;
    
    if (corsOrigins.includes('*') || (origin && corsOrigins.includes(origin))) {
      res.setHeader('Access-Control-Allow-Origin', origin || '*');
    }
    
    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-Requested-With');
    res.setHeader('Access-Control-Allow-Credentials', 'true');

    // Handle preflight requests
    if (req.method === 'OPTIONS') {
      return res.status(204).end();
    }

    next();
  });

  log('Security headers configured', 'production');
}

/**
 * Setup health check endpoint for Cloud Run and other platforms
 */
export function setupHealthCheck(app: any): void {
  const healthPath = process.env.HEALTH_CHECK_PATH || '/health';
  
  app.get(healthPath, (req: any, res: any) => {
    const healthData = {
      status: 'healthy',
      timestamp: new Date().toISOString(),
      environment: process.env.NODE_ENV || 'unknown',
      version: process.env.npm_package_version || '1.0.0',
      uptime: process.uptime(),
      memory: process.memoryUsage(),
    };

    res.status(200).json(healthData);
  });

  // Readiness probe (for Kubernetes/Cloud Run)
  app.get('/ready', (req: any, res: any) => {
    res.status(200).json({ status: 'ready' });
  });

  // Liveness probe (for Kubernetes/Cloud Run)
  app.get('/live', (req: any, res: any) => {
    res.status(200).json({ status: 'alive' });
  });

  log(`Health check endpoints configured: ${healthPath}, /ready, /live`, 'production');
}
</file>

<file path="server/routes.ts">
import type { Express, Request, Response, NextFunction } from "express";
import { createServer, type Server } from "http";
import { storage, type IStorage } from "./storage";
import { db } from "./db";
import { 
  leads, sessions, users, aulas, agendamentosRecorrentes, services,
  insertLeadSchema, leadValidationSchema, whatsappMessageValidationSchema,
  taskValidationSchema, taskCommentValidationSchema,
  type Session, type Student, type WhatsappMessage
} from "@shared/schema";
import * as schema from "@shared/schema";
import { eq, desc, and, or, like, isNull, isNotNull, count, sql as drizzleSql, inArray, gte, lte } from "drizzle-orm";
import { randomUUID } from "crypto";
import { fromZodError } from "zod-validation-error";
import { setupAuth } from "./auth";
import { logAuditEvent, AuditEventType, getRecentAuditLogs } from "./audit-log";
import { 
  sendWhatsAppMessage, 
  sendWhatsAppTemplate, 
  checkWhatsAppConnection, 
  formatPhoneNumber, 
  sendWhatsAppImage,
  getWhatsAppQRCode,
  checkMessageStatus,
  saveConfigSettings,
  getConfigSettings
} from "./whatsapp-service";
import { getWeatherByCity, checkWeatherService } from "./weather-service";
import { log } from "./vite";
import { sql } from 'drizzle-orm';

// Import new user router and middlewares
import userRouter from "./routes/user.routes";
import leadRouter from "./routes/lead.routes"; // Import lead router
import taskRouter from "./routes/task.routes"; // Import task router
import whatsappRouter from "./routes/whatsapp.routes"; // Import whatsapp router
import auditLogRouter from "./routes/auditLog.routes"; // Import auditLog router
import weatherRouter from "./routes/weather.routes"; // Import weather router
import schedulingRouter from "./routes/scheduling.routes"; // Import scheduling router
import newSchedulingRouter from "./routes/scheduling.routes"; // Import new scheduling router
import statsRouter from "./routes/stats.routes"; // Import stats router
import { isAuthenticated, isAdmin } from "./middlewares/auth.middleware"; // Import middlewares
import { addUserNamesToTasks } from "./utils/task.utils"; // Import addUserNamesToTasks
// Remover integração Google Calendar
// import oauthRoutes from './routes/oauth.routes';

export async function registerRoutes(app: Express): Promise<Server> {
  // Set up authentication routes and middleware
  setupAuth(app);

  // Use the new routers
  app.use("/api/users", userRouter);
  app.use("/api/leads", leadRouter); // Use lead router
  app.use("/api/tasks", taskRouter); // Use task router
  app.use("/api/whatsapp", whatsappRouter); // Use whatsapp router
  app.use("/api/audit-logs", auditLogRouter); // Use auditLog router
  app.use("/api/weather", weatherRouter); // Use weather router
  app.use("/api/scheduling", schedulingRouter); // Use old scheduling router
  app.use("/api/new-scheduling", newSchedulingRouter); // Use new scheduling router
  app.use("/api/stats", statsRouter); // Use stats router
  // Remover integração Google Calendar
  // app.use('/api/oauth', oauthRoutes);

  // Get all sessions
  app.get('/api/sessions', async (req, res) => {
    try {
      const result = await db.execute(sql`
        SELECT 
          id,
          start_time as "startTime",
          end_time as "endTime", 
          location,
          source,
          notes,
          status,
          lead_id as "leadId",
          trainer_id as "trainerId",
          value,
          service,
          recurrence_type as "recurrenceType",
          recurrence_interval as "recurrenceInterval",
          recurrence_week_days as "recurrenceWeekDays",
          recurrence_end_type as "recurrenceEndType",
          recurrence_end_date as "recurrenceEndDate",
          recurrence_end_count as "recurrenceEndCount",
          recurrence_group_id as "recurrenceGroupId",
          is_recurrence_parent as "isRecurrenceParent",
          parent_session_id as "parentSessionId"
        FROM sessions 
        ORDER BY start_time ASC
      `);
      
      res.json(result.rows);
    } catch (error) {
      console.error('Erro ao buscar sessões:', error);
      res.status(500).json({ message: "Erro ao buscar sessões" });
    }
  });

  // Get all trainers
  app.get('/api/trainers', async (req, res) => {
    try {
      const result = await db.execute(sql`
        SELECT id, name, email, specialties, source
        FROM trainers 
        ORDER BY name ASC
      `);
      
      res.json(result.rows);
    } catch (error) {
      console.error('Erro ao buscar professores:', error);
      res.status(500).json({ message: "Erro ao buscar professores" });
    }
  });

  // Create new session with recurrence support
  app.post('/api/sessions', async (req, res) => {
    try {
      const { 
        startTime, 
        endTime, 
        location, 
        source, 
        leadId, 
        trainerId, 
        notes, 
        status,
        value,
        service,
        recurrenceType,
        recurrenceInterval,
        recurrenceWeekDays,
        recurrenceEndType,
        recurrenceEndDate,
        recurrenceEndCount
      } = req.body;

      if (recurrenceType === 'none') {
        // Single session
        const result = await db.execute(sql`
          INSERT INTO sessions (
            start_time, end_time, location, source, lead_id, trainer_id, 
            notes, status, value, service, recurrence_type
          )
          VALUES (
            ${startTime}, ${endTime}, ${location}, ${source}, ${leadId}, ${trainerId}, 
            ${notes || null}, ${status || 'agendado'}, ${value}, ${service}, ${recurrenceType}
          )
          RETURNING id
        `);
        
        return res.json({ 
          id: result.rows[0].id, 
          message: 'Sessão criada com sucesso',
          recurring: false,
          count: 1
        });
      }

      // Generate recurring sessions
      const recurrenceGroupId = randomUUID();
      const sessions = [];
      const baseStartTime = new Date(startTime);
      const baseEndTime = new Date(endTime);
      let currentDate = new Date(baseStartTime);
      
      // Determine end condition
      const maxSessions = recurrenceEndType === 'count' ? recurrenceEndCount : 100;
      const endDate = recurrenceEndType === 'date' ? new Date(recurrenceEndDate) : null;
      
      let sessionCount = 0;
      
      while (sessionCount < maxSessions) {
        // Check if we've reached the end date
        if (endDate && currentDate > endDate) {
          break;
        }

        // For weekly recurrence, check if current day matches selected days
        if (recurrenceType === 'weekly') {
          const dayNames = ['domingo', 'segunda', 'terca', 'quarta', 'quinta', 'sexta', 'sabado'];
          const currentDayName = dayNames[currentDate.getDay()];
          
          if (recurrenceWeekDays && recurrenceWeekDays.includes(currentDayName)) {
            const sessionStart = new Date(currentDate);
            sessionStart.setHours(baseStartTime.getHours(), baseStartTime.getMinutes(), 0, 0);
            
            const sessionEnd = new Date(currentDate);
            sessionEnd.setHours(baseEndTime.getHours(), baseEndTime.getMinutes(), 0, 0);
            
            sessions.push({
              startTime: sessionStart.toISOString(),
              endTime: sessionEnd.toISOString(),
              isParent: sessions.length === 0
            });
          }
          
          // Move to next day
          currentDate.setDate(currentDate.getDate() + 1);
          
          // After checking 7 days, jump by interval weeks
          if (currentDate.getDay() === baseStartTime.getDay()) {
            currentDate.setDate(currentDate.getDate() + (7 * (recurrenceInterval - 1)));
          }
        } else if (recurrenceType === 'daily') {
          const sessionStart = new Date(currentDate);
          sessionStart.setHours(baseStartTime.getHours(), baseStartTime.getMinutes(), 0, 0);
          
          const sessionEnd = new Date(currentDate);
          sessionEnd.setHours(baseEndTime.getHours(), baseEndTime.getMinutes(), 0, 0);
          
          sessions.push({
            startTime: sessionStart.toISOString(),
            endTime: sessionEnd.toISOString(),
            isParent: sessions.length === 0
          });
          
          currentDate.setDate(currentDate.getDate() + recurrenceInterval);
        } else if (recurrenceType === 'monthly') {
          const sessionStart = new Date(currentDate);
          sessionStart.setHours(baseStartTime.getHours(), baseStartTime.getMinutes(), 0, 0);
          
          const sessionEnd = new Date(currentDate);
          sessionEnd.setHours(baseEndTime.getHours(), baseEndTime.getMinutes(), 0, 0);
          
          sessions.push({
            startTime: sessionStart.toISOString(),
            endTime: sessionEnd.toISOString(),
            isParent: sessions.length === 0
          });
          
          currentDate.setMonth(currentDate.getMonth() + recurrenceInterval);
        }
        
        sessionCount++;
        
        // Safety check to prevent infinite loops
        if (sessionCount > 365) break;
      }

      // Insert all sessions using SQL
      let parentSessionId = null;
      const insertedSessions = [];

      for (const session of sessions) {
        const result = await db.execute(sql`
          INSERT INTO sessions (
            start_time, end_time, location, source, lead_id, trainer_id, 
            notes, status, value, service, recurrence_type, recurrence_interval,
            recurrence_week_days, recurrence_end_type, recurrence_end_date, 
            recurrence_end_count, recurrence_group_id, is_recurrence_parent,
            parent_session_id
          )
          VALUES (
            ${session.startTime}, ${session.endTime}, ${location}, ${source}, 
            ${leadId}, ${trainerId}, ${notes}, ${status || 'agendado'}, 
            ${value}, ${service}, ${recurrenceType}, ${recurrenceInterval},
            ${recurrenceWeekDays ? JSON.stringify(recurrenceWeekDays) : null}, ${recurrenceEndType}, ${recurrenceEndDate}, 
            ${recurrenceEndCount}, ${recurrenceGroupId}, ${session.isParent},
            ${parentSessionId}
          )
          RETURNING id
        `);
        
        const sessionId = result.rows[0].id;
        insertedSessions.push(sessionId);
        
        if (session.isParent) {
          parentSessionId = sessionId;
        }
      }

      res.json({ 
        message: 'Sessões criadas com sucesso',
        recurring: true,
        count: insertedSessions.length,
        parentId: parentSessionId,
        groupId: recurrenceGroupId
      });
    } catch (error) {
      console.error('Erro ao criar sessão:', error);
      res.status(500).json({ message: "Erro ao criar sessão" });
    }
  });

  // Update session
  app.patch('/api/sessions/:id', async (req, res) => {
    try {
      const sessionId = parseInt(req.params.id);
      const updates = req.body;
      
      // Build dynamic update query
      const updateFields = [];
      const values = [];
      
      if (updates.startTime) {
        updateFields.push('start_time = $' + (values.length + 1));
        values.push(updates.startTime);
      }
      if (updates.endTime) {
        updateFields.push('end_time = $' + (values.length + 1));
        values.push(updates.endTime);
      }
      if (updates.location) {
        updateFields.push('location = $' + (values.length + 1));
        values.push(updates.location);
      }
      if (updates.status) {
        updateFields.push('status = $' + (values.length + 1));
        values.push(updates.status);
      }
      if (updates.notes !== undefined) {
        updateFields.push('notes = $' + (values.length + 1));
        values.push(updates.notes);
      }
      
      if (updateFields.length === 0) {
        return res.status(400).json({ message: 'Nenhum campo para atualizar' });
      }
      
      updateFields.push('updated_at = NOW()');
      values.push(sessionId);
      
      const query = `UPDATE sessions SET ${updateFields.join(', ')} WHERE id = $${values.length}`;
      
      await db.execute(sql.raw(query, values));
      
      res.json({ message: 'Sessão atualizada com sucesso' });
    } catch (error) {
      console.error('Erro ao atualizar sessão:', error);
      res.status(500).json({ message: "Erro ao atualizar sessão" });
    }
  });

  // Get all leads
  app.get('/api/leads', async (req, res) => {
    try {
      const leads = await storage.getLeads();
      res.json(leads);
    } catch (error) {
      res.status(500).json({ message: "Erro ao buscar leads" });
    }
  });

  // Get lead by ID
  app.get('/api/leads/:id', async (req, res) => {
    try {
      const leadId = parseInt(req.params.id);
      const lead = await storage.getLead(leadId);

      if (!lead) {
        return res.status(404).json({ message: "Lead não encontrado" });
      }

      res.json(lead);
    } catch (error) {
      res.status(500).json({ message: "Erro ao buscar lead" });
    }
  });

  // Create new lead
  app.post('/api/leads', async (req, res) => {
    try {
      console.log('Recebendo dados para criar lead:', req.body);

      // Primeiro validamos com o schema que aceita data como string (para validar formato)
      const validationResult = leadValidationSchema.safeParse(req.body);

      if (!validationResult.success) {
        const validationError = fromZodError(validationResult.error);
        console.error('Erro de validação:', validationError.message);
        return res.status(400).json({ message: validationError.message });
      }

      console.log('Dados validados:', validationResult.data);

      // Garantir que entryDate seja um objeto Date antes de enviar para o banco
      const leadToInsert = {
        ...validationResult.data,
        entryDate: validationResult.data.entryDate instanceof Date 
          ? validationResult.data.entryDate 
          : new Date(validationResult.data.entryDate)
      };

      console.log('Dados convertidos para inserção:', leadToInsert);
      const newLead = await storage.createLead(leadToInsert);

      // Registrar evento de criação de lead
      logAuditEvent(AuditEventType.LEAD_CREATED, req, {
        leadId: newLead.id,
        name: newLead.name,
        source: newLead.source,
        status: newLead.status
      });

      res.status(201).json(newLead);
    } catch (error) {
      console.error('Erro ao criar lead:', error);
      res.status(500).json({ message: "Erro ao criar lead", details: String(error) });
    }
  });

  // Update lead
  app.patch('/api/leads/:id', async (req, res) => {
    try {
      const leadId = parseInt(req.params.id);
      console.log('Atualizando lead:', req.body);

      // Validar os dados recebidos
      const validationResult = leadValidationSchema.partial().safeParse(req.body);

      if (!validationResult.success) {
        const validationError = fromZodError(validationResult.error);
        console.error('Erro de validação na atualização:', validationError.message);
        return res.status(400).json({ message: validationError.message });
      }

      // Preparar os dados para atualização
      let dataToUpdate = validationResult.data;

      // Se entryDate for uma string, converter para Date
      if (dataToUpdate.entryDate && typeof dataToUpdate.entryDate === 'string') {
        try {
          dataToUpdate = {
            ...dataToUpdate,
            entryDate: new Date(dataToUpdate.entryDate)
          };
        } catch (e) {
          console.error('Erro ao converter data:', e);
          return res.status(400).json({ message: "Formato de data inválido" });
        }
      }

      console.log('Dados para atualização:', dataToUpdate);
      const updatedLead = await storage.updateLead(leadId, dataToUpdate);

      if (!updatedLead) {
        return res.status(404).json({ message: "Lead não encontrado" });
      }

      // Registrar evento de atualização de lead
      logAuditEvent(AuditEventType.LEAD_UPDATED, req, {
        leadId: updatedLead.id,
        name: updatedLead.name,
        updatedFields: Object.keys(dataToUpdate),
        statusChange: dataToUpdate.status ? `${updatedLead.status !== dataToUpdate.status ? 'De ' + updatedLead.status + ' para ' + dataToUpdate.status : 'Sem alteração'}` : undefined
      });

      res.json(updatedLead);
    } catch (error) {
      console.error('Erro ao atualizar lead:', error);
      res.status(500).json({ message: "Erro ao atualizar lead", details: String(error) });
    }
  });

  // Delete lead
  app.delete('/api/leads/:id', async (req, res) => {
    try {
      const leadId = parseInt(req.params.id);

      // Obter informações do lead antes de excluir (para o log de auditoria)
      const leadToDelete = await storage.getLead(leadId);

      if (!leadToDelete) {
        return res.status(404).json({ message: "Lead não encontrado" });
      }

      const success = await storage.deleteLead(leadId);

      if (!success) {
        return res.status(404).json({ message: "Lead não encontrado" });
      }

      // Registrar evento de exclusão de lead
      logAuditEvent(AuditEventType.LEAD_DELETED, req, {
        leadId: leadId,
        name: leadToDelete.name,
        email: leadToDelete.email,
        source: leadToDelete.source,
        status: leadToDelete.status
      });

      res.status(204).send();
    } catch (error) {
      console.error('Erro ao deletar lead:', error);
      res.status(500).json({ message: "Erro ao deletar lead" });
    }
  });

  // Get all trainers
  app.get('/api/trainers', async (req, res) => {
    try {
      const trainersResult = await db.execute(sql`
        SELECT id, name, email, source, active, specialties, phone
        FROM trainers 
        WHERE active = true
        ORDER BY source, name
      `);
      
      res.json(trainersResult.rows);
    } catch (error) {
      console.error('Erro ao buscar professores:', error);
      res.status(500).json({ message: "Erro ao buscar professores" });
    }
  });

  // Check session conflicts
  app.post('/api/sessions/check-conflicts', async (req, res) => {
    try {
      const { trainerId, date, startTime, endTime } = req.body;
      
      if (!trainerId || !date || !startTime || !endTime) {
        return res.status(400).json({ message: "Parâmetros obrigatórios não fornecidos" });
      }

      const startDateTime = new Date(`${date}T${startTime}`);
      const endDateTime = new Date(`${date}T${endTime}`);
      
      // Adicionar 15 minutos de tolerância
      const toleranceStart = new Date(startDateTime.getTime() - 15 * 60000);
      const toleranceEnd = new Date(endDateTime.getTime() + 15 * 60000);

      // Verificar conflitos com sessões existentes
      const conflictsResult = await db.execute(sql`
        SELECT s.*, l.name as student_name
        FROM sessions s
        JOIN leads l ON s.lead_id = l.id
        WHERE s.trainer_id = ${trainerId}
        AND s.status = 'agendado'
        AND DATE(s.start_time) = ${date}
        AND (
          (s.start_time BETWEEN ${toleranceStart.toISOString()} AND ${toleranceEnd.toISOString()})
          OR 
          (s.end_time BETWEEN ${toleranceStart.toISOString()} AND ${toleranceEnd.toISOString()})
          OR
          (s.start_time <= ${startDateTime.toISOString()} AND s.end_time >= ${endDateTime.toISOString()})
        )
      `);

      const conflicts = [];
      
      if (conflictsResult.rows.length > 0) {
        for (const conflict of conflictsResult.rows) {
          const conflictRow = conflict as any;
          conflicts.push({
            type: 'trainer_busy',
            message: `Professor já tem sessão agendada com ${conflictRow.student_name} das ${new Date(conflictRow.start_time as string).toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })} às ${new Date(conflictRow.end_time as string).toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}`,
            suggestion: 'Considere agendar 15 minutos antes ou depois do horário conflitante.'
          });
        }
      }

      // Sugerir horários alternativos se houver conflitos
      if (conflicts.length > 0) {
        const suggestedTimes = [];
        const timeSlots = [
          "06:00", "06:30", "07:00", "07:30", "08:00", "08:30", 
          "09:00", "09:30", "10:00", "10:30", "11:00", "11:30",
          "12:00", "12:30", "13:00", "13:30", "14:00", "14:30", 
          "15:00", "15:30", "16:00", "16:30", "17:00", "17:30",
          "18:00", "18:30", "19:00", "19:30", "20:00", "20:30"
        ];

        // Verificar horários disponíveis
        for (const slot of timeSlots.slice(0, 5)) { // Limitar a 5 sugestões
          const slotStart = new Date(`${date}T${slot}`);
          const slotEnd = new Date(slotStart.getTime() + (endDateTime.getTime() - startDateTime.getTime()));
          
          const slotConflictResult = await db.execute(sql`
            SELECT COUNT(*) as count
            FROM sessions s
            WHERE s.trainer_id = ${trainerId}
            AND s.status = 'agendado'
            AND DATE(s.start_time) = ${date}
            AND (
              (s.start_time BETWEEN ${slotStart.toISOString()} AND ${slotEnd.toISOString()})
              OR 
              (s.end_time BETWEEN ${slotStart.toISOString()} AND ${slotEnd.toISOString()})
              OR
              (s.start_time <= ${slotStart.toISOString()} AND s.end_time >= ${slotEnd.toISOString()})
            )
          `);

          if (parseInt((slotConflictResult.rows[0] as any).count) === 0) {
            suggestedTimes.push({
              start: slot,
              end: slotEnd.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })
            });
          }
        }

        if (suggestedTimes.length > 0) {
          conflicts.push({
            type: 'suggestion',
            message: `Horários disponíveis: ${suggestedTimes.map(t => `${t.start}-${t.end}`).join(', ')}`,
          });
        }
      }

      res.json({ conflicts });
    } catch (error) {
      console.error('Erro ao verificar conflitos:', error);
      res.status(500).json({ message: "Erro ao verificar conflitos" });
    }
  });

  // Get all sessions
  app.get('/api/sessions', async (req, res) => {
    try {
      const sessions = await storage.getSessions();
      res.json(sessions);
    } catch (error) {
      console.error('Erro ao buscar sessões:', error);
      res.status(500).json({ message: "Erro ao buscar sessões" });
    }
  });

  // Create new session
  app.post('/api/sessions', async (req, res) => {
    try {
      const sessionData = {
        ...req.body,
        startTime: new Date(req.body.startTime),
        endTime: new Date(req.body.endTime)
      };
      
      // Gerar sessões recorrentes se necessário
      if (!sessionData.isOneTime && sessionData.weeklyFrequency && sessionData.weekDays) {
        const recurrenceGroupId = sessionData.recurrenceGroupId || crypto.randomUUID();
        const sessions = [];
        
        // Gerar sessões para as próximas 4 semanas
        for (let week = 0; week < 4; week++) {
          for (const dayName of sessionData.weekDays) {
            const dayIndex = ['Domingo', 'Segunda', 'Terça', 'Quarta', 'Quinta', 'Sexta', 'Sábado'].indexOf(dayName);
            const sessionDate = new Date(sessionData.startTime);
            sessionDate.setDate(sessionDate.getDate() + (week * 7) + (dayIndex - sessionDate.getDay()));
            
            const endDate = new Date(sessionData.endTime);
            endDate.setDate(endDate.getDate() + (week * 7) + (dayIndex - endDate.getDay()));
            
            const session = await storage.createSession({
              ...sessionData,
              startTime: sessionDate,
              endTime: endDate,
              recurrenceGroupId,
              parentSessionId: week === 0 ? null : sessions[0]?.id || null
            });
            
            sessions.push(session);
          }
        }
        
        res.status(201).json({ sessions, message: `${sessions.length} sessões criadas com sucesso` });
      } else {
        // Sessão avulsa
        const session = await storage.createSession(sessionData);
        res.status(201).json(session);
      }
    } catch (error) {
      console.error('Erro ao criar sessão:', error);
      res.status(500).json({ message: "Erro ao criar sessão" });
    }
  });

  // Update session
  app.patch('/api/sessions/:id', async (req, res) => {
    try {
      const sessionId = parseInt(req.params.id);
      const updates = req.body;
      
      const updatedSession = await storage.updateSession(sessionId, updates);
      
      if (!updatedSession) {
        return res.status(404).json({ message: "Sessão não encontrada" });
      }
      
      res.json(updatedSession);
    } catch (error) {
      console.error('Erro ao atualizar sessão:', error);
      res.status(500).json({ message: "Erro ao atualizar sessão" });
    }
  });

  // Delete session
  app.delete('/api/sessions/:id', async (req, res) => {
    try {
      const sessionId = parseInt(req.params.id);
      const deleted = await storage.deleteSession(sessionId);
      
      if (!deleted) {
        return res.status(404).json({ message: "Sessão não encontrada" });
      }
      
      res.status(204).send();
    } catch (error) {
      console.error('Erro ao deletar sessão:', error);
      res.status(500).json({ message: "Erro ao deletar sessão" });
    }
  });

  // Simple appointments API for new scheduling system
  app.post('/api/appointments', async (req, res) => {
    try {
      const appointmentData = req.body;
      
      // Create a single appointment using the aulas table
      const aulaData = {
        professorId: appointmentData.professorId,
        studentId: appointmentData.studentId,
        startTime: new Date(appointmentData.startTime),
        endTime: new Date(appointmentData.endTime),
        location: appointmentData.location || '',
        value: appointmentData.value || 0,
        service: appointmentData.service || '',
        notes: appointmentData.notes || '',
        status: 'agendado' as const,
        isModified: false,
      };

      const [newAula] = await db.insert(aulas).values(aulaData).returning();
      
      res.status(201).json(newAula);
    } catch (error) {
      console.error('Erro ao criar agendamento:', error);
      res.status(500).json({ message: "Erro ao criar agendamento", error: error.message });
    }
  });

  // Get appointments for calendar display
  app.get('/api/appointments', async (req, res) => {
    try {
      const appointments = await db
        .select({
          id: aulas.id,
          service: aulas.service,
          startTime: aulas.startTime,
          endTime: aulas.endTime,
          location: aulas.location,
          value: aulas.value,
          notes: aulas.notes,
          status: aulas.status,
          professorId: aulas.professorId,
          studentId: aulas.studentId,
          professor: {
            id: users.id,
            name: users.name,
            username: users.username,
            email: users.email,
            specialty: users.specialty,
            bio: users.bio,
            hourlyRate: users.hourlyRate
          },
          student: {
            id: leads.id,
            name: leads.name,
            email: leads.email,
            phone: leads.phone,
            notes: leads.notes
          }
        })
        .from(aulas)
        .leftJoin(users, eq(aulas.professorId, users.id))
        .leftJoin(leads, eq(aulas.studentId, leads.id));
      
      // Format the data for the calendar
      const formattedAppointments = appointments.map(appointment => ({
        ...appointment,
        title: `${appointment.service} - ${appointment.student?.name || 'Aluno'} (${appointment.professor?.name || appointment.professor?.username || 'Professor'})`
      }));
      
      res.json(formattedAppointments);
    } catch (error) {
      console.error('Erro ao buscar agendamentos:', error);
      res.status(500).json({ message: "Erro ao buscar agendamentos" });
    }
  });

  // Helper function to generate classes from recurrence
  async function generateClassesFromRecurrence(agendamento: any) {
    const { regras, startDate, endDate, maxOccurrences } = agendamento;
    const classes = [];
    
    let currentDate = new Date(startDate);
    const endDateTime = endDate ? new Date(endDate) : null;
    let count = 0;
    
    while (true) {
      // Check if we should stop
      if (maxOccurrences && count >= maxOccurrences) break;
      if (endDateTime && currentDate > endDateTime) break;
      if (count > 100) break; // Safety limit
      
      // Calculate end time for this class (assuming 1 hour duration by default)
      const classEndTime = new Date(currentDate);
      classEndTime.setHours(classEndTime.getHours() + 1);
      
      // Create the class
      classes.push({
        agendamentoRecorrenteId: agendamento.id,
        professorId: agendamento.professorId,
        studentId: agendamento.studentId,
        startTime: new Date(currentDate),
        endTime: classEndTime,
        location: agendamento.location,
        value: agendamento.value,
        service: agendamento.service,
        notes: agendamento.notes,
        status: 'agendado',
        isModified: false
      });
      
      count++;
      
      // Calculate next occurrence based on recurrence rules
      switch (regras.type) {
        case 'daily':
          currentDate.setDate(currentDate.getDate() + regras.interval);
          break;
        case 'weekly':
          currentDate.setDate(currentDate.getDate() + (7 * regras.interval));
          break;
        case 'monthly':
          currentDate.setMonth(currentDate.getMonth() + regras.interval);
          break;
        case 'yearly':
          currentDate.setFullYear(currentDate.getFullYear() + regras.interval);
          break;
        default:
          // For weekly with specific days, we need more complex logic
          if (regras.type === 'weekly' && regras.weekDays) {
            // Find next occurrence based on weekDays
            let found = false;
            for (let i = 1; i <= 7; i++) {
              const testDate = new Date(currentDate);
              testDate.setDate(testDate.getDate() + i);
              const dayName = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'][testDate.getDay()];
              if (regras.weekDays.includes(dayName)) {
                currentDate = testDate;
                found = true;
                break;
              }
            }
            if (!found) break;
          } else {
            break;
          }
      }
    }
    
    // Insert all classes in batch
    if (classes.length > 0) {
      await db.insert(aulas).values(classes);
    }
    
    return classes;
  }

  // Professor routes
  app.get('/api/users/professors', async (req, res) => {
    try {
      const professors = await db.select()
        .from(users)
        .where(eq(users.role, 'professor'));
      
      res.json(professors);
    } catch (error) {
      console.error('Erro ao buscar professores:', error);
      res.status(500).json({ message: "Erro ao buscar professores" });
    }
  });

  app.post('/api/users/professors', async (req, res) => {
    try {
      const professorData = req.body;
      
      // Hash password if provided
      if (professorData.password) {
        const bcrypt = require('bcrypt');
        professorData.password = await bcrypt.hash(professorData.password, 10);
      }
      
      const [professor] = await db.insert(users)
        .values({
          ...professorData,
          role: 'professor'
        })
        .returning();
      
      res.json(professor);
    } catch (error) {
      console.error('Erro ao criar professor:', error);
      res.status(500).json({ message: "Erro ao criar professor" });
    }
  });

  app.patch('/api/users/professors/:id', async (req, res) => {
    try {
      const professorId = parseInt(req.params.id);
      const updateData = req.body;
      
      // Hash password if provided
      if (updateData.password) {
        const bcrypt = await import('bcrypt');
        updateData.password = await bcrypt.hash(updateData.password, 10);
      }
      
      const [professor] = await db.update(schema.users)
        .set(updateData)
        .where(eq(schema.users.id, professorId))
        .returning();
      
      res.json(professor);
    } catch (error) {
      console.error('Erro ao atualizar professor:', error);
      res.status(500).json({ message: "Erro ao atualizar professor" });
    }
  });

  // New scheduling routes
  app.get('/api/new-scheduling/classes', async (req, res) => {
    try {
      const { start, end, professorId, status } = req.query;
      
      let query = db.select()
        .from(schema.aulas)
        .leftJoin(schema.users, eq(schema.aulas.professorId, schema.users.id))
        .leftJoin(schema.leads, eq(schema.aulas.studentId, schema.leads.id));
      
      const conditions = [];
      
      if (start && end) {
        conditions.push(
          and(
            gte(schema.aulas.startTime, new Date(start as string)),
            lte(schema.aulas.endTime, new Date(end as string))
          )
        );
      }
      
      if (professorId && professorId !== 'all') {
        conditions.push(eq(schema.aulas.professorId, parseInt(professorId as string)));
      }
      
      if (status && status !== 'all') {
        conditions.push(eq(schema.aulas.status, status as string));
      }
      
      if (conditions.length > 0) {
        query = query.where(and(...conditions));
      }
      
      const aulas = await query;
      
      // Format the data for the frontend
      const formattedAulas = aulas.map(row => ({
        ...row.aulas,
        title: `${row.aulas?.service || 'Aula'} - ${row.leads?.name || 'Aluno'}`,
        professor: row.users,
        student: row.leads
      }));
      
      res.json(formattedAulas);
    } catch (error) {
      console.error('Erro ao buscar aulas:', error);
      res.status(500).json({ message: "Erro ao buscar aulas" });
    }
  });

  app.patch('/api/new-scheduling/classes/:id', async (req, res) => {
    try {
      const aulaId = parseInt(req.params.id);
      const updateData = req.body;
      
      const [aula] = await db.update(schema.aulas)
        .set({
          ...updateData,
          updatedAt: new Date()
        })
        .where(eq(schema.aulas.id, aulaId))
        .returning();
      
      res.json(aula);
    } catch (error) {
      console.error('Erro ao atualizar aula:', error);
      res.status(500).json({ message: "Erro ao atualizar aula" });
    }
  });

  app.post('/api/new-scheduling/recurrent', async (req, res) => {
    try {
      const {
        professorId,
        studentId,
        location,
        value,
        service,
        notes,
        regras,
        startDate,
        endDate,
        maxOccurrences,
        active = true
      } = req.body;

      // Create the recurrent schedule
      const [agendamento] = await db.insert(schema.agendamentosRecorrentes)
        .values({
          professorId,
          studentId,
          location,
          value,
          service,
          notes,
          regras,
          startDate: new Date(startDate),
          endDate: endDate ? new Date(endDate) : null,
          maxOccurrences,
          active
        })
        .returning();

      // Generate individual classes based on recurrence rules
      await generateClassesFromRecurrence(agendamento);

      res.json(agendamento);
    } catch (error) {
      console.error('Erro ao criar agendamento recorrente:', error);
      res.status(500).json({ message: "Erro ao criar agendamento recorrente" });
    }
  });

  // Check professor availability for recurring appointments
  app.post('/api/professors/availability', async (req, res) => {
    try {
      const { professorId, dayOfWeek, startTime, endTime, startDate, endDate } = req.body;

      if (!professorId || dayOfWeek === undefined || !startTime || !endTime || !startDate || !endDate) {
        return res.status(400).json({ error: 'Missing required fields' });
      }

      // Convert day of week and times to check for conflicts
      const start = new Date(`2024-01-01T${startTime}:00`);
      const end = new Date(`2024-01-01T${endTime}:00`);
      
      // Query for conflicting appointments in the date range
      const conflicts = await db.select()
        .from(aulas)
        .where(
          and(
            eq(aulas.professorId, professorId),
            gte(aulas.startTime, new Date(startDate)),
            lte(aulas.startTime, new Date(endDate)),
            eq(sql`EXTRACT(dow FROM ${aulas.startTime})`, dayOfWeek),
            or(
              and(
                lte(sql`EXTRACT(hour FROM ${aulas.startTime}) * 60 + EXTRACT(minute FROM ${aulas.startTime})`,
                    start.getHours() * 60 + start.getMinutes()),
                gte(sql`EXTRACT(hour FROM ${aulas.endTime}) * 60 + EXTRACT(minute FROM ${aulas.endTime})`,
                    start.getHours() * 60 + start.getMinutes())
              ),
              and(
                lte(sql`EXTRACT(hour FROM ${aulas.startTime}) * 60 + EXTRACT(minute FROM ${aulas.startTime})`,
                    end.getHours() * 60 + end.getMinutes()),
                gte(sql`EXTRACT(hour FROM ${aulas.endTime}) * 60 + EXTRACT(minute FROM ${aulas.endTime})`,
                    end.getHours() * 60 + end.getMinutes())
              )
            )
          )
        );

      const available = conflicts.length === 0;
      res.json({ available, conflicts: conflicts.length });

    } catch (error) {
      console.error('Error checking professor availability:', error);
      res.status(500).json({ error: 'Failed to check availability' });
    }
  });

  // Get all services
  app.get('/api/services', async (req, res) => {
    try {
      const allServices = await db.select()
        .from(services)
        .where(eq(services.active, true))
        .orderBy(services.name);

      res.json(allServices);
    } catch (error) {
      console.error('Error fetching services:', error);
      res.status(500).json({ error: 'Failed to fetch services' });
    }
  });

  // Create recurring appointments
  app.post('/api/appointments/recurring', async (req, res) => {
    try {
      const { studentName, service, location, value, notes, startDate, endDate, weeklySchedule } = req.body;

      if (!studentName || !service || !startDate || !endDate || !weeklySchedule?.length) {
        return res.status(400).json({ error: 'Missing required fields' });
      }

      // First, create or find the student
      let student = await db.select()
        .from(leads)
        .where(eq(leads.name, studentName))
        .limit(1);

      if (student.length === 0) {
        // Create new student
        const newStudent = await db.insert(leads)
          .values({
            name: studentName,
            status: 'ativo',
            source: 'agendamento_recorrente',
            entryDate: new Date()
          })
          .returning();
        student = newStudent;
      }

      const studentId = student[0].id;

      // Create recurring appointment record with correct schema fields
      const recurringAppointment = await db.insert(agendamentosRecorrentes)
        .values({
          professorId: weeklySchedule[0]?.professorsSchedule[0]?.professorId || 1, // Use first professor as default
          studentId,
          service,
          location: location || '',
          value: value || 0,
          notes: notes || '',
          startDate: new Date(startDate),
          endDate: new Date(endDate),
          regras: { type: 'weekly', interval: 1 }, // Correct field name
          active: true // Correct field name
        })
        .returning();

      const recurringId = recurringAppointment[0].id;

      // Generate individual appointments
      const appointments = [];
      const start = new Date(startDate);
      const end = new Date(endDate);

      for (let currentDate = new Date(start); currentDate <= end; currentDate.setDate(currentDate.getDate() + 1)) {
        const dayOfWeek = currentDate.getDay();
        
        // Find schedule for this day
        const daySchedule = weeklySchedule.find(schedule => schedule.dayOfWeek === dayOfWeek);
        
        if (daySchedule) {
          for (const profSchedule of daySchedule.professorsSchedule) {
            for (const timeSlot of profSchedule.timeSlots) {
              const startTime = new Date(currentDate);
              const endTime = new Date(currentDate);
              
              // Parse time slots
              const [startHour, startMin] = timeSlot.startTime.split(':').map(Number);
              const [endHour, endMin] = timeSlot.endTime.split(':').map(Number);
              
              startTime.setHours(startHour, startMin, 0, 0);
              endTime.setHours(endHour, endMin, 0, 0);

              appointments.push({
                agendamentoRecorrenteId: recurringId,
                professorId: profSchedule.professorId,
                studentId,
                startTime,
                endTime,
                location: location || '',
                value: value || 0,
                service,
                notes: notes || '',
                status: 'agendado' as const,
                isModified: false
              });
            }
          }
        }
      }

      // Insert all appointments
      if (appointments.length > 0) {
        await db.insert(aulas).values(appointments);
      }

      res.json({
        success: true,
        recurringAppointmentId: recurringId,
        appointmentsCreated: appointments.length,
        message: `${appointments.length} agendamentos criados com sucesso`
      });

    } catch (error) {
      console.error('Error creating recurring appointments:', error);
      res.status(500).json({ error: 'Failed to create recurring appointments' });
    }
  });

  const httpServer = createServer(app);

  return httpServer;
}
</file>

<file path="server/routes/auditLog.routes.ts">
import { Router } from 'express';
import { isAdmin } from '../middlewares/auth.middleware';
import { getAuditLogs } from '../controllers/auditLog.controller';

const router = Router();

// Somente administradores podem acessar os logs de auditoria
router.get('/', isAdmin, getAuditLogs);

export default router;
</file>

<file path="server/routes/lead.routes.ts">
import { Router } from 'express';
import { isAuthenticated } from '../middlewares/auth.middleware'; // Assuming all lead routes require authentication
import {
  importLeadsBatch,
  updateLeadsBatch,
  deleteLeadsBatch,
  getAllLeads,
  getLeadById,
  createLead,
  updateLead,
  deleteLead
} from '../controllers/lead.controller';

const router = Router();

// Apply authentication middleware to all lead routes
router.use(isAuthenticated);

// Batch operations
router.post('/batch/import', importLeadsBatch);
router.post('/batch/update', updateLeadsBatch);
router.post('/batch/delete', deleteLeadsBatch);

// Standard CRUD operations
router.get('/', getAllLeads);
router.post('/', createLead);
router.get('/:id', getLeadById);
router.patch('/:id', updateLead);
router.delete('/:id', deleteLead);

export default router;
</file>

<file path="server/routes/oauth.routes.ts">
import { Router } from 'express';
import { isAuthenticated } from '../middlewares/auth.middleware';
import {
  getGoogleAuthUrl,
  handleGoogleCallback,
  getTokenStatus,
  revokeGoogleAccess
} from '../controllers/oauth.controller';

const router = Router();

// Todas as rotas OAuth2 precisam de autenticação
router.use(isAuthenticated);

// Gerar URL de autorização do Google
router.get('/google/auth-url', getGoogleAuthUrl);

// Callback do Google OAuth2
router.get('/google/callback', handleGoogleCallback);

// Status dos tokens
router.get('/google/status', getTokenStatus);

// Revogar acesso
router.delete('/google/revoke', revokeGoogleAccess);

export default router;
</file>

<file path="server/routes/scheduling.routes.ts">
import { Router } from 'express';
import { 
  getAppointments, 
  createAppointment, 
  updateAppointment, 
  deleteAppointment,
  createRecurringAppointments,
  updateAppointmentStatus,
  deleteRecurringGroup
} from '../controllers/scheduling.controller';
import { isAuthenticated } from '../middlewares/auth.middleware';

const router = Router();

router.use(isAuthenticated);

router.get('/', getAppointments);
router.post('/', createAppointment);
router.put('/:id', updateAppointment);
router.delete('/:id', deleteAppointment);
router.patch('/:id/status', updateAppointmentStatus);
router.post('/recurring', createRecurringAppointments);
router.delete('/recurring/:groupId', deleteRecurringGroup);

export default router;
</file>

<file path="server/routes/stats.routes.ts">
import { Router } from 'express';
import { isAuthenticated } from '../middlewares/auth.middleware'; // All stats should be authenticated
import { getStats } from '../controllers/stats.controller';

const router = Router();

// Apply authentication middleware
router.use(isAuthenticated);

// Define the route for getting all statistics
router.get('/', getStats);

export default router;
</file>

<file path="server/routes/task.routes.ts">
import { Router } from 'express';
import { isAuthenticated, isAdmin } from '../middlewares/auth.middleware';
import {
  getAllTasks,
  getTaskById,
  createTask,
  updateTask,
  deleteTask,
  getTasksByAssignedTo,
  getTasksByStatus,
  addTaskComment,
  deleteTaskComment
} from '../controllers/task.controller';

const router = Router();

// Apply authentication middleware to all task routes
router.use(isAuthenticated);

// Task specific routes
router.get('/assigned-to/:userId', getTasksByAssignedTo);
router.get('/status/:status', getTasksByStatus);

// Task CRUD
router.get('/', getAllTasks);
router.post('/', createTask);
router.get('/:id', getTaskById);
router.patch('/:id', updateTask);
router.delete('/:id', isAdmin, deleteTask); // Only admins can delete tasks

// Task Comment routes
router.post('/:id/comments', addTaskComment);
router.delete('/comments/:id', deleteTaskComment); // Note the path for deleting comments

export default router;
</file>

<file path="server/routes/user.routes.ts">
import { Router } from "express";
import { isAuthenticated } from "../middlewares/auth.middleware";
import { 
  getAllProfessors, 
  createProfessor, 
  updateProfessor, 
  deleteProfessor 
} from "../controllers/user.controller";

const router = Router();

// Aplicar middleware de autenticação a todas as rotas
router.use(isAuthenticated);

// ROTAS PARA GESTÃO DE PROFESSORES
router.get("/professors", getAllProfessors);
router.post("/professors", createProfessor);
router.put("/professors/:id", updateProfessor);
router.delete("/professors/:id", deleteProfessor);

export default router;
</file>

<file path="server/routes/weather.routes.ts">
import { Router } from 'express';
import { isAuthenticated } from '../middlewares/auth.middleware';
import { checkStatus, getWeather } from '../controllers/weather.controller';

const router = Router();

// Apply authentication middleware to weather routes
router.use(isAuthenticated);

// Weather routes
router.get('/status', checkStatus);
router.get('/:city', getWeather);

export default router;
</file>

<file path="server/routes/whatsapp.routes.ts">
import { Router } from 'express';
import { isAuthenticated, isAdmin } from '../middlewares/auth.middleware';
import {
  getLeadMessages,
  updateMessageStatus,
  deleteMessage,
  getRecentMessagesPerLead,
  getWhatsappStatus,
  getWhatsappConfig,
  saveWhatsappConfig,
  getQRCode,
  checkApiMessageStatus,
  sendTextMessage,
  sendImageMessage,
  sendTemplateMessage,
  handleWebhook, // POST webhook
  verifyWebhook,    // GET webhook verification
  // Novos controladores
  sendDocumentMessage,
  sendAudioMessage,
  sendVideoMessage,
  getWhatsappGroups,
  createWhatsappGroup,
  getWhatsappContacts
} from '../controllers/whatsapp.controller';

const router = Router();

// Webhook routes (NO AUTH)
router.post('/webhook', handleWebhook);
router.get('/webhook', verifyWebhook); // For Meta webhook verification

// Configuration routes (Admin only)
router.get('/config', isAuthenticated, isAdmin, getWhatsappConfig);
router.post('/config', isAuthenticated, isAdmin, saveWhatsappConfig);

// General WhatsApp status and QR code (Authenticated users)
router.get('/status', isAuthenticated, getWhatsappStatus);
router.get('/qrcode', isAuthenticated, getQRCode);

// Message sending and management (Authenticated users)
router.post('/send', isAuthenticated, sendTextMessage);
router.post('/send-image', isAuthenticated, sendImageMessage);
router.post('/template', isAuthenticated, sendTemplateMessage);

// Novas rotas para envio de diferentes tipos de mídia
router.post('/send-document', isAuthenticated, sendDocumentMessage);
router.post('/send-audio', isAuthenticated, sendAudioMessage);
router.post('/send-video', isAuthenticated, sendVideoMessage);

// Rotas para gerenciamento de grupos
router.get('/groups', isAuthenticated, getWhatsappGroups);
router.post('/groups', isAuthenticated, createWhatsappGroup);

// Rota para obter contatos
router.get('/contacts', isAuthenticated, getWhatsappContacts);

router.get('/recent-messages', isAuthenticated, getRecentMessagesPerLead);
router.get('/lead/:leadId', isAuthenticated, getLeadMessages);
// Note: a previous route was /api/whatsapp/lead/:id - this consolidates to /lead/:leadId

router.patch('/messages/:id/status', isAuthenticated, updateMessageStatus);
router.delete('/messages/:id', isAuthenticated, deleteMessage);
router.get('/message-status/:messageId', isAuthenticated, checkApiMessageStatus);


export default router;
</file>

<file path="server/storage.ts">
import { 
  leads, students, trainers, sessions, sessionHistory, whatsappMessages,
  tasks, taskComments,
  type Lead, type InsertLead, 
  type User, type InsertUser, 
  type Student, type InsertStudent,
  type Trainer, type InsertTrainer,
  type Session, type InsertSession,
  type SessionHistory, type InsertSessionHistory,
  type WhatsappMessage, type InsertWhatsappMessage,
  type Task, type InsertTask,
  type TaskComment, type InsertTaskComment,
  users,
  sessionHistory as sessionHistoryTable,
  whatsappSettings, InsertWhatsappSettings, WhatsappSettings,
  // New scheduling system imports
  agendamentosRecorrentes, aulas,
  type AgendamentoRecorrente, type InsertAgendamentoRecorrente,
  type Aula, type InsertAula
} from "@shared/schema";
import { db, sql as pgClient } from "./db";
import { eq, and, desc, asc, between, inArray, or, like, sql, SQL } from "drizzle-orm";
import session from "express-session";
import { SupabaseSessionStore } from "./supabase-session-store";
import { alias } from "drizzle-orm/pg-core";

// modify the interface with any CRUD methods
// you might need

export interface IStorage {
  // User methods
  getUser(id: number): Promise<User | undefined>;
  getUserById(id: number): Promise<User | undefined>;
  getUserByUsername(username: string): Promise<User | undefined>;
  getUserByEmail(email: string): Promise<User | undefined>;
  createUser(user: InsertUser): Promise<User>;
  getAllUsers(): Promise<User[]>;
  deleteUser(id: number): Promise<boolean>;
  
  // Professor methods (users with role='professor')
  getAllProfessors(): Promise<User[]>;
  createProfessor(professor: InsertUser): Promise<User>;
  updateProfessor(id: number, professor: Partial<InsertUser>): Promise<User | undefined>;
  deleteProfessor(id: number): Promise<boolean>;
  hasScheduledClasses(professorId: number): Promise<boolean>;

  // Lead methods
  getLeads(): Promise<Lead[]>;
  getLead(id: number): Promise<Lead | undefined>;
  createLead(lead: InsertLead): Promise<Lead>;
  updateLead(id: number, lead: Partial<InsertLead>): Promise<Lead | undefined>;
  deleteLead(id: number): Promise<boolean>;
  getLeadsBySource(source: string): Promise<Lead[]>;
  getLeadsByStatus(status: string): Promise<Lead[]>;
  getLeadsByCampaign(campaign: string): Promise<Lead[]>;
  getLeadsByState(state: string): Promise<Lead[]>;
  getLeadsByPhone(phone: string): Promise<Lead[]>;

  // Batch operations
  updateLeadsInBatch(ids: number[], updates: Partial<InsertLead>): Promise<number>;
  deleteLeadsInBatch(ids: number[]): Promise<number>;

  // WhatsApp methods
  getWhatsappMessages(leadId: number): Promise<WhatsappMessage[]>;
  getWhatsappMessageById(id: number): Promise<WhatsappMessage | undefined>;
  getWhatsappMessageByApiId(messageId: string): Promise<WhatsappMessage | undefined>;
  createWhatsappMessage(message: InsertWhatsappMessage): Promise<WhatsappMessage>;
  updateWhatsappMessageStatus(id: number, status: string): Promise<WhatsappMessage | undefined>;
  updateWhatsappMessageId(id: number, messageId: string): Promise<WhatsappMessage | undefined>;
  deleteWhatsappMessage(id: number): Promise<boolean>;

  // Trainer methods
  getTrainers(): Promise<Trainer[]>;
  getTrainer(id: number): Promise<Trainer | undefined>;
  createTrainer(trainer: InsertTrainer): Promise<Trainer>;
  updateTrainer(id: number, trainer: Partial<InsertTrainer>): Promise<Trainer | undefined>;
  deleteTrainer(id: number): Promise<boolean>;
  getActiveTrainers(): Promise<Trainer[]>;
  getTrainersBySpecialty(specialty: string): Promise<Trainer[]>;

  // Student methods
  getStudents(): Promise<Student[]>;
  getStudent(id: number): Promise<Student | undefined>;
  getStudentByLeadId(leadId: number): Promise<Student | undefined>;
  createStudent(student: InsertStudent): Promise<Student>;
  updateStudent(id: number, student: Partial<InsertStudent>): Promise<Student | undefined>;
  deleteStudent(id: number): Promise<boolean>;
  getActiveStudents(): Promise<Student[]>;
  getStudentsBySource(source: string): Promise<Student[]>;
  getStudentsWithLeadInfo(): Promise<(Student & { lead: Lead | null })[]>;

  // Session methods
  getSessions(): Promise<Session[]>;
  getSession(id: number): Promise<Session | undefined>;
  createSession(session: InsertSession): Promise<Session>;
  updateSession(id: number, session: Partial<InsertSession>): Promise<Session | undefined>;
  deleteSession(id: number): Promise<boolean>;
  getSessionsByStudentId(studentId: number): Promise<Session[]>;
  getSessionsByTrainerId(trainerId: number): Promise<Session[]>;
  getSessionsByDateRange(startDate: Date, endDate: Date): Promise<Session[]>;
  getSessionsByStatus(status: string): Promise<Session[]>;
  getSessionsBySource(source: string): Promise<Session[]>;
  getSessionsWithDetails(): Promise<any[]>; // Retorna sessões com dados de alunos e professores
  getCompletedSessionsByStudent(studentId: number, startDate?: Date, endDate?: Date): Promise<Session[]>;

  // Session history methods
  createSessionHistory(history: InsertSessionHistory): Promise<SessionHistory>;
  getSessionHistoryBySessionId(sessionId: number): Promise<SessionHistory[]>;

  // Task methods
  getTasks(): Promise<Task[]>;
  getTask(id: number): Promise<Task | undefined>;
  createTask(task: InsertTask): Promise<Task>;
  updateTask(id: number, task: Partial<InsertTask>): Promise<Task | undefined>;
  deleteTask(id: number): Promise<boolean>;
  getTasksByAssignedToId(userId: number): Promise<Task[]>;
  getTasksByAssignedById(userId: number): Promise<Task[]>;
  getTasksByStatus(status: string): Promise<Task[]>;
  getTasksByRelatedLeadId(leadId: number): Promise<Task[]>;

  // Task comments methods
  getTaskCommentsByTaskId(taskId: number): Promise<TaskComment[]>;
  createTaskComment(comment: InsertTaskComment): Promise<TaskComment>;
  deleteTaskComment(id: number): Promise<boolean>;

  // Session store for authentication
  sessionStore: session.Store;

  // WhatsApp Settings methods
  getWhatsappSettings(): Promise<WhatsappSettings | undefined>;
  saveWhatsappSettings(settings: InsertWhatsappSettings): Promise<WhatsappSettings>;

  // Google OAuth2 token management
  saveGoogleTokens(userId: number, tokens: {
    access_token: string;
    refresh_token?: string;
    expiry_date: number;
  }): Promise<void>;
  getGoogleTokens(userId: number): Promise<{
    access_token: string;
    refresh_token?: string;
    expiry_date: number;
  } | null>;
  deleteGoogleTokens(userId: number): Promise<void>;

  // New Scheduling System methods
  // Agendamentos Recorrentes
  createAgendamentoRecorrente(agendamento: any): Promise<any>;
  getAgendamentosRecorrentes(): Promise<any[]>;
  updateAgendamentoRecorrente(id: number, agendamento: any): Promise<any>;
  deleteAgendamentoRecorrente(id: number): Promise<boolean>;

  // Aulas (individual class instances)
  getAulas(filters?: any): Promise<any[]>;
  getAulaById(id: number): Promise<any | undefined>;
  createAula(aula: any): Promise<any>;
  createMultipleAulas(aulas: any[]): Promise<any[]>;
  updateAula(id: number, aula: any): Promise<any>;
  deleteAula(id: number): Promise<boolean>;
  
  // Lead helpers
  getLeadById(id: number): Promise<Lead | undefined>;
  
  // Conflict checking
  checkSchedulingConflicts(professorId: number, studentId: number, startTime: Date, endTime: Date, excludeAulaId?: number): Promise<any>;
}

export class DatabaseStorage implements IStorage {
  sessionStore: session.Store;

  constructor() {
    this.sessionStore = new SupabaseSessionStore({
      ttl: 86400 // 24 hours
    });
  }
  async getUser(id: number): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    return user || undefined;
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.username, username));
    return user || undefined;
  }

  async createUser(insertUser: InsertUser): Promise<User> {
    const [user] = await db
      .insert(users)
      .values(insertUser)
      .returning();
    return user;
  }

  async getAllUsers(): Promise<User[]> {
    return await db.select().from(users);
  }

  async deleteUser(id: number): Promise<boolean> {
    try {
      await db.delete(users).where(eq(users.id, id));
      return true;
    } catch (error) {
      console.error("Erro ao excluir usuário:", error);
      return false;
    }
  }

  // New professor and user helper methods
  async getUserById(id: number): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    return user || undefined;
  }

  async getUserByEmail(email: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.email, email));
    return user || undefined;
  }

  async getAllProfessors(): Promise<User[]> {
    return await db.select().from(users).where(eq(users.role, 'professor'));
  }

  async createProfessor(professor: InsertUser): Promise<User> {
    const [createdProfessor] = await db
      .insert(users)
      .values({ ...professor, role: 'professor' })
      .returning();
    return createdProfessor;
  }

  async updateProfessor(id: number, professor: Partial<InsertUser>): Promise<User | undefined> {
    try {
      const [updatedProfessor] = await db
        .update(users)
        .set({ ...professor, updatedAt: new Date() })
        .where(eq(users.id, id))
        .returning();
      return updatedProfessor || undefined;
    } catch (error) {
      console.error("Erro ao atualizar professor:", error);
      return undefined;
    }
  }

  async deleteProfessor(id: number): Promise<boolean> {
    try {
      await db.delete(users).where(eq(users.id, id));
      return true;
    } catch (error) {
      console.error("Erro ao excluir professor:", error);
      return false;
    }
  }

  async hasScheduledClasses(professorId: number): Promise<boolean> {
    try {
      // Check if professor has any future classes
      const now = new Date();
      const result = await db
        .select({ count: sql<number>`count(*)` })
        .from(sessions)
        .where(
          and(
            eq(sessions.trainerId, professorId),
            sql`${sessions.startTime} > ${now}`,
            sql`${sessions.status} != 'cancelado'`
          )
        );
      
      return (result[0]?.count || 0) > 0;
    } catch (error) {
      console.error("Erro ao verificar aulas agendadas:", error);
      return false;
    }
  }

  // Lead methods
  async getLeads(): Promise<Lead[]> {
    return await db.select().from(leads);
  }

  async getLead(id: number): Promise<Lead | undefined> {
    const [lead] = await db.select().from(leads).where(eq(leads.id, id));
    return lead || undefined;
  }

  async createLead(insertLead: InsertLead): Promise<Lead> {
    try {
      console.log('Inserindo lead no banco:', {
        ...insertLead,
        notes: insertLead.notes || null,
      });

      // Ensure entryDate is a Date object
      const leadDataToInsert = {
        ...insertLead,
        notes: insertLead.notes || null,
        entryDate: insertLead.entryDate instanceof Date ? insertLead.entryDate : new Date(insertLead.entryDate || Date.now()),
      };

      const [lead] = await db
        .insert(leads)
        .values(leadDataToInsert) // Use the processed data
        .returning();

      console.log('Lead criado com sucesso:', lead);
      return lead;
    } catch (error) {
      console.error('Erro ao inserir lead no banco:', error);
      throw error;
    }
  }

  async updateLead(id: number, updates: Partial<InsertLead>): Promise<Lead | undefined> {
    // Process updates, ensuring correct types for DB
    const processedUpdates: { [key: string]: any } = { ...updates }; // Use a more flexible type initially

    if (updates.entryDate && !(updates.entryDate instanceof Date)) {
      try {
        processedUpdates.entryDate = new Date(updates.entryDate);
      } catch (e) {
        console.error("Invalid date format for entryDate during update:", updates.entryDate);
        // Decide how to handle invalid date - skip update or throw error? Here we skip.
        delete processedUpdates.entryDate;
      }
    }
    processedUpdates.updatedAt = new Date();

    // Explicitly cast to Partial<Lead> before setting, ensuring type alignment
    const [updatedLead] = await db
      .update(leads)
      .set(processedUpdates as Partial<Lead>) 
      .where(eq(leads.id, id))
      .returning();
    return updatedLead || undefined;
  }

  async deleteLead(id: number): Promise<boolean> {
    try {
      // First delete any associated WhatsApp messages
      await db
        .delete(whatsappMessages)
        .where(eq(whatsappMessages.leadId, id));

      // Then delete the lead
      await db
        .delete(leads)
        .where(eq(leads.id, id));

      return true;
    } catch (error) {
      console.error("Erro ao excluir lead:", error);
      throw error; // Re-throw to be caught by the route handler
    }
  }

  async getLeadsBySource(source: string): Promise<Lead[]> {
    return await db
      .select()
      .from(leads)
      .where(eq(leads.source, source));
  }

  async getLeadsByStatus(status: string): Promise<Lead[]> {
    return await db
      .select()
      .from(leads)
      .where(eq(leads.status, status));
  }

  async getLeadsByCampaign(campaign: string): Promise<Lead[]> {
    return await db
      .select()
      .from(leads)
      .where(eq(leads.campaign, campaign));
  }

  async getLeadsByState(state: string): Promise<Lead[]> {
    return await db
      .select()
      .from(leads)
      .where(eq(leads.state, state));
  }

  async getLeadsByPhone(phone: string): Promise<Lead[]> {
    // Remove qualquer formatação do número antes de buscar
    const cleanPhone = phone.replace(/\D/g, '');
    return await db
      .select()
      .from(leads)
      .where(
        // Verifica padrões diferentes do telefone (com e sem código do país/DDD)
        or(
          like(leads.phone, `%${cleanPhone}%`),
          // Se o número passado parece já ter código de país (mais de 10 dígitos)
          // tenta buscar versão sem código de país também
          cleanPhone.length > 10 
            ? like(leads.phone, `%${cleanPhone.substring(2)}%`) 
            : sql`false`
        )
      );
  }

  // Batch operations
  async updateLeadsInBatch(ids: number[], updates: Partial<InsertLead>): Promise<number> {
    if (ids.length === 0) return 0;

    // Process updates for batch, ensuring correct types
    const processedUpdates: { [key: string]: any } = { ...updates }; // Use flexible type

    if (updates.entryDate && !(updates.entryDate instanceof Date)) {
       try {
        processedUpdates.entryDate = new Date(updates.entryDate);
      } catch (e) {
        console.error("Invalid date format for entryDate during batch update:", updates.entryDate);
        delete processedUpdates.entryDate;
      }
    }
    processedUpdates.updatedAt = new Date();

    // Explicitly cast to Partial<Lead> before setting
    const result = await db
      .update(leads)
      .set(processedUpdates as Partial<Lead>) 
      .where(sql`${leads.id} IN (${sql.join(ids, sql`, `)})`);

    // Drizzle's update doesn't directly return affected rows count easily in all drivers
    // We return the number of IDs passed as an approximation
    return ids.length; 
  }

  async deleteLeadsInBatch(ids: number[]): Promise<number> {
    if (ids.length === 0) return 0;

    // First delete all WhatsApp messages associated with these leads
    try {
      // Delete related WhatsApp messages first
      await db
        .delete(whatsappMessages)
        .where(sql`${whatsappMessages.leadId} IN (${sql.join(ids, sql`, `)})`);

      // Then delete the leads
      await db
        .delete(leads)
        .where(sql`${leads.id} IN (${sql.join(ids, sql`, `)})`);

      return ids.length; // Return the number of deleted rows
    } catch (error) {
      console.error("Erro ao excluir leads em lote:", error);
      throw error; // Re-throw to be caught by the route handler
    }
  }

  // Trainer methods
  async getTrainers(): Promise<Trainer[]> {
    return await db.select().from(trainers).orderBy(trainers.name);
  }

  async getTrainer(id: number): Promise<Trainer | undefined> {
    const [trainer] = await db.select().from(trainers).where(eq(trainers.id, id));
    return trainer || undefined;
  }

  async createTrainer(insertTrainer: InsertTrainer): Promise<Trainer> {
    const [trainer] = await db
      .insert(trainers)
      .values({
        ...insertTrainer,
      })
      .returning();
    return trainer;
  }

  async updateTrainer(id: number, updates: Partial<InsertTrainer>): Promise<Trainer | undefined> {
    const [updatedTrainer] = await db
      .update(trainers)
      .set({
        ...updates,
        updatedAt: new Date(),
      })
      .where(eq(trainers.id, id))
      .returning();
    return updatedTrainer || undefined;
  }

  async deleteTrainer(id: number): Promise<boolean> {
    try {
      await db.delete(trainers).where(eq(trainers.id, id));
      return true;
    } catch (error) {
      console.error("Erro ao excluir professor:", error);
      return false;
    }
  }

  async getActiveTrainers(): Promise<Trainer[]> {
    return await db
      .select()
      .from(trainers)
      .where(eq(trainers.active, true))
      .orderBy(trainers.name);
  }

  async getTrainersBySpecialty(specialty: string): Promise<Trainer[]> {
    // A busca por especialidade é mais complexa porque é um array
    // Usamos SQL customizado para verificar se o array contém a especialidade
    return await db
      .select()
      .from(trainers)
      .where(sql`${specialty} = ANY(${trainers.specialties})`);
  }

  // Student methods
  async getStudents(): Promise<Student[]> {
    return await db.select().from(students).orderBy(students.id);
  }

  async getStudent(id: number): Promise<Student | undefined> {
    const [student] = await db.select().from(students).where(eq(students.id, id));
    return student || undefined;
  }

  async getStudentByLeadId(leadId: number): Promise<Student | undefined> {
    const [student] = await db.select().from(students).where(eq(students.leadId, leadId));
    return student || undefined;
  }

  async createStudent(insertStudent: InsertStudent): Promise<Student> {
    const [student] = await db
      .insert(students)
      .values({
        ...insertStudent,
      })
      .returning();
    return student;
  }

  async updateStudent(id: number, updates: Partial<InsertStudent>): Promise<Student | undefined> {
    const [updatedStudent] = await db
      .update(students)
      .set({
        ...updates,
        updatedAt: new Date(),
      })
      .where(eq(students.id, id))
      .returning();
    return updatedStudent || undefined;
  }

  async deleteStudent(id: number): Promise<boolean> {
    try {
      await db.delete(students).where(eq(students.id, id));
      return true;
    } catch (error) {
      console.error("Erro ao excluir aluno:", error);
      return false;
    }
  }

  async getActiveStudents(): Promise<Student[]> {
    return await db
      .select()
      .from(students)
      .where(eq(students.active, true))
      .orderBy(students.id);
  }

  async getStudentsBySource(source: string): Promise<Student[]> {
    return await db
      .select()
      .from(students)
      .where(eq(students.source, source));
  }

  async getStudentsWithLeadInfo(): Promise<(Student & { lead: Lead | null })[]> {
    // Explicitly select columns and structure the result
    const result = await db
      .select({
        student: students, // Select all columns from students
        lead: leads,       // Select all columns from leads
      })
      .from(students)
      .leftJoin(leads, eq(students.leadId, leads.id));

    // Map the result to the desired structure
    return result.map(row => ({
      ...row.student,
      lead: row.lead, // lead can be null due to leftJoin
    }));
  }

  // Session methods
  async getSessions(): Promise<Session[]> {
    return await db.select().from(sessions).orderBy(desc(sessions.startTime));
  }

  async getSession(id: number): Promise<Session | undefined> {
    const [session] = await db.select().from(sessions).where(eq(sessions.id, id));
    return session || undefined;
  }

  async createSession(insertSession: InsertSession): Promise<Session> {
    const [session] = await db
      .insert(sessions)
      .values({
        ...insertSession,
      })
      .returning();
    return session;
  }

  async updateSession(id: number, updates: Partial<InsertSession>): Promise<Session | undefined> {
    const [updatedSession] = await db
      .update(sessions)
      .set({
        ...updates,
        updatedAt: new Date(),
      })
      .where(eq(sessions.id, id))
      .returning();
    return updatedSession || undefined;
  }

  async deleteSession(id: number): Promise<boolean> {
    try {
      await db.delete(sessions).where(eq(sessions.id, id));
      return true;
    } catch (error) {
      console.error("Erro ao excluir sessão:", error);
      return false;
    }
  }

  async getSessionsByStudentId(studentId: number): Promise<Session[]> {
    return await db
      .select()
      .from(sessions)
      .where(eq(sessions.studentId, studentId))
      .orderBy(desc(sessions.startTime));
  }

  async getSessionsByTrainerId(trainerId: number): Promise<Session[]> {
    return await db
      .select()
      .from(sessions)
      .where(eq(sessions.trainerId, trainerId))
      .orderBy(desc(sessions.startTime));
  }

  async getSessionsByDateRange(startDate: Date, endDate: Date): Promise<Session[]> {
    return await db
      .select()
      .from(sessions)
      .where(and(
        between(sessions.startTime, startDate, endDate),
      ))
      .orderBy(asc(sessions.startTime));
  }

  async getSessionsByStatus(status: string): Promise<Session[]> {
    return await db
      .select()
      .from(sessions)
      .where(eq(sessions.status, status))
      .orderBy(desc(sessions.startTime));
  }

  async getSessionsBySource(source: string): Promise<Session[]> {
    return await db
      .select()
      .from(sessions)
      .where(eq(sessions.source, source))
      .orderBy(desc(sessions.startTime));
  }

  async getSessionsWithDetails(): Promise<any[]> {
    // Alias para evitar colisões de nome
    const s = alias(students, 'student');
    const t = alias(trainers, 'trainer');
    const l = alias(leads, 'lead');

    return await db
      .select({
        id: sessions.id,
        startTime: sessions.startTime,
        endTime: sessions.endTime,
        location: sessions.location,
        notes: sessions.notes,
        status: sessions.status,
        source: sessions.source,
        googleEventId: sessions.googleEventId,
        createdAt: sessions.createdAt,
        updatedAt: sessions.updatedAt,
        student: {
          id: s.id,
          name: l.name,
          email: l.email,
          phone: l.phone,
          source: s.source,
          address: s.address,
        },
        trainer: {
          id: t.id,
          name: t.name,
          email: t.email,
          phone: t.phone,
          specialties: t.specialties,
        }
      })
      .from(sessions)
      .leftJoin(s, eq(sessions.studentId, s.id))
      .leftJoin(t, eq(sessions.trainerId, t.id))
      .leftJoin(l, eq(s.leadId, l.id))
      .orderBy(desc(sessions.startTime));
  }

  async getCompletedSessionsByStudent(
    studentId: number, 
    startDate?: Date, 
    endDate?: Date
  ): Promise<Session[]> {
    // Define base conditions as an array, explicitly typing elements as SQL
    const conditions: SQL[] = [
      eq(sessions.studentId, studentId) as SQL,
      eq(sessions.status, 'concluido') as SQL // Ensure this matches your actual status value
    ];

    // Conditionally add the date range filter to the conditions array
    if (startDate && endDate) {
      conditions.push(between(sessions.startTime, startDate, endDate) as SQL);
    }

    // Build and execute the query using the conditions array
    return await db
      .select()
      .from(sessions)
      .where(and(...conditions)) // Apply all conditions using and()
      .orderBy(asc(sessions.startTime));
  }

  // Session history methods
  async createSessionHistory(history: InsertSessionHistory): Promise<SessionHistory> {
    // Use the imported table schema object (aliased as sessionHistoryTable)
    const [newSessionHistory] = await db
      .insert(sessionHistoryTable) // Use the correct table schema object
      .values(history)
      .returning();
    return newSessionHistory; // Return the newly created history entry
  }

  async getSessionHistoryBySessionId(sessionId: number): Promise<SessionHistory[]> {
    return await db
      .select()
      .from(sessionHistoryTable) // Use the correct table schema object
      .where(eq(sessionHistoryTable.sessionId, sessionId))
      .orderBy(desc(sessionHistoryTable.changedAt));
  }

  // Task methods
  async getTasks(): Promise<Task[]> {
    return await db.select().from(tasks).orderBy(desc(tasks.createdAt));
  }

  async getTask(id: number): Promise<Task | undefined> {
    const [task] = await db.select().from(tasks).where(eq(tasks.id, id));
    return task || undefined;
  }

  async createTask(insertTask: InsertTask): Promise<Task> {
    // Log the incoming task data
    console.log('Creating task with data:', JSON.stringify(insertTask, null, 2));

    // Create a new object with processed data
    const processedTask = {
      ...insertTask,
    };

    // Ensure dueDate is a proper Date object if it exists
    if (processedTask.dueDate !== undefined && processedTask.dueDate !== null) {
      // If it's already a Date object, keep it; otherwise, try to create a new Date
      if (!(processedTask.dueDate instanceof Date)) {
        console.log('Converting dueDate to Date object:', processedTask.dueDate);
        try {
          processedTask.dueDate = new Date(processedTask.dueDate);
          console.log('Converted dueDate:', processedTask.dueDate);
        } catch (error) {
          console.error('Failed to convert dueDate to Date object:', error);
          // If conversion fails, set to null to avoid database errors
          processedTask.dueDate = null;
        }
      }
    }

    // Log the processed task data
    console.log('Processed task data:', JSON.stringify(processedTask, null, 2));

    const [task] = await db
      .insert(tasks)
      .values(processedTask)
      .returning();
    return task;
  }

  async updateTask(id: number, updates: Partial<InsertTask>): Promise<Task | undefined> {
    // Log the incoming update data
    console.log('Updating task', id, 'with data:', JSON.stringify(updates, null, 2));

    // Create a new object with processed data
    const processedUpdates = {
      ...updates,
      updatedAt: new Date()
    };

    // Ensure dueDate is a proper Date object if it exists
    if (processedUpdates.dueDate !== undefined && processedUpdates.dueDate !== null) {
      // If it's already a Date object, keep it; otherwise, try to create a new Date
      if (!(processedUpdates.dueDate instanceof Date)) {
        console.log('Converting dueDate to Date object:', processedUpdates.dueDate);
        try {
          processedUpdates.dueDate = new Date(processedUpdates.dueDate);
          console.log('Converted dueDate:', processedUpdates.dueDate);
        } catch (error) {
          console.error('Failed to convert dueDate to Date object:', error);
          // If conversion fails, set to null to avoid database errors
          processedUpdates.dueDate = null;
        }
      }
    }

    // Log the processed update data
    console.log('Processed update data:', JSON.stringify(processedUpdates, null, 2));

    const [updatedTask] = await db
      .update(tasks)
      .set(processedUpdates)
      .where(eq(tasks.id, id))
      .returning();
    return updatedTask || undefined;
  }

  async deleteTask(id: number): Promise<boolean> {
    try {
      // Primeiro excluir comentários associados
      await db.delete(taskComments).where(eq(taskComments.taskId, id));

      // Depois excluir a tarefa
      await db.delete(tasks).where(eq(tasks.id, id));
      return true;
    } catch (error) {
      console.error("Erro ao excluir tarefa:", error);
      return false;
    }
  }

  async getTasksByAssignedToId(userId: number): Promise<Task[]> {
    return await db
      .select()
      .from(tasks)
      .where(eq(tasks.assignedToId, userId))
      .orderBy(desc(tasks.createdAt));
  }

  async getTasksByAssignedById(userId: number): Promise<Task[]> {
    return await db
      .select()
      .from(tasks)
      .where(eq(tasks.assignedById, userId))
      .orderBy(desc(tasks.createdAt));
  }

  async getTasksByStatus(status: string): Promise<Task[]> {
    return await db
      .select()
      .from(tasks)
      .where(eq(tasks.status, status))
      .orderBy(desc(tasks.createdAt));
  }

  async getTasksByRelatedLeadId(leadId: number): Promise<Task[]> {
    return await db
      .select()
      .from(tasks)
      .where(eq(tasks.relatedLeadId, leadId))
      .orderBy(desc(tasks.createdAt));
  }

  // Task comments methods
  async getTaskCommentsByTaskId(taskId: number): Promise<TaskComment[]> {
    return await db
      .select()
      .from(taskComments)
      .where(eq(taskComments.taskId, taskId))
      .orderBy(asc(taskComments.createdAt));
  }

  async createTaskComment(insertComment: InsertTaskComment): Promise<TaskComment> {
    const [comment] = await db
      .insert(taskComments)
      .values({
        ...insertComment,
      })
      .returning();
    return comment;
  }

  async deleteTaskComment(id: number): Promise<boolean> {
    try {
      await db.delete(taskComments).where(eq(taskComments.id, id));
      return true;
    } catch (error) {
      console.error("Erro ao excluir comentário:", error);
      return false;
    }
  }

  // WhatsApp methods
  async getWhatsappMessages(leadId: number): Promise<WhatsappMessage[]> {
    return await db
      .select()
      .from(whatsappMessages)
      .where(eq(whatsappMessages.leadId, leadId))
      .orderBy(asc(whatsappMessages.timestamp));
  }

  async getWhatsappMessageById(id: number): Promise<WhatsappMessage | undefined> {
    const messages = await db
      .select()
      .from(whatsappMessages)
      .where(eq(whatsappMessages.id, id))
      .limit(1);

    return messages[0];
  }

  async getWhatsappMessageByApiId(messageId: string): Promise<WhatsappMessage | undefined> {
    const messages = await db
      .select()
      .from(whatsappMessages)
      .where(eq(whatsappMessages.messageId, messageId))
      .limit(1);

    return messages[0];
  }

  async createWhatsappMessage(message: InsertWhatsappMessage): Promise<WhatsappMessage> {
    const [newMessage] = await db
      .insert(whatsappMessages)
      .values(message)
      .returning();
    return newMessage;
  }

  async updateWhatsappMessageStatus(id: number, status: string): Promise<WhatsappMessage | undefined> {
    const [updatedMessage] = await db
      .update(whatsappMessages)
      .set({ status })
      .where(eq(whatsappMessages.id, id))
      .returning();
    return updatedMessage || undefined;
  }

  async updateWhatsappMessageId(id: number, messageId: string): Promise<WhatsappMessage | undefined> {
    const [updatedMessage] = await db
      .update(whatsappMessages)
      .set({ messageId })
      .where(eq(whatsappMessages.id, id))
      .returning();
    return updatedMessage || undefined;
  }

  async deleteWhatsappMessage(id: number): Promise<boolean> {
    try {
      await db.delete(whatsappMessages).where(eq(whatsappMessages.id, id));
      return true;
    } catch (error) {
      console.error("Erro ao excluir mensagem:", error);
      return false;
    }
  }

  // WhatsApp Settings methods
  async getWhatsappSettings(): Promise<WhatsappSettings | undefined> {
    const [settings] = await db.select().from(whatsappSettings).orderBy(desc(whatsappSettings.updatedAt)).limit(1);
    return settings || undefined;
  }

  async saveWhatsappSettings(settings: InsertWhatsappSettings): Promise<WhatsappSettings> {
    // Sempre insere um novo registro (pode ser ajustado para update se preferir)
    const [saved] = await db.insert(whatsappSettings).values(settings).returning();
    return saved;
  }

  // Google OAuth2 token management
  async saveGoogleTokens(userId: number, tokens: {
    access_token: string;
    refresh_token?: string;
    expiry_date: number;
  }): Promise<void> {
    try {
      // Usar SQL direto para gerenciar tokens do Google
      await db.execute(sql`
        INSERT INTO google_tokens (userId, accessToken, refreshToken, expiryDate, updatedAt)
        VALUES (${userId}, ${tokens.access_token}, ${tokens.refresh_token || null}, ${tokens.expiry_date}, ${new Date().toISOString()})
        ON CONFLICT (userId) 
        DO UPDATE SET 
          accessToken = ${tokens.access_token},
          refreshToken = ${tokens.refresh_token || null},
          expiryDate = ${tokens.expiry_date},
          updatedAt = ${new Date().toISOString()}
      `);
      
      console.log("Google tokens salvos com sucesso para usuário:", userId);
    } catch (error) {
      console.error("Erro ao salvar tokens do Google:", error);
      throw error;
    }
  }

  async getGoogleTokens(userId: number): Promise<{
    access_token: string;
    refresh_token?: string;
    expiry_date: number;
  } | null> {
    try {
      const result = await db.execute(sql`
        SELECT accessToken, refreshToken, expiryDate 
        FROM google_tokens 
        WHERE userId = ${userId}
      `);
      
      if (!result.rows || result.rows.length === 0) {
        console.log("Nenhum token encontrado para usuário:", userId);
        return null;
      }
      
      const token = result.rows[0] as any;
      
      return {
        access_token: token.accesstoken,
        refresh_token: token.refreshtoken,
        expiry_date: parseInt(token.expirydate),
      };
    } catch (error) {
      console.error("Erro ao buscar tokens do Google:", error);
      throw error;
    }
  }

  async deleteGoogleTokens(userId: number): Promise<void> {
    try {
      await db.execute(sql`
        DELETE FROM google_tokens 
        WHERE userId = ${userId}
      `);
      
      console.log("Tokens do Google removidos para usuário:", userId);
    } catch (error) {
      console.error("Erro ao remover tokens do Google:", error);
      throw error;
    }
  }

  // NEW SCHEDULING SYSTEM METHODS

  // Lead helper method
  async getLeadById(id: number): Promise<Lead | undefined> {
    const [lead] = await db.select().from(leads).where(eq(leads.id, id));
    return lead || undefined;
  }

  // Agendamentos Recorrentes methods
  async createAgendamentoRecorrente(agendamento: InsertAgendamentoRecorrente): Promise<AgendamentoRecorrente> {
    const [created] = await db
      .insert(agendamentosRecorrentes)
      .values(agendamento)
      .returning();
    return created;
  }

  async getAgendamentosRecorrentes(): Promise<AgendamentoRecorrente[]> {
    return await db.select().from(agendamentosRecorrentes);
  }

  async updateAgendamentoRecorrente(id: number, agendamento: Partial<InsertAgendamentoRecorrente>): Promise<AgendamentoRecorrente | undefined> {
    try {
      const [updated] = await db
        .update(agendamentosRecorrentes)
        .set({ ...agendamento, updatedAt: new Date() })
        .where(eq(agendamentosRecorrentes.id, id))
        .returning();
      return updated || undefined;
    } catch (error) {
      console.error("Erro ao atualizar agendamento recorrente:", error);
      return undefined;
    }
  }

  async deleteAgendamentoRecorrente(id: number): Promise<boolean> {
    try {
      await db.delete(agendamentosRecorrentes).where(eq(agendamentosRecorrentes.id, id));
      return true;
    } catch (error) {
      console.error("Erro ao excluir agendamento recorrente:", error);
      return false;
    }
  }

  // Aulas methods
  async getAulas(filters?: any): Promise<Aula[]> {
    let query = db.select().from(aulas);
    
    if (filters) {
      const conditions = [];
      
      if (filters.startDate && filters.endDate) {
        conditions.push(
          and(
            sql`${aulas.startTime} >= ${filters.startDate}`,
            sql`${aulas.startTime} <= ${filters.endDate}`
          )
        );
      }
      
      if (filters.professorId) {
        conditions.push(eq(aulas.professorId, filters.professorId));
      }
      
      if (filters.studentId) {
        conditions.push(eq(aulas.studentId, filters.studentId));
      }
      
      if (filters.status) {
        conditions.push(eq(aulas.status, filters.status));
      }
      
      if (conditions.length > 0) {
        query = query.where(and(...conditions));
      }
    }
    
    return await query.orderBy(asc(aulas.startTime));
  }

  async getAulaById(id: number): Promise<Aula | undefined> {
    const [aula] = await db.select().from(aulas).where(eq(aulas.id, id));
    return aula || undefined;
  }

  async createAula(aula: InsertAula): Promise<Aula> {
    const [created] = await db
      .insert(aulas)
      .values(aula)
      .returning();
    return created;
  }

  async createMultipleAulas(aulasList: InsertAula[]): Promise<Aula[]> {
    const created = await db
      .insert(aulas)
      .values(aulasList)
      .returning();
    return created;
  }

  async updateAula(id: number, aula: Partial<InsertAula>): Promise<Aula | undefined> {
    try {
      const [updated] = await db
        .update(aulas)
        .set({ ...aula, updatedAt: new Date() })
        .where(eq(aulas.id, id))
        .returning();
      return updated || undefined;
    } catch (error) {
      console.error("Erro ao atualizar aula:", error);
      return undefined;
    }
  }

  async deleteAula(id: number): Promise<boolean> {
    try {
      await db.delete(aulas).where(eq(aulas.id, id));
      return true;
    } catch (error) {
      console.error("Erro ao excluir aula:", error);
      return false;
    }
  }

  // Conflict checking
  async checkSchedulingConflicts(
    professorId: number, 
    studentId: number, 
    startTime: Date, 
    endTime: Date, 
    excludeAulaId?: number
  ): Promise<any> {
    try {
      const conditions = [
        and(
          // Check for overlapping times
          or(
            and(
              sql`${aulas.startTime} < ${endTime}`,
              sql`${aulas.endTime} > ${startTime}`
            )
          ),
          // Check for same professor OR same student
          or(
            eq(aulas.professorId, professorId),
            eq(aulas.studentId, studentId)
          ),
          // Exclude cancelled classes
          sql`${aulas.status} != 'cancelado'`
        )
      ];

      // Exclude specific aula if provided (for updates)
      if (excludeAulaId) {
        conditions.push(sql`${aulas.id} != ${excludeAulaId}`);
      }

      const conflicts = await db
        .select()
        .from(aulas)
        .where(and(...conditions))
        .limit(1);

      return conflicts.length > 0 ? conflicts[0] : null;
    } catch (error) {
      console.error("Erro ao verificar conflitos:", error);
      return null;
    }
  }
}

// Inicializa o armazenamento usando o banco de dados PostgreSQL
export const storage = new DatabaseStorage();
</file>

<file path="server/supabase-session-store.ts">
import { Store } from 'express-session';
import { db, sql } from './db';
import { httpSessions } from '@shared/schema';
import { eq } from 'drizzle-orm';

export class SupabaseSessionStore extends Store {
  private ttl: number;

  constructor(options: { ttl?: number } = {}) {
    super();
    this.ttl = options.ttl || 86400; // 24 hours default
  }

  async get(sid: string, callback: (err?: any, session?: any) => void): Promise<void> {
    try {
      const [result] = await db
        .select()
        .from(httpSessions)
        .where(eq(httpSessions.sid, sid));

      if (!result) {
        return callback();
      }

      // Check if session has expired
      if (result.expire && new Date() > result.expire) {
        await this.destroy(sid, callback);
        return;
      }

      callback(null, result.sess);
    } catch (error) {
      callback(error);
    }
  }

  async set(sid: string, session: any, callback?: (err?: any) => void): Promise<void> {
    try {
      const expire = new Date(Date.now() + (this.ttl * 1000));
      
      await db
        .insert(httpSessions)
        .values({
          sid,
          sess: session,
          expire
        })
        .onConflictDoUpdate({
          target: httpSessions.sid,
          set: {
            sess: session,
            expire
          }
        });

      if (callback) callback();
    } catch (error) {
      if (callback) callback(error);
    }
  }

  async destroy(sid: string, callback?: (err?: any) => void): Promise<void> {
    try {
      await db
        .delete(httpSessions)
        .where(eq(httpSessions.sid, sid));

      if (callback) callback();
    } catch (error) {
      if (callback) callback(error);
    }
  }

  async touch(sid: string, session: any, callback?: (err?: any) => void): Promise<void> {
    try {
      const expire = new Date(Date.now() + (this.ttl * 1000));
      
      await db
        .update(httpSessions)
        .set({ expire })
        .where(eq(httpSessions.sid, sid));

      if (callback) callback();
    } catch (error) {
      if (callback) callback(error);
    }
  }

  async clear(callback?: (err?: any) => void): Promise<void> {
    try {
      await sql`DELETE FROM http_sessions`;
      if (callback) callback();
    } catch (error) {
      if (callback) callback(error);
    }
  }

  async length(callback: (err?: any, length?: number) => void): Promise<void> {
    try {
      const result = await sql`SELECT COUNT(*) as count FROM http_sessions`;
      const count = parseInt(result[0].count);
      callback(null, count);
    } catch (error) {
      callback(error);
    }
  }

  async all(callback: (err?: any, sessions?: any[]) => void): Promise<void> {
    try {
      const results = await db.select().from(httpSessions);
      const sessions = results.reduce((acc, row) => {
        acc[row.sid] = row.sess;
        return acc;
      }, {} as any);
      callback(null, sessions);
    } catch (error) {
      callback(error);
    }
  }

  // Cleanup expired sessions
  async cleanup(): Promise<void> {
    try {
      await sql`DELETE FROM http_sessions WHERE expire < NOW()`;
    } catch (error) {
      console.error('Error cleaning up expired sessions:', error);
    }
  }
}
</file>

<file path="server/utils/auth.utils.ts">
import { scrypt, randomBytes } from "crypto";
import { promisify } from "util";

const scryptAsync = promisify(scrypt);

export async function hashPassword(password: string): Promise<string> {
  const salt = randomBytes(16).toString("hex");
  const buf = (await scryptAsync(password, salt, 64)) as Buffer;
  return `${buf.toString("hex")}.${salt}`;
}
</file>

<file path="server/utils/lead.utils.ts">
export const normalizePhone = (phone: string): string => {
  if (!phone) return '';
  return phone.replace(/[\s\(\)\-\+]/g, '');
};
</file>

<file path="server/utils/task.utils.ts">
import type { IStorage } from "../storage"; // Adjust path as needed

// Helper para adicionar nomes de usuários às tarefas
export async function addUserNamesToTasks(tasks: any[], storage: IStorage) {
  // Buscar todos os usuários para preencher os nomes
  const users = await storage.getAllUsers();
  
  // Criar mapa de IDs -> nomes de usuários para busca rápida
  const userMap = users.reduce((acc: Record<number, string>, user: { id: number, username: string }) => {
    acc[user.id] = user.username;
    return acc;
  }, {});
  
  // Adicionar nomes de usuários às tarefas
  return tasks.map(task => ({
    ...task,
    assignedToName: userMap[task.assignedToId] || 'Usuário não encontrado',
    assignedByName: userMap[task.assignedById] || 'Usuário não encontrado'
  }));
}
</file>

<file path="server/validation.ts">
import { Request, Response, NextFunction } from 'express';
import { ZodSchema, ZodError } from 'zod';

export const validateBody = (schema: ZodSchema) => {
  return (req: Request, res: Response, next: NextFunction) => {
    try {
      req.body = schema.parse(req.body);
      next();
    } catch (error) {
      if (error instanceof ZodError) {
        return res.status(400).json({
          message: 'Dados inválidos',
          errors: error.errors.map(err => ({
            path: err.path.join('.'),
            message: err.message
          }))
        });
      }
      next(error);
    }
  };
};

export const validateParams = (schema: ZodSchema) => {
  return (req: Request, res: Response, next: NextFunction) => {
    try {
      req.params = schema.parse(req.params);
      next();
    } catch (error) {
      if (error instanceof ZodError) {
        return res.status(400).json({
          message: 'Parâmetros inválidos',
          errors: error.errors.map(err => ({
            path: err.path.join('.'),
            message: err.message
          }))
        });
      }
      next(error);
    }
  };
};

export const validateQuery = (schema: ZodSchema) => {
  return (req: Request, res: Response, next: NextFunction) => {
    try {
      req.query = schema.parse(req.query);
      next();
    } catch (error) {
      if (error instanceof ZodError) {
        return res.status(400).json({
          message: 'Query parameters inválidos',
          errors: error.errors.map(err => ({
            path: err.path.join('.'),
            message: err.message
          }))
        });
      }
      next(error);
    }
  };
};
</file>

<file path="server/vite.ts">
import express, { type Express } from "express";
import fs from "fs";
import path from "path";
import { createServer as createViteServer, createLogger } from "vite";
import { type Server } from "http";
import viteConfig from "../vite.config";
import { nanoid } from "nanoid";

const viteLogger = createLogger();

export function log(message: string, source = "express") {
  const formattedTime = new Date().toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true,
  });

  console.log(`${formattedTime} [${source}] ${message}`);
}

export async function setupVite(app: Express, server: Server) {
  const serverOptions = {
    middlewareMode: true,
    hmr: { server },
    allowedHosts: true,
  };

  const vite = await createViteServer({
    ...viteConfig,
    configFile: false,
    customLogger: {
      ...viteLogger,
      error: (msg, options) => {
        viteLogger.error(msg, options);
        process.exit(1);
      },
    },
    server: serverOptions,
    appType: "custom",
  });

  app.use(vite.middlewares);
  app.use("*", async (req, res, next) => {
    const url = req.originalUrl;

    try {
      const clientTemplate = path.resolve(
        import.meta.dirname,
        "..",
        "client",
        "index.html",
      );

      // always reload the index.html file from disk incase it changes
      let template = await fs.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(
        `src="/src/main.tsx"`,
        `src="/src/main.tsx?v=${nanoid()}"`,
      );
      const page = await vite.transformIndexHtml(url, template);
      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e as Error);
      next(e);
    }
  });
}

export function serveStatic(app: Express) {
  const distPath = path.resolve(import.meta.dirname, "public");

  if (!fs.existsSync(distPath)) {
    throw new Error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`,
    );
  }

  app.use(express.static(distPath));

  // fall through to index.html if the file doesn't exist
  app.use("*", (_req, res) => {
    res.sendFile(path.resolve(distPath, "index.html"));
  });
}
</file>

<file path="server/weather-service.ts">
/**
 * Serviço de clima
 * Integra com a Weather API para fornecer informações meteorológicas
 */
import axios from "axios";
import { log } from "./vite";

// Chave de API para Weather API
const API_KEY = process.env.WEATHER_API_KEY;
const BASE_URL = "https://api.weatherapi.com/v1";

// Interface para os dados da resposta da API
export interface WeatherData {
  location: {
    name: string;
    region: string;
    country: string;
    lat: number;
    lon: number;
    localtime: string;
  };
  current: {
    temp_c: number;
    temp_f: number;
    condition: {
      text: string;
      icon: string;
      code: number;
    };
    wind_kph: number;
    wind_dir: string;
    humidity: number;
    feelslike_c: number;
    feelslike_f: number;
    uv: number;
    is_day: number;
  };
  forecast?: {
    forecastday: {
      date: string;
      day: {
        maxtemp_c: number;
        mintemp_c: number;
        condition: {
          text: string;
          icon: string;
          code: number;
        };
      };
    }[];
  };
  error?: {
    code: number;
    message: string;
  };
}

// Interface para erros da API
export interface WeatherError {
  error: {
    code: number;
    message: string;
  };
}

/**
 * Obtém dados do clima para uma cidade específica
 * @param city Nome da cidade ou estado
 * @returns Dados meteorológicos ou erro
 */
export async function getWeatherByCity(city: string): Promise<WeatherData> {
  try {
    log(`Buscando dados meteorológicos para: ${city}`, "weather-service");
    
    // Constrói a URL para a API de clima atual
    const url = `${BASE_URL}/forecast.json?key=${API_KEY}&q=${encodeURIComponent(city)}&days=1&lang=pt`;
    
    // Faz a requisição para a API
    const response = await axios.get<WeatherData>(url);
    
    // Retorna os dados recebidos
    return response.data;
  } catch (error: any) {
    log(`Erro ao buscar dados meteorológicos: ${error.message}`, "weather-service");
    
    // Se tiver um erro formatado da API, retorna-o
    if (error.response?.data?.error) {
      return {
        error: error.response.data.error,
        location: { name: "", region: "", country: "", lat: 0, lon: 0, localtime: "" },
        current: {
          temp_c: 0,
          temp_f: 0,
          condition: { text: "", icon: "", code: 0 },
          wind_kph: 0,
          wind_dir: "",
          humidity: 0,
          feelslike_c: 0,
          feelslike_f: 0,
          uv: 0,
          is_day: 0
        }
      };
    }
    
    // Caso contrário, formata um erro genérico
    return {
      error: {
        code: 500,
        message: `Erro ao obter dados do clima: ${error.message}`
      },
      location: { name: "", region: "", country: "", lat: 0, lon: 0, localtime: "" },
      current: {
        temp_c: 0,
        temp_f: 0,
        condition: { text: "", icon: "", code: 0 },
        wind_kph: 0,
        wind_dir: "",
        humidity: 0,
        feelslike_c: 0,
        feelslike_f: 0,
        uv: 0,
        is_day: 0
      }
    };
  }
}

/**
 * Verifica se o serviço de clima está funcionando
 * @returns Status do serviço
 */
export async function checkWeatherService(): Promise<{ status: string; message?: string }> {
  try {
    // Testa a API com uma cidade padrão (São Paulo)
    const response = await getWeatherByCity("São Paulo");
    
    if (response.error) {
      return {
        status: "error",
        message: `Erro na API de clima: ${response.error.message}`
      };
    }
    
    return {
      status: "connected",
      message: `Serviço de clima conectado. Temperatura em ${response.location.name}: ${response.current.temp_c}°C`
    };
  } catch (error: any) {
    return {
      status: "error",
      message: `Falha na verificação do serviço de clima: ${error.message}`
    };
  }
}
</file>

<file path="server/whatsapp-service.ts">
/**
 * Serviço WhatsApp API
 * Integra com a API oficial do WhatsApp e Evolution API para envio e recebimento de mensagens
 */

import axios from 'axios';
import { log } from './vite';
import { Lead } from '@shared/schema';
import { storage } from './storage';

// Configurações da API do WhatsApp
const WHATSAPP_API_TOKEN = process.env.WHATSAPP_API_TOKEN;
const WHATSAPP_PHONE_ID = process.env.WHATSAPP_PHONE_ID || '6536281892435135';
const WHATSAPP_API_URL = 'https://graph.facebook.com/v18.0';

// Evolution API configs
const EVOLUTION_API_URL = process.env.EVOLUTION_API_URL || 'https://evolution-api.example.com/api/v1';
const EVOLUTION_API_TOKEN = process.env.EVOLUTION_API_TOKEN || '7f3b2c4d1e6a8f0b9d3c5e7a2f4b6d8c';
const EVOLUTION_API_INSTANCE = process.env.EVOLUTION_API_INSTANCE || 'default';
const WHATSAPP_TEST_MODE = process.env.WHATSAPP_TEST_MODE === 'true';

// Logs para facilitar depuração
log(`Usando EVOLUTION_API_URL: ${EVOLUTION_API_URL}`, 'info');
log(`Modo de teste WhatsApp: ${WHATSAPP_TEST_MODE ? 'Ativado' : 'Desativado'}`, 'info');

// Interface para resposta da API WhatsApp Oficial
interface WhatsAppAPIResponse {
  messaging_product: string;
  contacts?: {
    input: string;
    wa_id: string;
  }[];
  messages?: {
    id: string;
  }[];
  error?: {
    message: string;
    type: string;
    code: number;
    error_subcode?: number;
    fbtrace_id: string;
  };
}

// Interface para resposta da Evolution API
interface EvolutionAPIResponse {
  key?: {
    fromMe: boolean;
    remoteJid: string;
    id: string;
  };
  status?: string;
  message?: string;
  error?: string;
  info?: any;
}

// Interface compartilhada para retorno das funções de WhatsApp
interface WhatsAppResult {
  success: boolean;
  messageId?: string;
  error?: string;
  details?: any;
}

/**
 * Função auxiliar para fazer requisições para a Evolution API
 */
async function makeEvolutionRequest(endpoint: string, method = 'GET', data: any = null): Promise<WhatsAppResult> {
  try {
    const settings = await getConfigSettings();
    const { apiUrl, apiToken, apiInstance } = settings;

    if (!apiUrl || !apiToken) {
      return { success: false, error: 'Configuração da Evolution API (URL ou Token) não encontrada.' };
    }

    // Substitua {instance} no endpoint se necessário
    const finalEndpoint = endpoint.replace('{instance}', apiInstance);
    const fullUrl = `${apiUrl}${finalEndpoint}`;
    
    log(`Fazendo requisição ${method} para ${fullUrl}`, 'info');

    const response = await axios({
      method,
      url: fullUrl,
      data,
      headers: {
        'Content-Type': 'application/json',
        'apikey': apiToken
      },
      timeout: 20000 // 20 segundos
    });

    return { success: true, details: response.data };
  } catch (error) {
    let errorMessage = 'Erro desconhecido na requisição';
    let details = null;

    if (axios.isAxiosError(error)) {
      if (error.response) {
        errorMessage = error.response.data?.error || 
                      error.response.data?.message || 
                      `Erro ${error.response.status}: ${error.message}`;
        details = error.response.data;
      } else if (error.request) {
        errorMessage = 'Não foi possível conectar à Evolution API. Verifique sua conexão.';
      } else {
        errorMessage = `Erro na configuração da requisição: ${error.message}`;
      }
    }
    
    log(`Erro na requisição para Evolution API: ${errorMessage}`, 'error');
    return { success: false, error: errorMessage, details };
  }
}

/**
 * Envia mensagem de texto via Evolution API
 */
export async function sendWhatsAppMessage(lead: Lead, message: string): Promise<WhatsAppResult> {
  const phoneNumber = formatPhoneNumber(lead.phone);
  if (!phoneNumber) {
    return { success: false, error: `Número de telefone inválido: ${lead.phone}` };
  }

  log(`Enviando mensagem Evolution API para ${lead.name} (${phoneNumber})`, 'info');

  try {
    const settings = await getConfigSettings();
    const { apiInstance } = settings;
    
    // Endpoint de texto da Evolution API
    const endpoint = `/message/text/${apiInstance}`;
    
    // Payload conforme documentação da Evolution API
    const payload = {
      number: phoneNumber,
      options: {
        delay: 1200, // Delay em ms (recomendado pela Evolution API)
        presence: "composing" // Mostra "digitando..." antes de enviar
      },
      textMessage: {
        text: message
      }
    };

    const result = await makeEvolutionRequest(endpoint, 'POST', payload);
    
    if (result.success) {
      log(`Mensagem enviada com sucesso via Evolution API: ${JSON.stringify(result.details)}`, 'info');
      
      // Extrair o ID da mensagem da resposta
      const messageId = result.details?.key?.id || 
                        result.details?.messageId || 
                        result.details?.id || 
                        `temp_${Date.now()}`;
      
      return { 
        success: true, 
        messageId, 
        details: result.details 
      };
    }
    
    return result;
  } catch (error) {
    log(`Erro ao enviar mensagem Evolution API: ${error}`, 'error');
    return { success: false, error: 'Erro desconhecido ao enviar mensagem', details: error };
  }
}

/**
 * Envia uma mensagem de template WhatsApp
 * Templates são mensagens pré-aprovadas pela Meta
 */
export async function sendWhatsAppTemplate(lead: Lead, templateName: string, language: string = 'pt_BR'): Promise<WhatsAppResult> {
  // Se estamos usando a Meta API diretamente (API oficial do WhatsApp)
  if (WHATSAPP_API_TOKEN) {
    const phoneNumber = formatPhoneNumber(lead.phone);
    if (!phoneNumber) {
      return { success: false, error: `Número de telefone inválido: ${lead.phone}` };
    }
    
    log(`Enviando template WhatsApp "${templateName}" para ${lead.name} (${phoneNumber})`, 'info');
    
    try {
      const response = await axios.post<WhatsAppAPIResponse>(
        `${WHATSAPP_API_URL}/${WHATSAPP_PHONE_ID}/messages`,
        {
          messaging_product: 'whatsapp',
          recipient_type: 'individual',
          to: phoneNumber,
          type: 'template',
          template: {
            name: templateName,
            language: {
              code: language
            }
          }
        },
        {
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${WHATSAPP_API_TOKEN}`
          },
          timeout: 10000 // 10 segundos de timeout
        }
      );

      if (response.data.messages && response.data.messages.length > 0) {
        const messageId = response.data.messages[0].id;
        log(`Template enviado com sucesso. ID: ${messageId}`, 'info');
        return { success: true, messageId, details: response.data };
      }
      
      log(`Template enviado, mas sem ID retornado`, 'warn');
      return { success: true, details: response.data };
    } catch (error) {
      log(`Erro ao enviar template WhatsApp: ${JSON.stringify(error)}`, 'error');
      let errorMessage = 'Erro desconhecido ao enviar mensagem';
      let details = null;
      
      if (axios.isAxiosError(error)) {
        if (error.response) {
          errorMessage = error.response.data?.error?.message || 
                        error.response.data?.message || 
                        `Erro ${error.response.status}: ${error.message}`;
          details = error.response.data;
        } else if (error.request) {
          errorMessage = 'Não foi possível conectar ao servidor do WhatsApp. Verifique sua conexão.';
        } else {
          errorMessage = `Erro na configuração da requisição: ${error.message}`;
        }
      }
      
      return { success: false, error: errorMessage, details };
    }
  } 
  // Caso contrário, tentamos usar a Evolution API para enviar template
  else {
    const phoneNumber = formatPhoneNumber(lead.phone);
    if (!phoneNumber) {
      return { success: false, error: `Número de telefone inválido: ${lead.phone}` };
    }

    try {
      const settings = await getConfigSettings();
      const { apiInstance } = settings;
      
      // Endpoint de template da Evolution API
      const endpoint = `/message/template/${apiInstance}`;
      
      // Payload conforme documentação da Evolution API
      const payload = {
        number: phoneNumber,
        options: {
          delay: 1200,
          presence: "composing" 
        },
        template: {
          name: templateName,
          language: {
            code: language
          }
        }
      };

      return await makeEvolutionRequest(endpoint, 'POST', payload);
    } catch (error) {
      log(`Erro ao enviar template via Evolution API: ${error}`, 'error');
      return { success: false, error: 'Erro ao enviar template', details: error };
    }
  }
}

/**
 * Checa conexão com Evolution API
 * Verifica o status da instância usando o endpoint de instância da Evolution API
 */
export async function checkWhatsAppConnection(): Promise<WhatsAppResult> {
  try {
    const settings = await getConfigSettings();
    const { apiUrl, apiToken, apiInstance } = settings;

    if (!apiUrl || !apiToken) {
      return { success: false, error: 'Configuração da Evolution API (URL ou Token) não encontrada.' };
    }

    // Para ambientes de produção, usar a URL real da sua Evolution API
    // Se estamos em ambiente de desenvolvimento e sem URL definida, tentamos simular uma resposta positiva
    if (apiUrl.includes('example.com') && process.env.NODE_ENV === 'development') {
      log('Ambiente de desenvolvimento detectado. Simulando resposta da Evolution API.', 'info');
      return {
        success: true,
        details: {
          name: 'Evolution API (Simulação)',
          phone: '+5511987654321',
          instance: apiInstance,
          status: 'CONNECTED',
          qrcode: null
        }
      };
    }

    // Endpoint específico para verificar o status da instância
    const endpoint = `/instances/instance/${apiInstance}`;
    return await makeEvolutionRequest(endpoint, 'GET');
  } catch (error) {
    log(`Erro ao verificar conexão: ${error}`, 'error');
    return { success: false, error: 'Erro ao verificar conexão com a Evolution API', details: error };
  }
}

/**
 * Envia imagem via Evolution API
 */
export async function sendWhatsAppImage(
  lead: Lead, 
  imageUrl: string, 
  caption: string = ''
): Promise<WhatsAppResult> {
  const phoneNumber = formatPhoneNumber(lead.phone);
  if (!phoneNumber) {
    return { success: false, error: `Número de telefone inválido: ${lead.phone}` };
  }

  log(`Enviando imagem para ${lead.name} (${phoneNumber})`, 'info');

  try {
    const settings = await getConfigSettings();
    const { apiInstance } = settings;
    
    // Endpoint para envio de imagem
    const endpoint = `/message/image/${apiInstance}`;
    
    // Payload conforme documentação da Evolution API
    const payload = {
      number: phoneNumber,
      options: {
        delay: 1200,
        presence: "composing"
      },
      image: {
        url: imageUrl,
        caption: caption
      }
    };

    return await makeEvolutionRequest(endpoint, 'POST', payload);
  } catch (error) {
    log(`Erro ao enviar imagem: ${error}`, 'error');
    return { success: false, error: 'Erro ao enviar imagem', details: error };
  }
}

/**
 * Envia documento via Evolution API
 */
export async function sendWhatsAppDocument(
  lead: Lead,
  documentUrl: string,
  fileName: string,
  caption: string = ''
): Promise<WhatsAppResult> {
  const phoneNumber = formatPhoneNumber(lead.phone);
  if (!phoneNumber) {
    return { success: false, error: `Número de telefone inválido: ${lead.phone}` };
  }

  log(`Enviando documento para ${lead.name} (${phoneNumber})`, 'info');

  try {
    const settings = await getConfigSettings();
    const { apiInstance } = settings;
    
    // Endpoint para envio de documento
    const endpoint = `/message/document/${apiInstance}`;
    
    // Payload conforme documentação da Evolution API
    const payload = {
      number: phoneNumber,
      options: {
        delay: 1200
      },
      document: {
        url: documentUrl,
        fileName: fileName,
        caption: caption
      }
    };

    return await makeEvolutionRequest(endpoint, 'POST', payload);
  } catch (error) {
    log(`Erro ao enviar documento: ${error}`, 'error');
    return { success: false, error: 'Erro ao enviar documento', details: error };
  }
}

/**
 * Envia áudio via Evolution API
 */
export async function sendWhatsAppAudio(
  lead: Lead,
  audioUrl: string
): Promise<WhatsAppResult> {
  const phoneNumber = formatPhoneNumber(lead.phone);
  if (!phoneNumber) {
    return { success: false, error: `Número de telefone inválido: ${lead.phone}` };
  }

  log(`Enviando áudio para ${lead.name} (${phoneNumber})`, 'info');

  try {
    const settings = await getConfigSettings();
    const { apiInstance } = settings;
    
    // Endpoint para envio de áudio
    const endpoint = `/message/audio/${apiInstance}`;
    
    // Payload conforme documentação da Evolution API
    const payload = {
      number: phoneNumber,
      options: {
        delay: 1200
      },
      audio: {
        url: audioUrl
      }
    };

    return await makeEvolutionRequest(endpoint, 'POST', payload);
  } catch (error) {
    log(`Erro ao enviar áudio: ${error}`, 'error');
    return { success: false, error: 'Erro ao enviar áudio', details: error };
  }
}

/**
 * Envia vídeo via Evolution API
 */
export async function sendWhatsAppVideo(
  lead: Lead,
  videoUrl: string,
  caption: string = ''
): Promise<WhatsAppResult> {
  const phoneNumber = formatPhoneNumber(lead.phone);
  if (!phoneNumber) {
    return { success: false, error: `Número de telefone inválido: ${lead.phone}` };
  }

  log(`Enviando vídeo para ${lead.name} (${phoneNumber})`, 'info');

  try {
    const settings = await getConfigSettings();
    const { apiInstance } = settings;
    
    // Endpoint para envio de vídeo
    const endpoint = `/message/video/${apiInstance}`;
    
    // Payload conforme documentação da Evolution API
    const payload = {
      number: phoneNumber,
      options: {
        delay: 1200
      },
      video: {
        url: videoUrl,
        caption: caption
      }
    };

    return await makeEvolutionRequest(endpoint, 'POST', payload);
  } catch (error) {
    log(`Erro ao enviar vídeo: ${error}`, 'error');
    return { success: false, error: 'Erro ao enviar vídeo', details: error };
  }
}

/**
 * Obtém o QR Code para conexão do WhatsApp
 */
export async function getWhatsAppQRCode(): Promise<WhatsAppResult> {
  try {
    const settings = await getConfigSettings();
    const { apiInstance } = settings;
    
    // Primeiro, verificamos se já existe uma instância conectada
    const statusResult = await makeEvolutionRequest(`/instances/instance/${apiInstance}`, 'GET');
    
    if (statusResult.success && statusResult.details?.status === 'open') {
      // Se já estiver conectado, não precisamos de QR Code
      return {
        success: true,
        details: {
          connected: true,
          message: 'WhatsApp já está conectado',
          instance: statusResult.details
        }
      };
    }
    
    // Se não estiver conectado ou em estado inválido, geramos novo QR Code
    const qrResult = await makeEvolutionRequest(`/instances/qrcode/${apiInstance}`, 'GET');
    
    if (!qrResult.success) {
      return qrResult;
    }

    return {
      success: true,
      details: {
        connected: false,
        qrcode: qrResult.details?.qrcode,
        message: 'Escaneie o QR Code para conectar'
      }
    };
  } catch (error) {
    log(`Erro ao obter QR Code: ${error}`, 'error');
    return { success: false, error: 'Erro ao obter QR Code', details: error };
  }
}

/**
 * Verifica o status de uma mensagem
 */
export async function checkMessageStatus(messageId: string): Promise<WhatsAppResult> {
  if (!messageId) {
    return { success: false, error: 'ID da mensagem não fornecido' };
  }
  
  try {
    const settings = await getConfigSettings();
    const { apiInstance } = settings;
    
    // Endpoint para verificar status de mensagem
    const endpoint = `/message/statusMessage/${apiInstance}/${messageId}`;
    
    const result = await makeEvolutionRequest(endpoint, 'GET');
    
    if (!result.success) {
      return result;
    }
    
    // Normalizar o status da mensagem com base na resposta da Evolution API
    let normalizedStatus = 'sent'; // Default
    const rawStatus = result.details?.status || '';
    
    // Mapeamento de status da Evolution API para nosso sistema
    switch (rawStatus.toLowerCase()) {
      case 'pending':
      case 'sending':
        normalizedStatus = 'pending';
        break;
      case 'sent':
        normalizedStatus = 'sent';
        break;
      case 'received':
      case 'delivered':
        normalizedStatus = 'delivered';
        break;
      case 'read':
        normalizedStatus = 'read';
        break;
      case 'failed':
      case 'error':
        normalizedStatus = 'failed';
        break;
      default:
        normalizedStatus = 'sent'; // Fallback
    }
    
    return {
      success: true,
      details: {
        status: normalizedStatus,
        originalStatus: rawStatus,
        timestamp: result.details?.timestamp || new Date().toISOString()
      }
    };
  } catch (error) {
    log(`Erro ao verificar status de mensagem ${messageId}: ${error}`, 'error');
    return { success: false, error: 'Erro ao verificar status da mensagem', details: error };
  }
}

/**
 * Formata o número de telefone para o formato esperado pelo WhatsApp
 */
export function formatPhoneNumber(phoneNumber: string | null | undefined): string | null {
  if (!phoneNumber) return null;
  
  // Remove todos os caracteres não numéricos
  let cleaned = phoneNumber.replace(/\D/g, '');
  
  // Se começar com 0, remove
  if (cleaned.startsWith('0')) {
    cleaned = cleaned.substring(1);
  }
  
  // Se for brasileiro e não começa com 55, adiciona o código do Brasil
  if (!cleaned.startsWith('55') && cleaned.length <= 11) {
    cleaned = '55' + cleaned;
  }
  
  // Verifica se o número tem pelo menos 10 dígitos (mínimo para um número de telefone válido)
  if (cleaned.length < 10) {
    return null;
  }
  
  return cleaned;
}

/**
 * Salva as configurações da Evolution API
 */
export async function saveConfigSettings(apiUrl: string, apiToken?: string, apiInstance = 'default'): Promise<WhatsAppResult> {
  try {
    // Normaliza a URL da API (remove a barra final se existir)
    let normalizedUrl = apiUrl.trim();
    if (normalizedUrl.endsWith('/')) {
      normalizedUrl = normalizedUrl.slice(0, -1);
    }
    
    // Se não começa com http:// ou https://, adiciona https://
    if (!normalizedUrl.startsWith('http://') && !normalizedUrl.startsWith('https://')) {
      normalizedUrl = 'https://' + normalizedUrl;
    }

    // Se não temos o token atual e não foi fornecido um novo, retorna erro
    if (!apiToken) {
      const existingSettings = await storage.getWhatsappSettings();
      if (!existingSettings?.apiToken) {
        return { success: false, error: 'Token da API é obrigatório para configuração inicial' };
      }
      
      // Se já temos um token no banco, vamos usar ele
      await storage.saveWhatsappSettings({
        apiUrl: normalizedUrl,
        apiToken: existingSettings.apiToken,
        apiInstance: apiInstance || 'default'
      });
    } else {
      // Caso contrário, salvamos com o novo token
      await storage.saveWhatsappSettings({
        apiUrl: normalizedUrl,
        apiToken,
        apiInstance: apiInstance || 'default'
      });
    }

    return { success: true, details: { apiUrl: normalizedUrl, apiInstance, hasToken: true } };
  } catch (error) {
    log(`Erro ao salvar configurações: ${error}`, 'error');
    return { success: false, error: 'Erro ao salvar configurações', details: error };
  }
}

/**
 * Obtém as configurações da Evolution API
 */
export async function getConfigSettings(): Promise<any> {
  try {
    const config = await storage.getWhatsappSettings();
    
    // Valores default quando não configurado
    return {
      apiUrl: config?.apiUrl || process.env.EVOLUTION_API_URL || '',
      apiToken: config?.apiToken || process.env.EVOLUTION_API_TOKEN || '',
      apiInstance: config?.apiInstance || process.env.EVOLUTION_API_INSTANCE || 'default',
      hasToken: !!config?.apiToken || !!process.env.EVOLUTION_API_TOKEN,
      lastUpdated: config?.updatedAt
    };
  } catch (error) {
    log(`Erro ao obter configurações: ${error}`, 'error');
    // Retorna valores default
    return {
      apiUrl: process.env.EVOLUTION_API_URL || '',
      apiToken: process.env.EVOLUTION_API_TOKEN || '',
      apiInstance: process.env.EVOLUTION_API_INSTANCE || 'default',
      hasToken: !!process.env.EVOLUTION_API_TOKEN,
      lastUpdated: null
    };
  }
}

// Nova função para obter grupos disponíveis
export async function getWhatsAppGroups(): Promise<WhatsAppResult> {
  try {
    const settings = await getConfigSettings();
    const { apiInstance } = settings;
    
    // Endpoint para obter grupos
    const endpoint = `/group/fetchAllGroups/${apiInstance}`;
    
    return await makeEvolutionRequest(endpoint, 'GET');
  } catch (error) {
    log(`Erro ao buscar grupos: ${error}`, 'error');
    return { success: false, error: 'Erro ao buscar grupos', details: error };
  }
}

// Nova função para criar um grupo
export async function createWhatsAppGroup(
  name: string, 
  participants: string[]
): Promise<WhatsAppResult> {
  try {
    const settings = await getConfigSettings();
    const { apiInstance } = settings;
    
    // Endpoint para criar grupo
    const endpoint = `/group/create/${apiInstance}`;
    
    // Prepare phone numbers in array
    const formattedParticipants = participants.map(p => formatPhoneNumber(p)).filter(Boolean);
    
    if (formattedParticipants.length === 0) {
      return { success: false, error: 'É necessário pelo menos um participante válido' };
    }
    
    const payload = {
      subject: name,
      participants: formattedParticipants
    };
    
    return await makeEvolutionRequest(endpoint, 'POST', payload);
  } catch (error) {
    log(`Erro ao criar grupo: ${error}`, 'error');
    return { success: false, error: 'Erro ao criar grupo', details: error };
  }
}

// Nova função para obter os contatos
export async function getWhatsAppContacts(): Promise<WhatsAppResult> {
  try {
    const settings = await getConfigSettings();
    const { apiInstance } = settings;
    
    // Endpoint para obter contatos
    const endpoint = `/contact/get-all/${apiInstance}`;
    
    return await makeEvolutionRequest(endpoint, 'GET');
  } catch (error) {
    log(`Erro ao buscar contatos: ${error}`, 'error');
    return { success: false, error: 'Erro ao buscar contatos', details: error };
  }
}
</file>

<file path="shared/schema.ts">
import { pgTable, text, serial, integer, timestamp, boolean, jsonb, pgEnum } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";

// Definindo o enum para roles de usuários
export const userRoleEnum = pgEnum('user_role', ['admin', 'professor']);

export const users = pgTable("users", {
  id: serial("id").primaryKey(),
  username: text("username").notNull().unique(),
  password: text("password").notNull(),
  role: userRoleEnum("role").default("professor").notNull(),
  // Campos adicionais para professores
  name: text("name"),
  email: text("email"),
  phone: text("phone"),
  address: text("address"),
  specialty: text("specialty"),
  bio: text("bio"),
  hourlyRate: integer("hourly_rate"),
  specialties: text("specialties").array(),
  active: boolean("active").default(true).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertUserSchema = createInsertSchema(users).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const professorValidationSchema = insertUserSchema.extend({
  username: z.string().min(1, "O nome de usuário é obrigatório"),
  password: z.string().min(6, "A senha deve ter pelo menos 6 caracteres"),
  name: z.string().min(1, "O nome é obrigatório"),
  email: z.string().min(1, "O e-mail é obrigatório").email("E-mail inválido"),
  phone: z.string().optional(),
  specialties: z.array(z.string()).optional(),
  role: z.enum(["admin", "professor"]).default("professor"),
  active: z.boolean().default(true),
});

export type InsertUser = z.infer<typeof insertUserSchema>;
export type User = typeof users.$inferSelect;

// Tabela de treinadores/professores
export const trainers = pgTable("trainers", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  email: text("email").notNull().unique(),
  phone: text("phone"),
  specialties: text("specialties").array(),
  source: text("source").notNull(), // "Favale", "Pink", ou "FavalePink"
  active: boolean("active").default(true).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertTrainerSchema = createInsertSchema(trainers).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const trainerValidationSchema = insertTrainerSchema.extend({
  name: z.string().min(1, "O nome é obrigatório"),
  email: z.string().min(1, "O e-mail é obrigatório").email("E-mail inválido"),
  phone: z.string().optional(),
  specialties: z.array(z.string()).optional(),
  source: z.enum(["Favale", "Pink", "FavalePink"], {
    errorMap: () => ({ message: "Origem deve ser 'Favale', 'Pink' ou 'FavalePink'" })
  }),
  active: z.boolean().optional(),
});

export type InsertTrainer = z.infer<typeof insertTrainerSchema>;
export type Trainer = typeof trainers.$inferSelect;

// Tabela de alunos (expandindo leads com status "Aluno")
export const students = pgTable("students", {
  id: serial("id").primaryKey(),
  leadId: integer("lead_id").references(() => leads.id), // Referência ao lead correspondente
  address: text("address"),
  preferences: text("preferences"),
  source: text("source").notNull(), // "Favale" ou "Pink"
  active: boolean("active").default(true).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertStudentSchema = createInsertSchema(students).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const studentValidationSchema = insertStudentSchema.extend({
  leadId: z.number().int().positive("ID do lead inválido"),
  address: z.string().optional(),
  preferences: z.string().optional(),
  source: z.string().min(1, "A origem é obrigatória"),
  active: z.boolean().optional(),
});

export type InsertStudent = z.infer<typeof insertStudentSchema>;
export type Student = typeof students.$inferSelect;

// Lead schema
export const leads = pgTable("leads", {
  id: serial("id").primaryKey(),
  entryDate: timestamp("entry_date").defaultNow().notNull(),
  name: text("name").notNull(),
  email: text("email").notNull(),
  phone: text("phone").notNull(),
  state: text("state").notNull(),
  campaign: text("campaign").notNull(),
  tags: text("tags").array().notNull(),
  source: text("source").notNull(), // "Favale" or "Pink"
  status: text("status").notNull(), // "Lead" or "Aluno"
  notes: text("notes"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

// Criar um schema base para inserção de leads, omitindo campos autoincrementais/autogenerated
export const baseInsertLeadSchema = createInsertSchema(leads).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

// Schema usado para inserção no banco de dados, aceita Date ou string ISO
export const insertLeadSchema = baseInsertLeadSchema.extend({
  entryDate: z.union([
    z.string(),
    z.date()
  ]).optional(),
});

export const leadValidationSchema = insertLeadSchema.extend({
  entryDate: z.union([
    z.string().transform(val => {
      try {
        // Formatar a data se estiver no padrão DD/MM/YYYY (formato brasileiro)
        if (/^\d{2}\/\d{2}\/\d{4}$/.test(val)) {
          const [day, month, year] = val.split('/');
          return `${year}-${month}-${day}`;
        }
        // Outros formatos
        return val;
      } catch (e) {
        return val;
      }
    }).refine(value => !isNaN(Date.parse(value)), {
      message: "Data de entrada precisa ser uma data válida"
    }),
    z.date()
  ]),
  name: z.string().min(1, "O nome é obrigatório"),
  email: z.string().min(1, "O e-mail é obrigatório").email("E-mail inválido"),
  phone: z.string().min(1, "O telefone é obrigatório"),
  state: z.string().min(1, "O estado é obrigatório"),
  campaign: z.string().default("Importação em Lote"),
  source: z.string().min(1, "A origem é obrigatória"),
  status: z.string().min(1, "O status é obrigatório"),
});

export type InsertLead = z.infer<typeof insertLeadSchema>;
export type Lead = typeof leads.$inferSelect;

// Tabela de sessões de treinamento
export const sessions = pgTable("sessions", {
  id: serial("id").primaryKey(),
  startTime: timestamp("start_time").notNull(),
  endTime: timestamp("end_time").notNull(),
  leadId: integer("lead_id").references(() => leads.id).notNull(), // Referência direta ao lead (aluno)
  trainerId: integer("trainer_id").references(() => trainers.id).notNull(),
  location: text("location").notNull(), // Endereço do treino
  value: integer("value").notNull(), // Valor em centavos (R$)
  service: text("service").notNull(), // Tipo do serviço
  notes: text("notes"),
  status: text("status").default("agendado").notNull(), // agendado, concluído, cancelado, remarcado
  source: text("source").notNull(), // "Favale", "Pink" ou "FavalePink"
  // Campos para recorrência (estilo Google Calendar)
  recurrenceType: text("recurrence_type").default("none").notNull(), // none, daily, weekly, monthly, yearly, custom
  recurrenceInterval: integer("recurrence_interval").default(1), // A cada X dias/semanas/meses
  recurrenceWeekDays: text("recurrence_week_days").array(), // Para recorrência semanal: ["segunda", "quarta", "sexta"]
  recurrenceEndType: text("recurrence_end_type").default("never").notNull(), // never, date, count
  recurrenceEndDate: timestamp("recurrence_end_date"), // Data limite para recorrência
  recurrenceEndCount: integer("recurrence_end_count"), // Número de ocorrências
  recurrenceGroupId: text("recurrence_group_id"), // UUID para agrupar toda a série
  isRecurrenceParent: boolean("is_recurrence_parent").default(false), // Primeira sessão da série
  parentSessionId: integer("parent_session_id"), // ID da sessão pai (primeira da série)
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertSessionSchema = createInsertSchema(sessions).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const sessionBaseValidationSchema = insertSessionSchema.extend({
  startTime: z.preprocess((arg) => {
    if (typeof arg === "string" || arg instanceof Date) return arg;
    return undefined;
  }, z.union([
    z.string().transform(val => new Date(val)),
    z.date()
  ])).refine(date => date instanceof Date && !isNaN(date.getTime()), {
    message: "Horário de início precisa ser uma data válida"
  }),
  endTime: z.preprocess((arg) => {
    if (typeof arg === "string" || arg instanceof Date) return arg;
    return undefined;
  }, z.union([
    z.string().transform(val => new Date(val)),
    z.date()
  ])).refine(date => date instanceof Date && !isNaN(date.getTime()), {
    message: "Horário de término precisa ser uma data válida"
  }),
  leadId: z.number().int().positive("ID do aluno inválido"),
  trainerId: z.number().int().positive("ID do professor inválido"),
  location: z.string().min(1, "O local é obrigatório"),
  value: z.number().int().positive("O valor deve ser maior que zero"),
  service: z.string().min(1, "O serviço é obrigatório"),
  notes: z.string().optional(),
  status: z.enum(["agendado", "concluído", "cancelado", "remarcado"], {
    errorMap: () => ({ message: "Status deve ser 'agendado', 'concluído', 'cancelado' ou 'remarcado'" })
  }),
  source: z.enum(["Favale", "Pink", "FavalePink"], {
    errorMap: () => ({ message: "Origem deve ser 'Favale', 'Pink' ou 'FavalePink'" })
  }),
  // Campos de recorrência estilo Google Calendar
  recurrenceType: z.enum(["none", "daily", "weekly", "monthly", "yearly", "custom"], {
    errorMap: () => ({ message: "Tipo de recorrência inválido" })
  }).default("none"),
  recurrenceInterval: z.number().int().positive("Intervalo deve ser um número positivo").default(1),
  recurrenceWeekDays: z.array(z.enum(["segunda", "terca", "quarta", "quinta", "sexta", "sabado", "domingo"])).optional(),
  recurrenceEndType: z.enum(["never", "date", "count"], {
    errorMap: () => ({ message: "Tipo de fim de recorrência inválido" })
  }).default("never"),
  recurrenceEndDate: z.preprocess((arg) => {
    if (typeof arg === "string" || arg instanceof Date) return arg;
    return undefined;
  }, z.union([
    z.string().transform(val => new Date(val)),
    z.date()
  ])).optional(),
  recurrenceEndCount: z.number().int().positive("Número de ocorrências deve ser positivo").optional(),
  recurrenceGroupId: z.string().optional(),
  isRecurrenceParent: z.boolean().default(false),
  parentSessionId: z.number().int().positive("ID da sessão pai inválido").optional(),
});

// Validação adicional para a criação de sessões
export const sessionValidationSchema = sessionBaseValidationSchema.refine(
  data => {
    // Verifica se a data de término é posterior à data de início
    const startTime = data.startTime instanceof Date ? data.startTime : new Date(data.startTime as string);
    const endTime = data.endTime instanceof Date ? data.endTime : new Date(data.endTime as string);
    return endTime > startTime;
  },
  {
    message: "O horário de término deve ser posterior ao horário de início",
    path: ["endTime"],
  }
);

export type InsertSession = z.infer<typeof insertSessionSchema>;
export type Session = typeof sessions.$inferSelect;

// Tabela de histórico de alterações em sessões
export const sessionHistory = pgTable("session_history", {
  id: serial("id").primaryKey(),
  sessionId: integer("session_id").references(() => sessions.id).notNull(),
  changedAt: timestamp("changed_at").defaultNow().notNull(),
  changeType: text("change_type").notNull(), // created, updated, cancelled, rescheduled
  userId: integer("user_id").references(() => users.id).notNull(), // Quem fez a alteração
  oldValue: jsonb("old_value"), // Valor anterior (para campos alterados)
  newValue: jsonb("new_value"), // Novo valor
});

export const insertSessionHistorySchema = createInsertSchema(sessionHistory).omit({
  id: true,
});

export type InsertSessionHistory = z.infer<typeof insertSessionHistorySchema>;
export type SessionHistory = typeof sessionHistory.$inferSelect;

// WhatsApp mensagens
export const whatsappMessages = pgTable("whatsapp_messages", {
  id: serial("id").primaryKey(),
  leadId: integer("lead_id").references(() => leads.id).notNull(),
  direction: text("direction").notNull(), // "incoming" ou "outgoing"
  content: text("content").notNull(),
  status: text("status").notNull(), // "sent", "delivered", "read", "failed"
  timestamp: timestamp("timestamp").defaultNow().notNull(),
  mediaUrl: text("media_url"), // URL opcional para mídia (imagens, áudio, etc.)
  mediaType: text("media_type"), // Tipo de mídia (image, audio, video, document)
  messageId: text("message_id"), // ID da mensagem na API do WhatsApp
});

export const insertWhatsappMessageSchema = createInsertSchema(whatsappMessages).omit({
  id: true,
});

export const whatsappMessageValidationSchema = insertWhatsappMessageSchema.extend({
  leadId: z.number().int().positive("ID do lead inválido"),
  direction: z.enum(["incoming", "outgoing"], {
    errorMap: () => ({ message: "Direção deve ser 'incoming' ou 'outgoing'" })
  }),
  content: z.string().min(1, "O conteúdo da mensagem é obrigatório"),
  status: z.enum(["pending", "sent", "delivered", "read", "failed"], {
    errorMap: () => ({ message: "Status inválido" })
  }),
  mediaUrl: z.string().url("URL de mídia inválida").optional(),
  mediaType: z.enum(["image", "audio", "video", "document"], {
    errorMap: () => ({ message: "Tipo de mídia inválido" })
  }).optional(),
  messageId: z.string().optional(),
});

export type InsertWhatsappMessage = z.infer<typeof insertWhatsappMessageSchema>;
export type WhatsappMessage = typeof whatsappMessages.$inferSelect;

// Tabela de tarefas
export const tasks = pgTable("tasks", {
  id: serial("id").primaryKey(),
  title: text("title").notNull(),
  description: text("description"),
  assignedById: integer("assigned_by_id").references(() => users.id).notNull(),
  assignedToId: integer("assigned_to_id").references(() => users.id).notNull(),
  dueDate: timestamp("due_date"),
  priority: text("priority").default("medium").notNull(), // low, medium, high
  status: text("status").default("pending").notNull(), // pending, in_progress, completed, cancelled
  // relatedLeadId is kept for backward compatibility but will be phased out
  // Tasks are now assigned to system users only
  relatedLeadId: integer("related_lead_id").references(() => leads.id),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertTaskSchema = createInsertSchema(tasks).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const taskValidationSchema = insertTaskSchema.extend({
  title: z.string().min(1, "O título é obrigatório"),
  description: z.string().optional(),
  assignedById: z.number().int().positive("ID do usuário que atribuiu a tarefa inválido"),
  assignedToId: z.number().int().positive("ID do usuário atribuído inválido"),
  dueDate: z.preprocess((arg) => {
    if (typeof arg === "string" || arg instanceof Date) return arg;
    // If arg is null or undefined, let it pass to be handled by .optional()
    if (arg === null || arg === undefined) return arg;
    // For other invalid types, return undefined to trigger validation error if not optional
    return undefined;
  }, z.union([
    z.string().transform(val => new Date(val)),
    z.date()
  ])).optional().refine(date => date ? (date instanceof Date && !isNaN(date.getTime())) : true, {
    message: "Data de vencimento precisa ser uma data válida ou estar vazia"
  }),
  priority: z.enum(["low", "medium", "high"], {
    errorMap: () => ({ message: "Prioridade deve ser 'low', 'medium' ou 'high'" })
  }),
  status: z.enum(["backlog", "pending", "in_progress", "completed", "cancelled"], {
    errorMap: () => ({ message: "Status deve ser 'backlog', 'pending', 'in_progress', 'completed' ou 'cancelled'" })
  }),
  relatedLeadId: z.number().int().positive("ID do lead inválido").optional(),
});

export type InsertTask = z.infer<typeof insertTaskSchema>;
export type Task = typeof tasks.$inferSelect;

// Tabela de comentários em tarefas
export const taskComments = pgTable("task_comments", {
  id: serial("id").primaryKey(),
  taskId: integer("task_id").references(() => tasks.id).notNull(),
  userId: integer("user_id").references(() => users.id).notNull(),
  content: text("content").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertTaskCommentSchema = createInsertSchema(taskComments).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const taskCommentValidationSchema = insertTaskCommentSchema.extend({
  taskId: z.number().int().positive("ID da tarefa inválido"),
  userId: z.number().int().positive("ID do usuário inválido"),
  content: z.string().min(1, "O conteúdo é obrigatório"),
});

export type InsertTaskComment = z.infer<typeof insertTaskCommentSchema>;
export type TaskComment = typeof taskComments.$inferSelect;

// Tabela de configurações do WhatsApp/Evolution API
export const whatsappSettings = pgTable("whatsapp_settings", {
  id: serial("id").primaryKey(),
  apiUrl: text("api_url").notNull(),
  apiToken: text("api_token").notNull(),
  apiInstance: text("api_instance").notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertWhatsappSettingsSchema = createInsertSchema(whatsappSettings).omit({
  id: true,
  updatedAt: true,
});

export type InsertWhatsappSettings = z.infer<typeof insertWhatsappSettingsSchema>;
export type WhatsappSettings = typeof whatsappSettings.$inferSelect;

// Enums para o novo sistema de agendamento
export const clasStatusEnum = pgEnum('class_status', ['agendado', 'em_andamento', 'concluido', 'cancelado', 'remarcado']);
export const recurrenceTypeEnum = pgEnum('recurrence_type', ['none', 'daily', 'weekly', 'monthly', 'yearly', 'custom']);
export const recurrenceEndTypeEnum = pgEnum('recurrence_end_type', ['never', 'date', 'count']);

// Tabela de Agendamentos Recorrentes
export const agendamentosRecorrentes = pgTable("agendamentos_recorrentes", {
  id: serial("id").primaryKey(),
  professorId: integer("professor_id").references(() => users.id).notNull(),
  studentId: integer("student_id").references(() => leads.id).notNull(), // Referência ao lead/aluno
  location: text("location").notNull(),
  value: integer("value").notNull(), // Valor em centavos
  service: text("service").notNull(),
  notes: text("notes"),
  // Configurações de recorrência
  regras: jsonb("regras").notNull(), // JSON com as regras de recorrência
  startDate: timestamp("start_date").notNull(),
  endDate: timestamp("end_date"), // Data limite opcional
  maxOccurrences: integer("max_occurrences"), // Número máximo de ocorrências
  active: boolean("active").default(true).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertAgendamentoRecorrenteSchema = createInsertSchema(agendamentosRecorrentes).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const agendamentoRecorrenteValidationSchema = insertAgendamentoRecorrenteSchema.extend({
  professorId: z.number().int().positive("ID do professor inválido"),
  studentId: z.number().int().positive("ID do aluno inválido"),
  location: z.string().min(1, "O local é obrigatório"),
  value: z.number().int().positive("O valor deve ser maior que zero"),
  service: z.string().min(1, "O serviço é obrigatório"),
  notes: z.string().optional(),
  regras: z.record(z.any()), // JSON com regras de recorrência
  startDate: z.preprocess((arg) => {
    if (typeof arg === "string" || arg instanceof Date) return arg;
    return undefined;
  }, z.union([
    z.string().transform(val => new Date(val)),
    z.date()
  ])).refine(date => date instanceof Date && !isNaN(date.getTime()), {
    message: "Data de início precisa ser uma data válida"
  }),
  endDate: z.preprocess((arg) => {
    if (typeof arg === "string" || arg instanceof Date) return arg;
    return undefined;
  }, z.union([
    z.string().transform(val => new Date(val)),
    z.date()
  ])).optional(),
  maxOccurrences: z.number().int().positive("Número máximo de ocorrências deve ser positivo").optional(),
  active: z.boolean().default(true),
});

export type InsertAgendamentoRecorrente = z.infer<typeof insertAgendamentoRecorrenteSchema>;
export type AgendamentoRecorrente = typeof agendamentosRecorrentes.$inferSelect;

// Tabela de Aulas (instâncias individuais)
export const aulas = pgTable("aulas", {
  id: serial("id").primaryKey(),
  agendamentoRecorrenteId: integer("agendamento_recorrente_id").references(() => agendamentosRecorrentes.id),
  professorId: integer("professor_id").references(() => users.id).notNull(),
  studentId: integer("student_id").references(() => leads.id).notNull(),
  startTime: timestamp("start_time").notNull(),
  endTime: timestamp("end_time").notNull(),
  location: text("location").notNull(),
  value: integer("value").notNull(),
  service: text("service").notNull(),
  notes: text("notes"),
  status: clasStatusEnum("status").default("agendado").notNull(),
  // Campo para gerenciar alterações específicas de uma instância
  isModified: boolean("is_modified").default(false), // Se foi modificada em relação ao agendamento original
  originalStartTime: timestamp("original_start_time"), // Horário original antes de modificações
  originalEndTime: timestamp("original_end_time"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertAulaSchema = createInsertSchema(aulas).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const aulaValidationSchema = insertAulaSchema.extend({
  professorId: z.number().int().positive("ID do professor inválido"),
  studentId: z.number().int().positive("ID do aluno inválido"),
  startTime: z.preprocess((arg) => {
    if (typeof arg === "string" || arg instanceof Date) return arg;
    return undefined;
  }, z.union([
    z.string().transform(val => new Date(val)),
    z.date()
  ])).refine(date => date instanceof Date && !isNaN(date.getTime()), {
    message: "Horário de início precisa ser uma data válida"
  }),
  endTime: z.preprocess((arg) => {
    if (typeof arg === "string" || arg instanceof Date) return arg;
    return undefined;
  }, z.union([
    z.string().transform(val => new Date(val)),
    z.date()
  ])).refine(date => date instanceof Date && !isNaN(date.getTime()), {
    message: "Horário de término precisa ser uma data válida"
  }),
  location: z.string().min(1, "O local é obrigatório"),
  value: z.number().int().positive("O valor deve ser maior que zero"),
  service: z.string().min(1, "O serviço é obrigatório"),
  notes: z.string().optional(),
  status: z.enum(["agendado", "em_andamento", "concluido", "cancelado", "remarcado"]).default("agendado"),
  agendamentoRecorrenteId: z.number().int().positive("ID do agendamento recorrente inválido").optional(),
  isModified: z.boolean().default(false),
  originalStartTime: z.preprocess((arg) => {
    if (typeof arg === "string" || arg instanceof Date) return arg;
    return undefined;
  }, z.union([
    z.string().transform(val => new Date(val)),
    z.date()
  ])).optional(),
  originalEndTime: z.preprocess((arg) => {
    if (typeof arg === "string" || arg instanceof Date) return arg;
    return undefined;
  }, z.union([
    z.string().transform(val => new Date(val)),
    z.date()
  ])).optional(),
}).refine(
  data => {
    const startTime = data.startTime instanceof Date ? data.startTime : new Date(data.startTime as string);
    const endTime = data.endTime instanceof Date ? data.endTime : new Date(data.endTime as string);
    return endTime > startTime;
  },
  {
    message: "O horário de término deve ser posterior ao horário de início",
    path: ["endTime"],
  }
);

export type InsertAula = z.infer<typeof insertAulaSchema>;
export type Aula = typeof aulas.$inferSelect;

// Tabela de serviços
export const services = pgTable("services", {
  id: serial("id").primaryKey(),
  name: text("name").notNull().unique(),
  description: text("description"),
  duration: integer("duration").notNull(), // Duração em minutos
  price: integer("price").notNull(), // Preço em centavos
  active: boolean("active").default(true).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertServiceSchema = createInsertSchema(services).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export type InsertService = z.infer<typeof insertServiceSchema>;
export type Service = typeof services.$inferSelect;

// Interface para as regras de recorrência (JSON)
export interface IRegraRecorrencia {
  type: 'daily' | 'weekly' | 'monthly' | 'yearly' | 'custom';
  interval: number; // A cada X dias/semanas/meses
  weekDays?: string[]; // ['monday', 'wednesday', 'friday'] para recorrência semanal
  monthDay?: number; // Dia do mês (1-31) para recorrência mensal
  endType: 'never' | 'date' | 'count';
  endDate?: Date;
  endCount?: number;
}

// Tabela para armazenar sessões HTTP do express-session
export const httpSessions = pgTable("http_sessions", {
  sid: text("sid").primaryKey(),
  sess: jsonb("sess").notNull(),
  expire: timestamp("expire").notNull(),
});

export type HttpSession = typeof httpSessions.$inferSelect;
export type InsertHttpSession = typeof httpSessions.$inferInsert;
</file>

<file path="tailwind.config.ts">
import type { Config } from "tailwindcss";

export default {
  darkMode: ["class"],
  content: ["./client/index.html", "./client/src/**/*.{js,jsx,ts,tsx}"],
  theme: {
    screens: {
      'xs': '480px',
      'sm': '640px',
      'md': '768px',
      'lg': '1024px',
      'xl': '1280px',
      '2xl': '1536px',
    },
    extend: {
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      colors: {
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        chart: {
          "1": "hsl(var(--chart-1))",
          "2": "hsl(var(--chart-2))",
          "3": "hsl(var(--chart-3))",
          "4": "hsl(var(--chart-4))",
          "5": "hsl(var(--chart-5))",
        },
        sidebar: {
          DEFAULT: "hsl(var(--sidebar-background))",
          foreground: "hsl(var(--sidebar-foreground))",
          primary: "hsl(var(--sidebar-primary))",
          "primary-foreground": "hsl(var(--sidebar-primary-foreground))",
          accent: "hsl(var(--sidebar-accent))",
          "accent-foreground": "hsl(var(--sidebar-accent-foreground))",
          border: "hsl(var(--sidebar-border))",
          ring: "hsl(var(--sidebar-ring))",
        },
      },
      keyframes: {
        "accordion-down": {
          from: {
            height: "0",
          },
          to: {
            height: "var(--radix-accordion-content-height)",
          },
        },
        "accordion-up": {
          from: {
            height: "var(--radix-accordion-content-height)",
          },
          to: {
            height: "0",
          },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate"), require("@tailwindcss/typography")],
} satisfies Config;
</file>

<file path="tsconfig.json">
{
  "include": ["client/src/**/*", "shared/**/*", "server/**/*"],
  "exclude": ["node_modules", "build", "dist", "**/*.test.ts"],
  "compilerOptions": {
    "incremental": true,
    "tsBuildInfoFile": "./node_modules/typescript/tsbuildinfo",
    "noEmit": true,
    "module": "ESNext",
    "strict": true,
    "lib": ["esnext", "dom", "dom.iterable"],
    "jsx": "preserve",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "allowImportingTsExtensions": true,
    "moduleResolution": "bundler",
    "baseUrl": ".",
    "types": ["node", "vite/client"],
    "paths": {
      "@/*": ["./client/src/*"],
      "@shared/*": ["./shared/*"]
    }
  }
}
</file>

<file path="vite.config.ts">
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path from "path";
import runtimeErrorOverlay from "@replit/vite-plugin-runtime-error-modal";

export default defineConfig({
  plugins: [
    react(),
    runtimeErrorOverlay(),
    ...(process.env.NODE_ENV !== "production" &&
    process.env.REPL_ID !== undefined
      ? [
          await import("@replit/vite-plugin-cartographer").then((m) =>
            m.cartographer(),
          ),
        ]
      : []),
  ],
  resolve: {
    alias: {
      "@": path.resolve(import.meta.dirname, "client", "src"),
      "@shared": path.resolve(import.meta.dirname, "shared"),
      "@assets": path.resolve(import.meta.dirname, "attached_assets"),
    },
  },
  root: path.resolve(import.meta.dirname, "client"),
  build: {
    outDir: path.resolve(import.meta.dirname, "dist/public"),
    emptyOutDir: true,
  },
});
</file>

<file path=".gitignore">
node_modules
dist
.DS_Store
server/public
vite.config.ts.*
*.tar.gz

# Environment variables
.env
.env.local
.env.development
.env.test
.env.production
.env*.local

# API Keys and sensitive configuration
client/src/config/openai.ts

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# VS Code Server files
.config/
.vscode-server/

# Database
*.sqlite
*.db
drizzle/

# Cache
.cache/
.next/
.nuxt/

# IDE
.vscode/
.idea/

# Temporary files
*.tmp
*.temp
.temp/

# Backup files
*.bak
*.backup

# Large binary files
*.zip
*.rar

# Authentication cookies
cookies.txt

# Production configuration files
*production*.js
*production*.ts
!server/production-config.ts

# Sensitive data
*.key
*.pem
*.p12
*.cert

# Generated assets
generated-*
*.generated.*
</file>

</files>
