import { pgTable, text, serial, integer, timestamp, boolean, jsonb, pgEnum } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";

// Definindo o enum para roles de usuários
export const userRoleEnum = pgEnum('user_role', ['admin', 'professor']);

export const users = pgTable("users", {
  id: serial("id").primaryKey(),
  username: text("username").notNull().unique(),
  password: text("password").notNull(),
  role: userRoleEnum("role").default("professor").notNull(),
  // Campos adicionais para professores
  name: text("name"),
  email: text("email"),
  phone: text("phone"),
  address: text("address"),
  specialty: text("specialty"),
  bio: text("bio"),
  hourlyRate: integer("hourly_rate"),
  specialties: text("specialties").array(),
  active: boolean("active").default(true).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertUserSchema = createInsertSchema(users).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const professorValidationSchema = insertUserSchema.extend({
  username: z.string().min(1, "O nome de usuário é obrigatório"),
  password: z.string().min(6, "A senha deve ter pelo menos 6 caracteres"),
  name: z.string().min(1, "O nome é obrigatório"),
  email: z.string().min(1, "O e-mail é obrigatório").email("E-mail inválido"),
  phone: z.string().optional(),
  specialties: z.array(z.string()).optional(),
  role: z.enum(["admin", "professor"]).default("professor"),
  active: z.boolean().default(true),
});

export type InsertUser = z.infer<typeof insertUserSchema>;
export type User = typeof users.$inferSelect;

// Tabela de treinadores/professores
export const trainers = pgTable("trainers", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  email: text("email").notNull().unique(),
  phone: text("phone"),
  specialties: text("specialties").array(),
  source: text("source").notNull(), // "Favale", "Pink", ou "FavalePink"
  active: boolean("active").default(true).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertTrainerSchema = createInsertSchema(trainers).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const trainerValidationSchema = insertTrainerSchema.extend({
  name: z.string().min(1, "O nome é obrigatório"),
  email: z.string().min(1, "O e-mail é obrigatório").email("E-mail inválido"),
  phone: z.string().optional(),
  specialties: z.array(z.string()).optional(),
  source: z.enum(["Favale", "Pink", "FavalePink"], {
    errorMap: () => ({ message: "Origem deve ser 'Favale', 'Pink' ou 'FavalePink'" })
  }),
  active: z.boolean().optional(),
});

export type InsertTrainer = z.infer<typeof insertTrainerSchema>;
export type Trainer = typeof trainers.$inferSelect;

// Tabela de alunos (expandindo leads com status "Aluno")
export const students = pgTable("students", {
  id: serial("id").primaryKey(),
  leadId: integer("lead_id").references(() => leads.id), // Referência ao lead correspondente
  address: text("address"),
  preferences: text("preferences"),
  source: text("source").notNull(), // "Favale" ou "Pink"
  active: boolean("active").default(true).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertStudentSchema = createInsertSchema(students).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const studentValidationSchema = insertStudentSchema.extend({
  leadId: z.number().int().positive("ID do lead inválido"),
  address: z.string().optional(),
  preferences: z.string().optional(),
  source: z.string().min(1, "A origem é obrigatória"),
  active: z.boolean().optional(),
});

export type InsertStudent = z.infer<typeof insertStudentSchema>;
export type Student = typeof students.$inferSelect;

// Lead schema
export const leads = pgTable("leads", {
  id: serial("id").primaryKey(),
  entryDate: timestamp("entry_date").defaultNow().notNull(),
  name: text("name").notNull(),
  email: text("email").notNull(),
  phone: text("phone").notNull(),
  state: text("state").notNull(),
  campaign: text("campaign").notNull(),
  tags: text("tags").array().notNull(),
  source: text("source").notNull(), // "Favale" or "Pink"
  status: text("status").notNull(), // "Lead" or "Aluno"
  notes: text("notes"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

// Criar um schema base para inserção de leads, omitindo campos autoincrementais/autogenerated
export const baseInsertLeadSchema = createInsertSchema(leads).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

// Schema usado para inserção no banco de dados, aceita Date ou string ISO
export const insertLeadSchema = baseInsertLeadSchema.extend({
  entryDate: z.union([
    z.string(),
    z.date()
  ]).optional(),
});

export const leadValidationSchema = insertLeadSchema.extend({
  entryDate: z.union([
    z.string().transform(val => {
      try {
        // Formatar a data se estiver no padrão DD/MM/YYYY (formato brasileiro)
        if (/^\d{2}\/\d{2}\/\d{4}$/.test(val)) {
          const [day, month, year] = val.split('/');
          return `${year}-${month}-${day}`;
        }
        // Outros formatos
        return val;
      } catch (e) {
        return val;
      }
    }).refine(value => !isNaN(Date.parse(value)), {
      message: "Data de entrada precisa ser uma data válida"
    }),
    z.date()
  ]),
  name: z.string().min(1, "O nome é obrigatório"),
  email: z.string().min(1, "O e-mail é obrigatório").email("E-mail inválido"),
  phone: z.string().min(1, "O telefone é obrigatório"),
  state: z.string().min(1, "O estado é obrigatório"),
  campaign: z.string().default("Importação em Lote"),
  source: z.string().min(1, "A origem é obrigatória"),
  status: z.string().min(1, "O status é obrigatório"),
});

export type InsertLead = z.infer<typeof insertLeadSchema>;
export type Lead = typeof leads.$inferSelect;

// Tabela de sessões de treinamento
export const sessions = pgTable("sessions", {
  id: serial("id").primaryKey(),
  startTime: timestamp("start_time").notNull(),
  endTime: timestamp("end_time").notNull(),
  leadId: integer("lead_id").references(() => leads.id).notNull(), // Referência direta ao lead (aluno)
  trainerId: integer("trainer_id").references(() => trainers.id).notNull(),
  location: text("location").notNull(), // Endereço do treino
  value: integer("value").notNull(), // Valor em centavos (R$)
  service: text("service").notNull(), // Tipo do serviço
  notes: text("notes"),
  status: text("status").default("agendado").notNull(), // agendado, concluído, cancelado, remarcado
  source: text("source").notNull(), // "Favale", "Pink" ou "FavalePink"
  // Campos para recorrência (estilo Google Calendar)
  recurrenceType: text("recurrence_type").default("none").notNull(), // none, daily, weekly, monthly, yearly, custom
  recurrenceInterval: integer("recurrence_interval").default(1), // A cada X dias/semanas/meses
  recurrenceWeekDays: text("recurrence_week_days").array(), // Para recorrência semanal: ["segunda", "quarta", "sexta"]
  recurrenceEndType: text("recurrence_end_type").default("never").notNull(), // never, date, count
  recurrenceEndDate: timestamp("recurrence_end_date"), // Data limite para recorrência
  recurrenceEndCount: integer("recurrence_end_count"), // Número de ocorrências
  recurrenceGroupId: text("recurrence_group_id"), // UUID para agrupar toda a série
  isRecurrenceParent: boolean("is_recurrence_parent").default(false), // Primeira sessão da série
  parentSessionId: integer("parent_session_id"), // ID da sessão pai (primeira da série)
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertSessionSchema = createInsertSchema(sessions).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const sessionBaseValidationSchema = insertSessionSchema.extend({
  startTime: z.preprocess((arg) => {
    if (typeof arg === "string" || arg instanceof Date) return arg;
    return undefined;
  }, z.union([
    z.string().transform(val => new Date(val)),
    z.date()
  ])).refine(date => date instanceof Date && !isNaN(date.getTime()), {
    message: "Horário de início precisa ser uma data válida"
  }),
  endTime: z.preprocess((arg) => {
    if (typeof arg === "string" || arg instanceof Date) return arg;
    return undefined;
  }, z.union([
    z.string().transform(val => new Date(val)),
    z.date()
  ])).refine(date => date instanceof Date && !isNaN(date.getTime()), {
    message: "Horário de término precisa ser uma data válida"
  }),
  leadId: z.number().int().positive("ID do aluno inválido"),
  trainerId: z.number().int().positive("ID do professor inválido"),
  location: z.string().min(1, "O local é obrigatório"),
  value: z.number().int().positive("O valor deve ser maior que zero"),
  service: z.string().min(1, "O serviço é obrigatório"),
  notes: z.string().optional(),
  status: z.enum(["agendado", "concluído", "cancelado", "remarcado"], {
    errorMap: () => ({ message: "Status deve ser 'agendado', 'concluído', 'cancelado' ou 'remarcado'" })
  }),
  source: z.enum(["Favale", "Pink", "FavalePink"], {
    errorMap: () => ({ message: "Origem deve ser 'Favale', 'Pink' ou 'FavalePink'" })
  }),
  // Campos de recorrência estilo Google Calendar
  recurrenceType: z.enum(["none", "daily", "weekly", "monthly", "yearly", "custom"], {
    errorMap: () => ({ message: "Tipo de recorrência inválido" })
  }).default("none"),
  recurrenceInterval: z.number().int().positive("Intervalo deve ser um número positivo").default(1),
  recurrenceWeekDays: z.array(z.enum(["segunda", "terca", "quarta", "quinta", "sexta", "sabado", "domingo"])).optional(),
  recurrenceEndType: z.enum(["never", "date", "count"], {
    errorMap: () => ({ message: "Tipo de fim de recorrência inválido" })
  }).default("never"),
  recurrenceEndDate: z.preprocess((arg) => {
    if (typeof arg === "string" || arg instanceof Date) return arg;
    return undefined;
  }, z.union([
    z.string().transform(val => new Date(val)),
    z.date()
  ])).optional(),
  recurrenceEndCount: z.number().int().positive("Número de ocorrências deve ser positivo").optional(),
  recurrenceGroupId: z.string().optional(),
  isRecurrenceParent: z.boolean().default(false),
  parentSessionId: z.number().int().positive("ID da sessão pai inválido").optional(),
});

// Validação adicional para a criação de sessões
export const sessionValidationSchema = sessionBaseValidationSchema.refine(
  data => {
    // Verifica se a data de término é posterior à data de início
    const startTime = data.startTime instanceof Date ? data.startTime : new Date(data.startTime as string);
    const endTime = data.endTime instanceof Date ? data.endTime : new Date(data.endTime as string);
    return endTime > startTime;
  },
  {
    message: "O horário de término deve ser posterior ao horário de início",
    path: ["endTime"],
  }
);

export type InsertSession = z.infer<typeof insertSessionSchema>;
export type Session = typeof sessions.$inferSelect;

// Tabela de histórico de alterações em sessões
export const sessionHistory = pgTable("session_history", {
  id: serial("id").primaryKey(),
  sessionId: integer("session_id").references(() => sessions.id).notNull(),
  changedAt: timestamp("changed_at").defaultNow().notNull(),
  changeType: text("change_type").notNull(), // created, updated, cancelled, rescheduled
  userId: integer("user_id").references(() => users.id).notNull(), // Quem fez a alteração
  oldValue: jsonb("old_value"), // Valor anterior (para campos alterados)
  newValue: jsonb("new_value"), // Novo valor
});

export const insertSessionHistorySchema = createInsertSchema(sessionHistory).omit({
  id: true,
});

export type InsertSessionHistory = z.infer<typeof insertSessionHistorySchema>;
export type SessionHistory = typeof sessionHistory.$inferSelect;

// WhatsApp mensagens
export const whatsappMessages = pgTable("whatsapp_messages", {
  id: serial("id").primaryKey(),
  leadId: integer("lead_id").references(() => leads.id).notNull(),
  direction: text("direction").notNull(), // "incoming" ou "outgoing"
  content: text("content").notNull(),
  status: text("status").notNull(), // "sent", "delivered", "read", "failed"
  timestamp: timestamp("timestamp").defaultNow().notNull(),
  mediaUrl: text("media_url"), // URL opcional para mídia (imagens, áudio, etc.)
  mediaType: text("media_type"), // Tipo de mídia (image, audio, video, document)
  messageId: text("message_id"), // ID da mensagem na API do WhatsApp
});

export const insertWhatsappMessageSchema = createInsertSchema(whatsappMessages).omit({
  id: true,
});

export const whatsappMessageValidationSchema = insertWhatsappMessageSchema.extend({
  leadId: z.number().int().positive("ID do lead inválido"),
  direction: z.enum(["incoming", "outgoing"], {
    errorMap: () => ({ message: "Direção deve ser 'incoming' ou 'outgoing'" })
  }),
  content: z.string().min(1, "O conteúdo da mensagem é obrigatório"),
  status: z.enum(["pending", "sent", "delivered", "read", "failed"], {
    errorMap: () => ({ message: "Status inválido" })
  }),
  mediaUrl: z.string().url("URL de mídia inválida").optional(),
  mediaType: z.enum(["image", "audio", "video", "document"], {
    errorMap: () => ({ message: "Tipo de mídia inválido" })
  }).optional(),
  messageId: z.string().optional(),
});

export type InsertWhatsappMessage = z.infer<typeof insertWhatsappMessageSchema>;
export type WhatsappMessage = typeof whatsappMessages.$inferSelect;

// Tabela de tarefas
export const tasks = pgTable("tasks", {
  id: serial("id").primaryKey(),
  title: text("title").notNull(),
  description: text("description"),
  assignedById: integer("assigned_by_id").references(() => users.id).notNull(),
  assignedToId: integer("assigned_to_id").references(() => users.id).notNull(),
  dueDate: timestamp("due_date"),
  priority: text("priority").default("medium").notNull(), // low, medium, high
  status: text("status").default("pending").notNull(), // pending, in_progress, completed, cancelled
  // relatedLeadId is kept for backward compatibility but will be phased out
  // Tasks are now assigned to system users only
  relatedLeadId: integer("related_lead_id").references(() => leads.id),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertTaskSchema = createInsertSchema(tasks).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const taskValidationSchema = insertTaskSchema.extend({
  title: z.string().min(1, "O título é obrigatório"),
  description: z.string().optional(),
  assignedById: z.number().int().positive("ID do usuário que atribuiu a tarefa inválido"),
  assignedToId: z.number().int().positive("ID do usuário atribuído inválido"),
  dueDate: z.preprocess((arg) => {
    if (typeof arg === "string" || arg instanceof Date) return arg;
    // If arg is null or undefined, let it pass to be handled by .optional()
    if (arg === null || arg === undefined) return arg;
    // For other invalid types, return undefined to trigger validation error if not optional
    return undefined;
  }, z.union([
    z.string().transform(val => new Date(val)),
    z.date()
  ])).optional().refine(date => date ? (date instanceof Date && !isNaN(date.getTime())) : true, {
    message: "Data de vencimento precisa ser uma data válida ou estar vazia"
  }),
  priority: z.enum(["low", "medium", "high"], {
    errorMap: () => ({ message: "Prioridade deve ser 'low', 'medium' ou 'high'" })
  }),
  status: z.enum(["backlog", "pending", "in_progress", "completed", "cancelled"], {
    errorMap: () => ({ message: "Status deve ser 'backlog', 'pending', 'in_progress', 'completed' ou 'cancelled'" })
  }),
  relatedLeadId: z.number().int().positive("ID do lead inválido").optional(),
});

export type InsertTask = z.infer<typeof insertTaskSchema>;
export type Task = typeof tasks.$inferSelect;

// Tabela de comentários em tarefas
export const taskComments = pgTable("task_comments", {
  id: serial("id").primaryKey(),
  taskId: integer("task_id").references(() => tasks.id).notNull(),
  userId: integer("user_id").references(() => users.id).notNull(),
  content: text("content").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertTaskCommentSchema = createInsertSchema(taskComments).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const taskCommentValidationSchema = insertTaskCommentSchema.extend({
  taskId: z.number().int().positive("ID da tarefa inválido"),
  userId: z.number().int().positive("ID do usuário inválido"),
  content: z.string().min(1, "O conteúdo é obrigatório"),
});

export type InsertTaskComment = z.infer<typeof insertTaskCommentSchema>;
export type TaskComment = typeof taskComments.$inferSelect;

// Tabela de configurações do WhatsApp/Evolution API
export const whatsappSettings = pgTable("whatsapp_settings", {
  id: serial("id").primaryKey(),
  apiUrl: text("api_url").notNull(),
  apiToken: text("api_token").notNull(),
  apiInstance: text("api_instance").notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertWhatsappSettingsSchema = createInsertSchema(whatsappSettings).omit({
  id: true,
  updatedAt: true,
});

export type InsertWhatsappSettings = z.infer<typeof insertWhatsappSettingsSchema>;
export type WhatsappSettings = typeof whatsappSettings.$inferSelect;

// Enums para o novo sistema de agendamento
export const clasStatusEnum = pgEnum('class_status', ['agendado', 'em_andamento', 'concluido', 'cancelado', 'remarcado']);
export const recurrenceTypeEnum = pgEnum('recurrence_type', ['none', 'daily', 'weekly', 'monthly', 'yearly', 'custom']);
export const recurrenceEndTypeEnum = pgEnum('recurrence_end_type', ['never', 'date', 'count']);

// Tabela de Agendamentos Recorrentes
export const agendamentosRecorrentes = pgTable("agendamentos_recorrentes", {
  id: serial("id").primaryKey(),
  professorId: integer("professor_id").references(() => users.id).notNull(),
  studentId: integer("student_id").references(() => leads.id).notNull(), // Referência ao lead/aluno
  location: text("location").notNull(),
  value: integer("value").notNull(), // Valor em centavos
  service: text("service").notNull(),
  notes: text("notes"),
  // Configurações de recorrência
  regras: jsonb("regras").notNull(), // JSON com as regras de recorrência
  startDate: timestamp("start_date").notNull(),
  endDate: timestamp("end_date"), // Data limite opcional
  maxOccurrences: integer("max_occurrences"), // Número máximo de ocorrências
  active: boolean("active").default(true).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertAgendamentoRecorrenteSchema = createInsertSchema(agendamentosRecorrentes).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const agendamentoRecorrenteValidationSchema = insertAgendamentoRecorrenteSchema.extend({
  professorId: z.number().int().positive("ID do professor inválido"),
  studentId: z.number().int().positive("ID do aluno inválido"),
  location: z.string().min(1, "O local é obrigatório"),
  value: z.number().int().positive("O valor deve ser maior que zero"),
  service: z.string().min(1, "O serviço é obrigatório"),
  notes: z.string().optional(),
  regras: z.record(z.any()), // JSON com regras de recorrência
  startDate: z.preprocess((arg) => {
    if (typeof arg === "string" || arg instanceof Date) return arg;
    return undefined;
  }, z.union([
    z.string().transform(val => new Date(val)),
    z.date()
  ])).refine(date => date instanceof Date && !isNaN(date.getTime()), {
    message: "Data de início precisa ser uma data válida"
  }),
  endDate: z.preprocess((arg) => {
    if (typeof arg === "string" || arg instanceof Date) return arg;
    return undefined;
  }, z.union([
    z.string().transform(val => new Date(val)),
    z.date()
  ])).optional(),
  maxOccurrences: z.number().int().positive("Número máximo de ocorrências deve ser positivo").optional(),
  active: z.boolean().default(true),
});

export type InsertAgendamentoRecorrente = z.infer<typeof insertAgendamentoRecorrenteSchema>;
export type AgendamentoRecorrente = typeof agendamentosRecorrentes.$inferSelect;

// Tabela de Aulas (instâncias individuais)
export const aulas = pgTable("aulas", {
  id: serial("id").primaryKey(),
  agendamentoRecorrenteId: integer("agendamento_recorrente_id").references(() => agendamentosRecorrentes.id),
  professorId: integer("professor_id").references(() => users.id).notNull(),
  studentId: integer("student_id").references(() => leads.id).notNull(),
  startTime: timestamp("start_time").notNull(),
  endTime: timestamp("end_time").notNull(),
  location: text("location").notNull(),
  value: integer("value").notNull(),
  service: text("service").notNull(),
  notes: text("notes"),
  status: clasStatusEnum("status").default("agendado").notNull(),
  // Campo para gerenciar alterações específicas de uma instância
  isModified: boolean("is_modified").default(false), // Se foi modificada em relação ao agendamento original
  originalStartTime: timestamp("original_start_time"), // Horário original antes de modificações
  originalEndTime: timestamp("original_end_time"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertAulaSchema = createInsertSchema(aulas).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const aulaValidationSchema = insertAulaSchema.extend({
  professorId: z.number().int().positive("ID do professor inválido"),
  studentId: z.number().int().positive("ID do aluno inválido"),
  startTime: z.preprocess((arg) => {
    if (typeof arg === "string" || arg instanceof Date) return arg;
    return undefined;
  }, z.union([
    z.string().transform(val => new Date(val)),
    z.date()
  ])).refine(date => date instanceof Date && !isNaN(date.getTime()), {
    message: "Horário de início precisa ser uma data válida"
  }),
  endTime: z.preprocess((arg) => {
    if (typeof arg === "string" || arg instanceof Date) return arg;
    return undefined;
  }, z.union([
    z.string().transform(val => new Date(val)),
    z.date()
  ])).refine(date => date instanceof Date && !isNaN(date.getTime()), {
    message: "Horário de término precisa ser uma data válida"
  }),
  location: z.string().min(1, "O local é obrigatório"),
  value: z.number().int().positive("O valor deve ser maior que zero"),
  service: z.string().min(1, "O serviço é obrigatório"),
  notes: z.string().optional(),
  status: z.enum(["agendado", "em_andamento", "concluido", "cancelado", "remarcado"]).default("agendado"),
  agendamentoRecorrenteId: z.number().int().positive("ID do agendamento recorrente inválido").optional(),
  isModified: z.boolean().default(false),
  originalStartTime: z.preprocess((arg) => {
    if (typeof arg === "string" || arg instanceof Date) return arg;
    return undefined;
  }, z.union([
    z.string().transform(val => new Date(val)),
    z.date()
  ])).optional(),
  originalEndTime: z.preprocess((arg) => {
    if (typeof arg === "string" || arg instanceof Date) return arg;
    return undefined;
  }, z.union([
    z.string().transform(val => new Date(val)),
    z.date()
  ])).optional(),
}).refine(
  data => {
    const startTime = data.startTime instanceof Date ? data.startTime : new Date(data.startTime as string);
    const endTime = data.endTime instanceof Date ? data.endTime : new Date(data.endTime as string);
    return endTime > startTime;
  },
  {
    message: "O horário de término deve ser posterior ao horário de início",
    path: ["endTime"],
  }
);

export type InsertAula = z.infer<typeof insertAulaSchema>;
export type Aula = typeof aulas.$inferSelect;

// Tabela de serviços
export const services = pgTable("services", {
  id: serial("id").primaryKey(),
  name: text("name").notNull().unique(),
  description: text("description"),
  duration: integer("duration").notNull(), // Duração em minutos
  price: integer("price").notNull(), // Preço em centavos
  active: boolean("active").default(true).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertServiceSchema = createInsertSchema(services).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export type InsertService = z.infer<typeof insertServiceSchema>;
export type Service = typeof services.$inferSelect;

// Interface para as regras de recorrência (JSON)
export interface IRegraRecorrencia {
  type: 'daily' | 'weekly' | 'monthly' | 'yearly' | 'custom';
  interval: number; // A cada X dias/semanas/meses
  weekDays?: string[]; // ['monday', 'wednesday', 'friday'] para recorrência semanal
  monthDay?: number; // Dia do mês (1-31) para recorrência mensal
  endType: 'never' | 'date' | 'count';
  endDate?: Date;
  endCount?: number;
}

// Tabela para armazenar sessões HTTP do express-session
export const httpSessions = pgTable("http_sessions", {
  sid: text("sid").primaryKey(),
  sess: jsonb("sess").notNull(),
  expire: timestamp("expire").notNull(),
});

export type HttpSession = typeof httpSessions.$inferSelect;
export type InsertHttpSession = typeof httpSessions.$inferInsert;
